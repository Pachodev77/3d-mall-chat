<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paseo Virtual por Centro Comercial</title>
    <script>
// --- [FIX GLOBAL] Definir window.IS_MOBILE globalmente antes de cualquier otro script ---
window.window.IS_MOBILE = (typeof isMobileDevice === 'function') ? isMobileDevice() : /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
// --- [SKIN MAP GLOBAL] ---
window.skinFileMap = {
    // Kenney pack original
    humanMaleA: 'assets/kenney 3d characters/Skins/humanMaleA.png',
    humanFemaleA: 'assets/kenney 3d characters/Skins/humanFemaleA.png',
    zombieMaleA: 'assets/kenney 3d characters/Skins/zombieMaleA.png',
    zombieFemaleA: 'assets/kenney 3d characters/Skins/zombieFemaleA.png',
    // Kannei 3d characters 1
    criminalMaleA: 'assets/kannei 3d characters 1/Skins/criminalMaleA.png',
    cyborgFemaleA: 'assets/kannei 3d characters 1/Skins/cyborgFemaleA.png',
    skaterFemaleA: 'assets/kannei 3d characters 1/Skins/skaterFemaleA.png',
    skaterMaleA: 'assets/kannei 3d characters 1/Skins/skaterMaleA.png',
    // Kennei 3d characters 2
    survivorFemaleA: 'assets/kennei 3d characters 2/Skins/survivorFemaleA.png',
    survivorMaleB: 'assets/kennei 3d characters 2/Skins/survivorMaleB.png',
    zombieA: 'assets/kennei 3d characters 2/Skins/zombieA.png',
    zombieC: 'assets/kennei 3d characters 2/Skins/zombieC.png'
};

// --- [DEFAULT FURNITURE LAYOUT] ---
const DEFAULT_FURNITURE_LAYOUT = [
    {
        name: "Sof√° Lounge",
        file: "loungeSofa.glb",
        category: "Sala",
        position: { x: 0, y: 0, z: -4 },
        rotation: { y: 0 },
        scale: { x: 1, y: 1, z: 1 }
    },
    {
        name: "Mesa de Caf√©",
        file: "tableCoffee.glb",
        category: "Mesas",
        position: { x: 0, y: 0, z: -2 },
        rotation: { y: 0 },
        scale: { x: 1, y: 1, z: 1 }
    },
    {
        name: "Cama Doble",
        file: "bedDouble.glb",
        category: "Dormitorio",
        position: { x: 4, y: 0, z: 0 },
        rotation: { y: Math.PI / 2 },
        scale: { x: 1, y: 1, z: 1 }
    },
    {
        name: "Escritorio",
        file: "desk.glb",
        category: "Escritorio",
        position: { x: -4, y: 0, z: 0 },
        rotation: { y: -Math.PI / 2 },
        scale: { x: 1, y: 1, z: 1 }
    },
    {
        name: "Silla de Escritorio",
        file: "chairDesk.glb",
        category: "Escritorio",
        position: { x: -4, y: 0, z: 1 },
        rotation: { y: -Math.PI / 2 },
        scale: { x: 1, y: 1, z: 1 }
    },
    {
        name: "Estanter√≠a Abierta",
        file: "bookcaseOpen.glb",
        category: "Almacenamiento",
        position: { x: -5.5, y: 0, z: -4 },
        rotation: { y: 0 },
        scale: { x: 1, y: 1, z: 1 }
    },
    {
        name: "Planta en Maceta",
        file: "pottedPlant.glb",
        category: "Decoraci√≥n",
        position: { x: 2, y: 0, z: -5.5 },
        rotation: { y: 0 },
        scale: { x: 1, y: 1, z: 1 }
    }
];
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2409695903679883"
     crossorigin="anonymous"></script>
        <link rel="stylesheet" href="/public/style.css">
</head>
<body>
    <!-- Contenedor de UI completamente separado del canvas -->
    <div id="ui-container" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 30000;">
        <div id="ui-overlay"></div>
    <div id="crosshair"></div>
        <button id="chat-toggle-btn" title="Abrir chat" style="pointer-events: auto;">üí¨</button>
        <button id="change-alias-btn" title="Personalizar avatar" style="pointer-events: auto;">üë§</button>
        <button id="room-toggle-btn" title="Mi habitaci√≥n" style="pointer-events: auto;">üè†</button>
        <!-- Botones de piso para m√≥vil -->
        <div id="mobile-floor-buttons" style="position: fixed; top: 20px; right: 20px; display: none; flex-direction: column; gap: 10px; z-index: 35000; pointer-events: auto;">
            <button id="btn-floor-2" style="width: 70px; height: 44px; font-size: 18px; border-radius: 10px 10px 0 0; background: #4B0000; color: #fff; border: 2px solid #FFD700;">Piso 2</button>
            <button id="btn-floor-1" style="width: 70px; height: 44px; font-size: 18px; border-radius: 0 0 10px 10px; background: #4B0000; color: #fff; border: 2px solid #FFD700;">Piso 1</button>
        </div>
    </div>
    
    <!-- Bot√≥n para regresar al mall desde la habitaci√≥n -->
    <button id="return-to-mall-btn" title="Regresar al centro comercial" style="position: fixed; top: 16px; right: 16px; width: 36px; height: 36px; background: #4B0000; color: #fff; border: none; border-radius: 50%; cursor: pointer; z-index: 22000; display: none; align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(0,0,0,0.2); font-size: 16px; transition: background 0.2s; pointer-events: auto;">üè¢</button>
    
    <!-- Panel de edici√≥n de muebles -->
    <div id="furniture-edit-panel" style="position: fixed; top: 60px; right: 16px; width: 380px; height: 500px; background: rgba(30,30,30,0.95); border-radius: 12px; box-shadow: 0 4px 24px rgba(0,0,0,0.4); z-index: 31000; display: none; flex-direction: column; overflow: hidden; backdrop-filter: blur(10px); pointer-events: auto;">
        <div style="background: rgba(24,24,24,0.9); color: #fff; padding: 12px 16px; font-weight: bold; display: flex; align-items: center; justify-content: space-between;">
            <span>ü™ë Editar Muebles</span>
            <button onclick="closeFurnitureEditPanel()" style="background: none; border: none; color: #fff; font-size: 18px; cursor: pointer;">‚úñ</button>
        </div>
        <div style="padding: 16px; color: #eee;">
            <div style="margin-bottom: 16px;">
                <h3 style="margin: 0 0 8px 0; color: #27AE60;">Modo de Edici√≥n</h3>
                <p style="margin: 0; font-size: 14px; color: #ccc;">Haz clic en un mueble para seleccionarlo y luego usa las teclas para moverlo.</p>
            </div>
            <div id="furniture-list" style="max-height: 300px; overflow-y: auto; margin-bottom: 16px;">
                <!-- Lista de muebles se generar√° din√°micamente -->
            </div>
            <div style="border-top: 1px solid #333; padding-top: 16px;">
                <h4 style="margin: 0 0 12px 0; color: #F39C12; font-size: 18px;">Controles:</h4>
                <p style="margin: 0 0 6px 0; font-size: 14px;">‚Ä¢ WASD/Flechas: Mover mueble seleccionado</p>
                <p style="margin: 0 0 6px 0; font-size: 14px;">‚Ä¢ R: Rotar mueble</p>
                <p style="margin: 0 0 6px 0; font-size: 14px;">‚Ä¢ ESC: Deseleccionar</p>
                <p style="margin: 0; font-size: 14px;">‚Ä¢ Enter: Guardar posici√≥n</p>
            </div>
        </div>
    </div>
    
    <!-- Panel de selecci√≥n de muebles nuevos -->
    <div id="furniture-selection-panel" style="position: fixed; top: 60px; left: 16px; width: 400px; height: 600px; background: rgba(30,30,30,0.95); border-radius: 12px; box-shadow: 0 4px 24px rgba(0,0,0,0.4); z-index: 31000; display: none; flex-direction: column; overflow: hidden; backdrop-filter: blur(10px); pointer-events: auto;">
        <div style="background: rgba(24,24,24,0.9); color: #fff; padding: 12px 16px; font-weight: bold; display: flex; align-items: center; justify-content: space-between;">
            <span>ü™ë Agregar Muebles</span>
            <button onclick="closeFurnitureSelectionPanel()" style="background: none; border: none; color: #fff; font-size: 18px; cursor: pointer;">‚úñ</button>
        </div>
        <div style="padding: 16px; color: #eee; flex: 1; overflow: hidden; display: flex; flex-direction: column;">
            <div style="margin-bottom: 16px;">
                <h3 style="margin: 0 0 8px 0; color: #27AE60;">Muebles Disponibles</h3>
                <p style="margin: 0; font-size: 14px; color: #ccc;">Haz clic en un mueble para agregarlo a tu habitaci√≥n.</p>
            </div>
            
            <!-- Selector de categor√≠as -->
            <div style="margin-bottom: 16px;">
                <select id="furniture-category-filter" style="width: 100%; padding: 8px; background: #333; color: #fff; border: 1px solid #555; border-radius: 6px; font-size: 14px;">
                    <option value="all">Todas las categor√≠as</option>
                    <option value="Sala">Sala</option>
                    <option value="Mesas">Mesas</option>
                    <option value="Dormitorio">Dormitorio</option>
                    <option value="Cocina">Cocina</option>
                    <option value="Ba√±o">Ba√±o</option>
                    <option value="Iluminaci√≥n">Iluminaci√≥n</option>
                    <option value="Electr√≥nicos">Electr√≥nicos</option>
                    <option value="Escritorio">Escritorio</option>
                    <option value="Almacenamiento">Almacenamiento</option>
                    <option value="Decoraci√≥n">Decoraci√≥n</option>
                    <option value="Miscel√°neos">Miscel√°neos</option>
                </select>
            </div>
            
            <!-- Lista de muebles disponibles -->
            <div id="available-furniture-list" style="flex: 1; overflow-y: auto; border: 1px solid #333; border-radius: 6px; background: #222;">
                <!-- Lista de muebles se generar√° din√°micamente -->
            </div>
        </div>
    </div>
    
    <!-- Panel de navegaci√≥n de habitaci√≥n -->
    <div id="room-navigation-panel" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 400px; background: rgba(30,30,30,0.95); border-radius: 12px; box-shadow: 0 4px 24px rgba(0,0,0,0.4); z-index: 30000; display: none; flex-direction: column; overflow: hidden; backdrop-filter: blur(10px); pointer-events: auto;">
        <div style="background: rgba(24,24,24,0.9); color: #fff; padding: 12px 16px; font-weight: bold; display: flex; align-items: center; justify-content: space-between;">
            <span>üè† Mi Habitaci√≥n</span>
            <button onclick="closeRoomNavigation()" style="background: none; border: none; color: #fff; font-size: 18px; cursor: pointer;">‚úñ</button>
        </div>
        <div style="padding: 20px; color: #eee;">
            <div style="margin-bottom: 24px;">
                <h3 style="margin: 0 0 12px 0; color: #FFD700; font-size: 20px;">Bienvenido a tu espacio personal</h3>
                <p style="margin: 0; font-size: 16px; color: #ccc; line-height: 1.5;">Aqu√≠ puedes personalizar tu habitaci√≥n y relajarte en tu espacio privado.</p>
            </div>
            <button onclick="enterPersonalRoom()" style="width: 100%; padding: 16px; background: linear-gradient(135deg, #4B0000, #800000); color: #fff; border: none; border-radius: 10px; font-size: 18px; font-weight: bold; cursor: pointer; transition: all 0.3s; margin-bottom: 12px;">üö™ Entrar a mi habitaci√≥n</button>
            <button onclick="toggleFurnitureEditMode()" style="width: 100%; padding: 16px; background: linear-gradient(135deg, #27AE60, #2ECC71); color: #fff; border: none; border-radius: 10px; font-size: 18px; font-weight: bold; cursor: pointer; transition: all 0.3s; margin-bottom: 12px;">ü™ë Mover muebles</button>
            <button onclick="openFurnitureSelectionPanel()" style="width: 100%; padding: 16px; background: linear-gradient(135deg, #3498db, #2980b9); color: #fff; border: none; border-radius: 10px; font-size: 18px; font-weight: bold; cursor: pointer; transition: all 0.3s; margin-bottom: 12px;">‚ûï Agregar muebles</button>
            <button onclick="customizeRoom()" style="width: 100%; padding: 16px; background: linear-gradient(135deg, #333, #555); color: #fff; border: none; border-radius: 10px; font-size: 18px; font-weight: bold; cursor: pointer; transition: all 0.3s;">üé® Personalizar habitaci√≥n</button>
        </div>
    </div>
    
    <!-- Contenedor para ventanas de chats privados -->
    <div id="private-chats-container" style="position:fixed; bottom:20px; right:20px; z-index:40000; pointer-events:none;"></div>
    
    <!-- Controles m√≥viles -->
    <div id="mobile-controls">
        <div class="movement-controls">
            <button class="mobile-btn forward" id="mobile-forward" title="Mover adelante">‚ñ≤</button>
            <button class="mobile-btn backward" id="mobile-backward" title="Mover atr√°s">‚ñº</button>
        </div>
    </div>
    
    <!-- Controles de rotaci√≥n m√≥viles (separados a la derecha) -->
    <div id="mobile-rotation-controls">
        <div class="rotation-controls">
            <button class="mobile-btn left" id="mobile-left" title="Rotar izquierda">‚óÄ</button>
            <button class="mobile-btn right" id="mobile-right" title="Rotar derecha">‚ñ∂</button>
        </div>
    </div>
        <!-- Panel de personalizaci√≥n completamente redise√±ado -->
    <div id="simple-panel" class="customization-panel" style="min-width:340px; max-width:420px; width:90vw; min-height:480px; max-height:90vh; height:auto; display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(24,24,24,0.98); border-radius:16px; box-shadow:0 8px 32px rgba(0,0,0,0.6); z-index:31000; flex-direction:column; overflow:auto; pointer-events:auto; padding:0;">
        <!-- Header elegante -->
        <div class="panel-header">
            <div>
                <span>üë§</span>
                <span>Personalizar Avatar</span>
            </div>
            <button onclick="closeSimplePanel()" class="close-btn">‚úñ</button>
        </div>
        
        <!-- Contenido principal -->
        <div class="panel-content">
            <div class="options-column" style="width:100%;align-items:center;justify-content:center;">
                <div class="option-section" style="display: flex; flex-direction: column; align-items: center; gap: 24px; margin-top: 24px;">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <button id="skin-prev-btn" class="skin-arrow-btn" title="Anterior" style="font-size: 28px; background: none; border: none; color: #FFD700; cursor: pointer;">‚óÄ</button>
                        <div id="skin-preview-container" style="display: flex; flex-direction: column; align-items: center;">
                            <div id="avatar-3d-preview-container" style="width: 180px; height: 240px; background: #222; border-radius: 14px; border: 2px solid #FFD700; box-shadow: 0 2px 12px rgba(0,0,0,0.3); margin-bottom: 10px; display: flex; align-items: center; justify-content: center; overflow: hidden;"></div>
                            <div id="skin-preview-label" style="color: #FFD700; font-size: 14px; font-weight: bold; text-align: center; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">Humano Masculino</div>
                        </div>
                        <button id="skin-next-btn" class="skin-arrow-btn" title="Siguiente" style="font-size: 28px; background: none; border: none; color: #FFD700; cursor: pointer;">‚ñ∂</button>
                    </div>
                </div>
                <div class="option-section" style="margin-top: 32px; width: 100%;">
                    <h3 class="section-title" style="margin-bottom: 8px; text-align:center;">
                        <span class="section-icon">üìù</span>
                        Nombre del Avatar
                    </h3>
                    <input type="text" id="simple-alias-input" placeholder="Escribe tu nombre..." maxlength="20" style="width: 100%; min-width: 180px; padding: 14px; border-radius: 8px; border: 2px solid #FFD700; background: #232323; color: #FFD700; font-size: 18px; font-weight: bold; text-align: center; margin-top: 6px; margin-bottom: 6px;">
                </div>
            </div>
        </div>
        <div class="panel-footer">
            <button onclick="resetSimpleCustomization()" style="padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; background: linear-gradient(135deg, #555, #777); color: #fff; transition: all 0.3s; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">üîÑ Restablecer</button>
            <button onclick="saveSimpleCustomization()" style="padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; background: linear-gradient(135deg, #4B0000, #800000); color: #fff; transition: all 0.3s; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">üíæ Guardar</button>
        </div>
    </div>
    <div id="chat-panel">
        <div id="chat-header">
            Chat
            <button id="chat-close-btn" title="Cerrar">‚úñ</button>
        </div>
        <div id="chat-content">
            <div id="chat-main">
                <div id="chat-messages"></div>
                <div id="chat-input-area">
                    <button id="emoji-toggle" title="Emojis">üòä</button>
                    <input id="chat-input" type="text" placeholder="Escribe un mensaje..." autocomplete="off" />
                    <button id="chat-send-btn">Enviar</button>
                </div>
                <div id="emoji-panel"></div>
            </div>
            <div id="users-sidebar">
                <div id="users-title">Usuarios</div>
                <div id="users-list"></div>
            </div>
        </div>
    </div>
    
    <!-- Panel de personalizaci√≥n de avatar -->
    <!-- Eliminado: <div id="customization-panel">...</div> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.4/umd/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.min.js"></script>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script type="module" src="/public/furniture-persistence.js"></script>
    <script src="./firebase-config.js"></script>
    <script>
        // URLs de las tiendas proporcionadas por el usuario (duplicadas para llenar todos los pisos)
        const originalStoreLinks = [
            "https://www.ipweb.pro/en/?Davincho88", "https://ipgold.biz/?r=meramente42@gmail.com", "https://surfe.be/ext/2837287",
            "https://sproutgigs.com/?a=0675642e", "https://r.adbtc.top/2847448", "https://www.coinpayu.com/?r=everest101",
            "https://surfio.site/i/794", "https://serfclick.net/i/277142", "https://faucetcrypto.com/r/1373767",
            "https://earnbitmoon.club/?ref=1075373", "https://viefaucet.com?r=6383ddeaec6d7776fc69e555", "https://simplebits.io/ref/OLkiv6stfLj_",
            "https://tap-coin.de/refer/user/4365", "https://btcadspace.com/ref/p4ch3c0", "https://trustdice.win/faucet/?ref=u_mapachox101",
            "http://cointiply.com/r/4yDJAp", "https://autofaucet.dutchycorp.space/?r=sakreto", "https://freebitco.in/?r=49843181",
            "https://faucetpay.io/?r=2136351", "https://r.honeygain.me/MERAM588A9", "https://pawns.app/?r=585883",
            "https://teaserfast.ru/u/mapachox", "https://addon.money/p/343495", "https://everve.net/ref/961754/",
            "https://swashapp.io/download?referral_code=3opl7k4ztf53", "https://addslice.com/?crew=JHVJ6", "https://earnapp.com/i/4zbftm2",
            "https://node.optimai.network/register?ref=F471454F", "https://dashboard.teneo.pro/auth/signup?referralCode=ERPr2", "https://app.nodepay.ai/register?ref=kOYHwfDuFNSSZg2",
            "https://www.jumptask.io/r/budapygirazu", "https://payeer.com/?partner=23994523", "https://rollercoin.com/?r=m9dnpgsp",
            "https://bux.money/u/239006", "https://www.swagbucks.com/p/register?rb=119244201&rp=1", "https://app.getgrass.io/register?referralCode=SwWRadefuICY8DI",
            "https://freecash.com/r/116249823271721789104", "https://r.honeygain.me/AIRRIFADB7", "https://www.binance.com/referral/earn-together/refertoearn2000usdc/claim?hl=en&ref=GRO_14352_ZBFKF",
            "https://www.paidwork.com/?r=meramente42", "https://www.bybit.com/invite?ref=VWN6NL", "https://app-earnings-link.com/givvyMusic/hoty216dfkvisgv",
            "https://swcapp.com/i/davehz", "https://app-earnings-link.com/givvyStream/a6dd8fsmn6t6qhfjjw5", "https://app-earnings-link.com/givvyScratchCardNew/euz9t4x3bmk6"
        ];

        // Mapeo de dominios a nombres de archivo de logos
        const domainToLogoMap = {
            'ipweb': 'ipweb-logo.png',
            'ipgold': 'ipgold-logo.png',
            'surfe': 'surfe-logo.png',
            'sproutgigs': 'sproutgigs-logo.png',
            'adbtc': 'adbtc-logo.png',
            'coinpayu': 'coinpayu-logo.png',
            'surfio': 'surfio-logo.png',
            'serfclick': 'serfclick-logo.png',
            'faucetcrypto': 'faucetcrypto-logo.png',
            'earnbitmoon': 'earnbitmoon-logo.png',
            'viefaucet': 'viefaucet-logo.png',
            'simplebits': 'simplebits-logo.png',
            'tap-coin': 'tapcoin-logo.png',
            'btcadspace': 'btcadspace-logo.png',
            'trustdice': 'trustdice-logo.png',
            'cointiply': 'cointiply-logo.png',
            'autofaucet': 'autofaucet-logo.png',
            'freebitco': 'freebitcoin-logo.png',
            'faucetpay': 'faucetpay-logo.png',
            'honeygain': 'honeygain-logo.png',
            'pawns': 'pawns-logo.png',
            'teaserfast': 'teaserfast-logo.png',
            'addon': 'addonmoney-logo.png',
            'everve': 'everve-logo.png',
            'swashapp': 'swash-logo.png',
            'addslice': 'addslice-logo.png',
            'earnapp': 'earnapp-logo.png',
            'optimai': 'optimai-logo.png',
            'teneo': 'teneo-logo.png',
            'nodepay': 'nodepay-logo.png',
            'jumptask': 'jumptask-logo.png',
            'payeer': 'payeer-logo.png',
            'rollercoin': 'rollercoin-logo.png',
            'bux': 'buxmoney-logo.png',
            'swagbucks': 'swagbucks-logo.png',
            'grass': 'grass-logo.png',
            'getgrass': 'grass-logo.png', // Agregar alias para app.getgrass.io
            'freecash': 'freecash-logo.png',
            'binance': 'binance-logo.png',
            'paidwork': 'paidwork-logo.png',
            'bybit': 'bybit-logo.png',
            'givvyMusic': 'givvymusic-logo.png',
            'givvyStream': 'givvystream-logo.png',
            'givvyScratchCardNew': 'givvystream-logo.png', // Usar givvystream como fallback
            'swcapp': 'swcapp-logo.png',
            'app-earnings-link': 'givvystream-logo.png' // Agregar alias para app-earnings-link.com
        };

        // Duplicar los enlaces 5 veces para asegurar que hay suficientes para todos los pisos
        const storeLinks = [];
        for (let i = 0; i < 5; i++) {
            storeLinks.push(...originalStoreLinks);
        }

        // --- Constantes y Configuraci√≥n Global ---
        const HALL_SIZE = 90; // Aumentado 1.5 veces (60 * 1.5 = 90)
const HALL_HEIGHT = 4;
// --- [FIX] Definir window.IS_MOBILE globalmente antes de cualquier uso ---

// Ajustar velocidad de movimiento seg√∫n dispositivo
const MOVE_SPEED = window.IS_MOBILE ? 0.35 : 0.5; // M√°s lento en ambos, a√∫n m√°s en m√≥vil
        const ROTATE_SPEED = window.IS_MOBILE ? 0.06 : 0.07; // Rotaci√≥n m√°s lenta tambi√©n
        const CAMERA_HEIGHT = 1.6;
        const MAX_FLOOR = 1; // Cambiado de 4 a 1 (solo 2 pisos: planta baja + 1 piso superior)
        const MIN_FLOOR = 0;
        // --- Dimensiones globales de la habitaci√≥n personal ---
        const roomWidth = 12, roomHeight = 3.5, roomDepth = 12;

        // --- Variables de la Escena ---
        let scene, camera, renderer;
        const clickableObjects = [];
        const collisionObjects = [];
        const keys = { W: false, S: false, A: false, D: false, ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        
        // Reloj para animaciones
        const clock = new THREE.Clock();
        
        // --- Variables para Avatares de Usuarios ---
        const userAvatars = new Map(); // Mapa de alias -> avatar
        const avatarColors = [
            0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFFEAA7,
            0xDDA0DD, 0x98D8C8, 0xF7DC6F, 0xBB8FCE, 0x85C1E9,
            0xF8C471, 0x82E0AA, 0xF1948A, 0x85C1E9, 0xD7BDE2,
            0xF9E79F, 0xABEBC6, 0xFAD7A0, 0xAED6F1, 0xF5B7B1
        ];

        // --- Variables de personalizaci√≥n de avatar ---
        
        
        window.currentCustomization = {
            skin: 'humanMaleA' // Skin por defecto
        };
        
        let customizationPanelOpen = false;
        
        // --- Variables para el sistema de habitaciones personales ---
        let currentScene = 'mall'; // 'mall' o 'personal-room'
        // --- Variables de la habitaci√≥n personal ---
        // personalRoomScene est√° definido en furniture-persistence.js
        let personalRoomCamera, personalRoomRenderer;
        let roomNavigationPanelOpen = false;
        let personalRoomTargetPosition, personalRoomTargetRotationY;
        
        // --- Variables para el sistema de edici√≥n de muebles ---
        let furnitureEditMode = false;
        let selectedFurniture = null;
        // furnitureObjects ahora est√° definido en furniture-persistence.js
        let furnitureEditPanelOpen = false;

        // --- Variables de Interacci√≥n y Movimiento ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let targetPosition;
        let targetRotationY;
        let currentFloor = 0;
        let keyA = false;
        let keyD = false;
        let keyW = false;
        let keyS = false;
        let shopNumberCounter = 1; // Contador global para numerar las tiendas
        
        // --- Variables para controles m√≥viles ---
        let mobileForward = false;
        let mobileBackward = false;
        let mobileLeft = false;
        let mobileRight = false;

        // Funci√≥n para obtener el siguiente n√∫mero de tienda solo cuando se crea una
        const getNextShopNumber = () => {
            return shopNumberCounter++;
        };

        // --- Variables de rendimiento y timing centralizado ---
        let lastTime = 0;
        let frameCount = 0;
        let fps = 60;
        const targetFPS = 60;
        const frameInterval = 1000 / targetFPS;
        
        // Variables de timing para actualizaciones peri√≥dicas
        let lastSkyUpdate = 0;
        let lastPositionUpdate = 0;
        let lastRotatingSignUpdate = 0;
        let lastClockUpdate = 0;
        
        // Configuraci√≥n de intervalos (en milisegundos)
        const UPDATE_INTERVALS = {
            SKY: 60000,        // 1 minuto
            POSITION: 500,     // 500ms
            ROTATING_SIGN: 2500, // 2.5 segundos
            CLOCK: 1000        // 1 segundo
        };
        
        // Sistema de timing centralizado
        const timingSystem = {
            shouldUpdate: (lastUpdate, interval) => {
                return Date.now() - lastUpdate >= interval;
            },
            updateLastTime: (type) => {
                switch(type) {
                    case 'SKY': lastSkyUpdate = Date.now(); break;
                    case 'POSITION': lastPositionUpdate = Date.now(); break;
                    case 'ROTATING_SIGN': lastRotatingSignUpdate = Date.now(); break;
                    case 'CLOCK': lastClockUpdate = Date.now(); break;
                }
            }
        };

        // --- Performance Monitoring ---
        const stats = new (function() {
            this.fps = 0;
            this.lastFpsUpdate = 0;
            this.frameCount = 0;
            this.memory = {
                textures: 0,
                geometries: 0,
                materials: 0
            };
            
            this.update = function(currentTime) {
                this.frameCount++;
                if (!this.lastFpsUpdate) this.lastFpsUpdate = currentTime;
                
                if (currentTime - this.lastFpsUpdate >= 1000) {
                    this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastFpsUpdate));
                    this.frameCount = 0;
                    this.lastFpsUpdate = currentTime;
                    
                    // Log memory usage every 5 seconds
                    if (performance.memory) {
                        console.log('Memory Usage (MB):', {
                            used: Math.round(performance.memory.usedJSHeapSize / 1048576 * 100) / 100,
                            total: Math.round(performance.memory.totalJSHeapSize / 1048576 * 100) / 100,
                            limit: Math.round(performance.memory.jsHeapSizeLimit / 1048576 * 100) / 100
                        });
                    }
                }
            };
        })();
        
        // --- Texture and Material Management ---
        const textureCache = new Map();
        const materialCache = new Map();
        const loadedTextures = new Set();
        
        // Device capability detection
        const isLowEndDevice = (() => {
            const userAgent = navigator.userAgent.toLowerCase();
            const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent);
            const memory = performance.memory;
            const isLowMemory = memory ? memory.totalJSHeapSize < 1073741824 : true; // < 1GB
            return isMobile || isLowMemory;
        })();
        
        // Texture quality settings based on device
        const textureSettings = {
            maxSize: isLowEndDevice ? 1024 : 2048,  // Lower max texture size for mobile
            quality: isLowEndDevice ? 0.7 : 1.0,    // Lower quality for mobile
            mipmaps: !isLowEndDevice,                // Disable mipmaps on low-end
            anisotropy: isLowEndDevice ? 1 : 2       // Lower anisotropy on mobile
        };

        function getCachedMaterial(color, roughness = 0.8, metalness = 0.2) {
            const key = `${color}-${roughness}-${metalness}`;
            if (!materialCache.has(key)) {
                materialCache.set(key, new THREE.MeshStandardMaterial({ 
                    color, 
                    roughness, 
                    metalness 
                }));
            }
            return materialCache.get(key);
        }

        function getCachedTexture(text, colorIdx, width, height) {
            const key = `${text}-${colorIdx}-${width}-${height}`;
            if (!textureCache.has(key)) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const canvasW = Math.min(512, width * 64); // Reducir tama√±o del canvas
                const canvasH = Math.min(512, height * 64);
                canvas.width = canvasW;
                canvas.height = canvasH;
                
                context.fillStyle = `hsl(${colorIdx * 47 % 360}, 60%, 50%)`;
                context.fillRect(0, 0, canvasW, canvasH);
                
                context.font = `bold ${canvasH * 0.3}px Arial`;
                context.fillStyle = 'white';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text.charAt(0).toUpperCase() + text.slice(1), canvasW / 2, canvasH / 2);

                const texture = new THREE.CanvasTexture(canvas);
                textureCache.set(key, texture);
            }
            return textureCache.get(key);
        }

        // --- Funci√≥n para obtener el color del cielo seg√∫n la hora ---
        function getSkyColor() {
            const now = new Date();
            const hour = now.getHours();
            
            // Transiciones suaves entre colores seg√∫n la hora
            if (hour >= 6 && hour < 12) {
                // Ma√±ana: azul claro
                return new THREE.Color(0x87CEEB); // Sky blue
            } else if (hour >= 12 && hour < 18) {
                // Tarde: azul m√°s intenso
                return new THREE.Color(0x4682B4); // Steel blue
            } else if (hour >= 18 && hour < 20) {
                // Atardecer: naranja/rosa
                return new THREE.Color(0xFF7F50); // Coral
            } else if (hour >= 20 && hour < 22) {
                // Anochecer: azul oscuro
                return new THREE.Color(0x191970); // Midnight blue
            } else {
                // Noche: negro
                return new THREE.Color(0x000000); // Black
            }
        }

        function init() {
            // --- Configuraci√≥n de la Escena, C√°mara y Renderer ---
            setupScene();
            setupLighting();
            createMall();

            // --- Event Listeners ---
            setupEventListeners();
            
            // --- Configurar botones de UI ---
            setupUIButtons();

            // --- Env√≠o peri√≥dico robusto de posici√≥n/timestamp a Firebase ---
            if (typeof sendPosition === 'function') {
                setInterval(() => {
                    // Obt√©n la posici√≥n, piso y rotaci√≥n actual del usuario
                    if (typeof camera !== 'undefined' && typeof currentFloor !== 'undefined' && typeof camera !== 'undefined') {
                        const position = camera.position ? { x: camera.position.x, y: camera.position.y, z: camera.position.z } : { x: 0, y: 0, z: 0 };
                        const rotation = camera.rotation ? camera.rotation.y : 0;
                        sendPosition(position, currentFloor, rotation);
                    }
                }, 10000); // cada 10 segundos
            }

            // --- Iniciar Animaci√≥n ---
            animate();
        }

        function setupScene() {
            scene = new THREE.Scene();
            scene.background = getSkyColor(); // Color din√°mico del cielo
            scene.fog = new THREE.Fog(0x1a1a1a, 15, 105); // Ajustado para el nuevo tama√±o

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(25, CAMERA_HEIGHT, 25); // Posici√≥n m√°s cerca del centro
            camera.lookAt(HALL_SIZE / 2, CAMERA_HEIGHT, HALL_SIZE / 2);

            targetPosition = camera.position.clone();
            targetRotationY = camera.rotation.y;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limitar pixel ratio
            renderer.shadowMap.enabled = false; // Desactivar sombras completamente
            renderer.domElement.style.zIndex = '1'; // Asegurar que el canvas est√© por debajo de la UI
            document.body.appendChild(renderer.domElement);
        }

        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // Aumentar intensidad para compensar falta de sombras
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); // Reducir intensidad
            directionalLight.position.set(30, 45, 15); // Ajustado para el nuevo tama√±o
            directionalLight.castShadow = false; // Desactivar sombras
            scene.add(directionalLight);
        }

        function createMall() {
            // --- Materiales ---
            const floorMaterial = getCachedMaterial(0x444444, 0.8, 0.2);
            const wallMaterial = getCachedMaterial(0x6B8E23, 0.9); // Verde oliva
            const separatorMaterial = getCachedMaterial(0xFFFFFF, 0.9); // Blanco para muros separadores

            // --- Creaci√≥n del Centro Comercial ---
            let linkIndex = 0;
            
            // Planta baja con tiendas
            linkIndex = createFloorLevel(0, floorMaterial, wallMaterial, separatorMaterial, linkIndex);
            
            // Solo un piso superior con tiendas y pasillos (piso 1)
            const floorY = 1 * (HALL_HEIGHT + 1);
            linkIndex = createUpperFloorLevel(floorY, floorMaterial, wallMaterial, separatorMaterial, linkIndex);

            // --- Estructura Central completa ---
            const centralStructureY = 0;
            const cubeSize = 6;
            createCentralCubeScreens(HALL_SIZE / 2, centralStructureY, HALL_SIZE / 2, cubeSize, storeLinks.slice(0, 4), 0, 2500);
            createCentralCubeScreens(HALL_SIZE / 2, centralStructureY + cubeSize * 0.8, HALL_SIZE / 2, cubeSize, storeLinks.slice(4, 8), 100, 2000);
            createCentralCubeScreens(HALL_SIZE / 2, centralStructureY + cubeSize * 1.6, HALL_SIZE / 2, cubeSize, storeLinks.slice(8, 12), 200, 1800);
            const clockCubeY = centralStructureY + cubeSize * 2.4;
            createDigitalClockCube(HALL_SIZE / 2, clockCubeY, HALL_SIZE / 2, cubeSize);

            // C√∫pula
            const pyramidHeight = cubeSize * 1.5;
            const pyramidGeometry = new THREE.ConeGeometry(cubeSize / Math.SQRT2 * 1.2, pyramidHeight, 4);
            const pyramidMaterial = getCachedMaterial(0xA0522D, 0.8, 0.1); // Sienna
            const pyramid = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
            pyramid.position.set(HALL_SIZE / 2, clockCubeY + cubeSize * 0.8 + pyramidHeight / 2, HALL_SIZE / 2);
            pyramid.rotation.y = Math.PI / 4;
            // pyramid.castShadow = false; // Desactivar sombras para mejor rendimiento
            // pyramid.receiveShadow = true;
            scene.add(pyramid);

            // Crear √°rea de descanso completa (restaurar 8 mesas)
            const gardenRadius = 8;
            const tableCount = 8; // Restaurar 8 mesas
            
            for (let i = 0; i < tableCount; i++) {
                const angle = (i / tableCount) * Math.PI * 2;
                const radius = gardenRadius + Math.random() * 2 - 1; // Variaci√≥n en el radio
                
                // Crear mesa
                const tableTopGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.1, 8);
                const tableTopMaterial = getCachedMaterial(new THREE.Color().setHSL(0.1, 0.3, 0.7));
                const tableTop = new THREE.Mesh(tableTopGeometry, tableTopMaterial);
                
                // Patas de la mesa
                const tableLegGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.7, 6);
                const tableLegMaterial = getCachedMaterial(new THREE.Color().setHSL(0.05, 0.2, 0.5));
                
                // Posicionar mesa
                const tableX = HALL_SIZE / 2 + Math.cos(angle) * radius;
                const tableZ = HALL_SIZE / 2 + Math.sin(angle) * radius;
                
                tableTop.position.set(tableX, 0.85, tableZ);
                // tableTop.castShadow = false; // Desactivar sombras para mejor rendimiento
                // tableTop.receiveShadow = true;
                scene.add(tableTop);
                
                // Agregar 4 patas a la mesa
                for (let j = 0; j < 4; j++) {
                    const legAngle = (j / 4) * Math.PI * 2;
                    const legRadius = 0.6;
                    const leg = new THREE.Mesh(tableLegGeometry, tableLegMaterial);
                    leg.position.set(
                        tableX + Math.cos(legAngle) * legRadius,
                        0.35,
                        tableZ + Math.sin(legAngle) * legRadius
                    );
                    // leg.castShadow = false; // Desactivar sombras para mejor rendimiento
                    // leg.receiveShadow = true;
                    scene.add(leg);
                }
                
                // Crear parasol sobre la mesa
                const parasolPoleGeometry = new THREE.CylinderGeometry(0.03, 0.03, 2.5, 6);
                const parasolPoleMaterial = getCachedMaterial(new THREE.Color().setHSL(0.05, 0.2, 0.5));
                const parasolPole = new THREE.Mesh(parasolPoleGeometry, parasolPoleMaterial);
                parasolPole.position.set(tableX, 2.1, tableZ);
                // parasolPole.castShadow = false; // Desactivar sombras para mejor rendimiento
                // parasolPole.receiveShadow = true;
                scene.add(parasolPole);
                
                // Tela del parasol
                const parasolGeometry = new THREE.ConeGeometry(1.2, 0.3, 8);
                const parasolMaterial = getCachedMaterial(0x000080); // Azul oscuro
                const parasol = new THREE.Mesh(parasolGeometry, parasolMaterial);
                parasol.position.set(tableX, 3.25, tableZ);
                parasol.rotation.x = 0; // Quitar la rotaci√≥n para que apunte hacia arriba (invertido)
                // parasol.castShadow = false; // Desactivar sombras para mejor rendimiento
                // parasol.receiveShadow = true;
                scene.add(parasol);
                
                // Crear sillas completas (restaurar 4 sillas por mesa)
                const chairCount = 4; // Restaurar 4 sillas
                for (let k = 0; k < chairCount; k++) {
                    // Posicionar sillas en los 4 puntos cardinales alrededor de la mesa
                    const chairAngle = (k / chairCount) * Math.PI * 2; // 0¬∞, 90¬∞, 180¬∞, 270¬∞
                    const chairRadius = 1.8; // Distancia fija desde la mesa
                    
                    // Asiento de la silla
                    const seatGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.4);
                    const seatMaterial = getCachedMaterial(new THREE.Color().setHSL(0.08, 0.4, 0.6));
                    const seat = new THREE.Mesh(seatGeometry, seatMaterial);
                    
                    const chairX = tableX + Math.cos(chairAngle) * chairRadius;
                    const chairZ = tableZ + Math.sin(chairAngle) * chairRadius;
                    
                    seat.position.set(chairX, 0.45, chairZ);
                    // seat.castShadow = false; // Desactivar sombras para mejor rendimiento
                    // seat.receiveShadow = true;
                    scene.add(seat);
                    

                    
                    // Patas de la silla
                    for (let l = 0; l < 4; l++) {
                        const chairLegGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.45, 6);
                        const chairLegMaterial = getCachedMaterial(new THREE.Color().setHSL(0.05, 0.2, 0.5));
                        const chairLeg = new THREE.Mesh(chairLegGeometry, chairLegMaterial);
                        
                        const legOffsetX = (l % 2 === 0 ? -1 : 1) * 0.15;
                        const legOffsetZ = (l < 2 ? -1 : 1) * 0.15;
                        
                        chairLeg.position.set(chairX + legOffsetX, 0.225, chairZ + legOffsetZ);
                        // chairLeg.castShadow = false; // Desactivar sombras para mejor rendimiento
                        // chairLeg.receiveShadow = true;
                        scene.add(chairLeg);
                    }
                }
            }
        }

        // --- Funci√≥n refactorizada para crear filas de tiendas ---
        function createStoreRow(axis, position, count, storeWidth, storeSpacing, initialOffset, yOffset, wallMaterial, startLinkIndex, isCornerPosition) {
            let linkIndex = startLinkIndex;
            const stores = [];
            
            // Configuraci√≥n seg√∫n el eje
            const config = {
                'north': {
                    position: (i) => new THREE.Vector3(initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2, yOffset + HALL_HEIGHT / 2, position),
                    rotation: 0,
                    direction: 1, // izquierda a derecha
                    skipCorners: true
                },
                'south': {
                    position: (i) => new THREE.Vector3(initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2, yOffset + HALL_HEIGHT / 2, position),
                    rotation: Math.PI,
                    direction: -1, // derecha a izquierda
                    skipCorners: true
                },
                'east': {
                    position: (i) => new THREE.Vector3(position, yOffset + HALL_HEIGHT / 2, initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2),
                    rotation: -Math.PI / 2,
                    direction: 1, // arriba hacia abajo
                    skipCorners: true
                },
                'west': {
                    position: (i) => new THREE.Vector3(position, yOffset + HALL_HEIGHT / 2, initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2),
                    rotation: Math.PI / 2,
                    direction: -1, // abajo hacia arriba
                    skipCorners: true
                }
            };
            
            const axisConfig = config[axis];
            if (!axisConfig) return { linkIndex, stores };
            
            const start = axisConfig.direction > 0 ? 0 : count - 1;
            const end = axisConfig.direction > 0 ? count : -1;
            const step = axisConfig.direction;
            
            for (let i = start; i !== end; i += step) {
                if (axisConfig.skipCorners && isCornerPosition(i, axis)) continue;
                
                const storePos = axisConfig.position(i);
                const currentLinkIndex = linkIndex % storeLinks.length;
                
                const store = createStore(
                    storePos,
                    new THREE.Vector2(storeWidth, HALL_HEIGHT),
                    axisConfig.rotation,
                    currentLinkIndex,
                    12, // storeDepth
                    wallMaterial,
                    yOffset,
                    getNextShopNumber()
                );
                
                stores.push(store);
                linkIndex++;
            }
            
            return { linkIndex, stores };
        }

        // --- Funci√≥n refactorizada para crear muros separadores ---
        function createSeparatorWalls(axis, position, count, storeWidth, storeSpacing, initialOffset, yOffset, separatorMaterial) {
            const walls = [];
            
            // Configuraci√≥n seg√∫n el eje
            const config = {
                'north': {
                    geometry: () => new THREE.BoxGeometry(storeSpacing, HALL_HEIGHT + 1, 0.2),
                    position: (i) => new THREE.Vector3(initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2, yOffset + (HALL_HEIGHT + 1) / 2, position)
                },
                'south': {
                    geometry: () => new THREE.BoxGeometry(storeSpacing, HALL_HEIGHT + 1, 0.2),
                    position: (i) => new THREE.Vector3(initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2, yOffset + (HALL_HEIGHT + 1) / 2, position)
                },
                'east': {
                    geometry: () => new THREE.BoxGeometry(0.2, HALL_HEIGHT + 1, storeSpacing),
                    position: (i) => new THREE.Vector3(position, yOffset + (HALL_HEIGHT + 1) / 2, initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2)
                },
                'west': {
                    geometry: () => new THREE.BoxGeometry(0.2, HALL_HEIGHT + 1, storeSpacing),
                    position: (i) => new THREE.Vector3(position, yOffset + (HALL_HEIGHT + 1) / 2, initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2)
                }
            };
            
            const axisConfig = config[axis];
            if (!axisConfig) return walls;
            
            for (let i = 0; i < count - 1; i++) {
                const wall = new THREE.Mesh(axisConfig.geometry(), separatorMaterial);
                wall.position.copy(axisConfig.position(i));
                scene.add(wall);
                collisionObjects.push(new THREE.Box3().setFromObject(wall));
                walls.push(wall);
            }
            
            return walls;
        }

        function createFloorLevel(yOffset, floorMaterial, wallMaterial, separatorMaterial, startLinkIndex) {
            // --- Suelo con textura de madera realista ---
            // Crear textura de madera usando canvas
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Configuraci√≥n de la textura de madera
            const boardWidth = 64; // Ancho de cada tabla de madera
            const boardHeight = 512; // Altura de cada tabla
            const numBoards = 8; // N√∫mero de tablas de madera
            
            // Color √∫nico de madera
            const woodColor = '#8B4513'; // Saddle Brown - tono uniforme
            
            // Crear patr√≥n de tablas de madera organizadas
            for (let i = 0; i < numBoards; i++) {
                const x = i * boardWidth;
                
                // Color base de la tabla (mismo para todas)
                ctx.fillStyle = woodColor;
                ctx.fillRect(x, 0, boardWidth, boardHeight);
                
                // Agregar vetas de madera organizadas
                ctx.strokeStyle = '#654321'; // Color m√°s oscuro para las vetas
                ctx.lineWidth = 1;
                
                // Vetas horizontales organizadas (espaciado uniforme)
                for (let v = 0; v < 20; v++) {
                    const y = v * 25 + 12; // Espaciado uniforme sin variaci√≥n aleatoria
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + boardWidth, y);
                    ctx.stroke();
                }
                
                // Vetas verticales organizadas (espaciado uniforme)
                ctx.strokeStyle = '#5D4037';
                ctx.lineWidth = 0.5;
                for (let v = 0; v < 5; v++) {
                    const vx = x + v * 15 + 8; // Espaciado uniforme sin variaci√≥n aleatoria
                    ctx.beginPath();
                    ctx.moveTo(vx, 0);
                    ctx.lineTo(vx, boardHeight);
                    ctx.stroke();
                }
                
                // Agregar variaci√≥n sutil de color para realismo (mismo tono)
                ctx.fillStyle = 'rgba(139, 69, 19, 0.1)';
                ctx.fillRect(x, 0, boardWidth, boardHeight);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 2); // Repetir la textura para cubrir el √°rea
            
            const woodFloorMaterial = new THREE.MeshStandardMaterial({ 
                map: texture,
                roughness: 0.7, 
                metalness: 0.0,
                bumpMap: texture,
                bumpScale: 0.1
            });
            
            // Calcular el tama√±o del √°rea central (sin tiendas ni corredores)
            const storeDepth = 12;
            const corridorWidth = 8;
            const sueloOffset = corridorWidth / 2;
            // Hacer el √°rea central m√°s peque√±a para que se vea mejor la separaci√≥n
            const areaCentralSize = HALL_SIZE - 2 * (storeDepth + sueloOffset + 4); // Agregar 4 unidades m√°s de margen
            
            // Crear suelo de madera solo para el √°rea central
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(areaCentralSize, areaCentralSize), woodFloorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(HALL_SIZE / 2, yOffset, HALL_SIZE / 2);
            floor.receiveShadow = true;
            scene.add(floor);
            collisionObjects.push(new THREE.Box3().setFromObject(floor));

            // --- Tiendas ---
            const storeWidth = 8; // Reducido para que las tiendas sean m√°s estrechas
            const storeSpacing = 1.5; // Espaciado ajustado para un balance entre densidad y espacio
            const numStoresPerSide = Math.floor(HALL_SIZE / (storeWidth + storeSpacing));
            const totalStoresWidth = numStoresPerSide * storeWidth + (numStoresPerSide - 1) * storeSpacing;
            const initialOffset = (HALL_SIZE - totalStoresWidth) / 2;
            let linkIndex = startLinkIndex;

            // Funci√≥n para verificar si una posici√≥n est√° en una esquina
            const isCornerPosition = (index, side) => {
                // Saltar solo la primera y la √∫ltima tienda de cada lado
                return index === 0 || index === numStoresPerSide - 1;
            };

            // Crear tiendas usando la funci√≥n refactorizada
            const storePositions = {
                north: storeDepth / 2,
                south: HALL_SIZE - storeDepth / 2,
                east: HALL_SIZE - storeDepth / 2,
                west: storeDepth / 2
            };
            
            // Crear tiendas en sentido horario: Norte -> Este -> Sur -> Oeste
            let currentLinkIndex = linkIndex;
            
            // Norte
            const northResult = createStoreRow('north', storePositions.north, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, wallMaterial, currentLinkIndex, isCornerPosition);
            currentLinkIndex = northResult.linkIndex;
            
            // Este
            const eastResult = createStoreRow('east', storePositions.east, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, wallMaterial, currentLinkIndex, isCornerPosition);
            currentLinkIndex = eastResult.linkIndex;

            // Sur
            const southResult = createStoreRow('south', storePositions.south, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, wallMaterial, currentLinkIndex, isCornerPosition);
            currentLinkIndex = southResult.linkIndex;

            // Oeste
            const westResult = createStoreRow('west', storePositions.west, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, wallMaterial, currentLinkIndex, isCornerPosition);
            currentLinkIndex = westResult.linkIndex;
            
            linkIndex = currentLinkIndex;

            // --- Crear muros separadores entre tiendas usando la funci√≥n refactorizada ---
            createSeparatorWalls('north', storeDepth, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, separatorMaterial);
            createSeparatorWalls('south', HALL_SIZE - storeDepth, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, separatorMaterial);
            createSeparatorWalls('west', storeDepth, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, separatorMaterial);
            createSeparatorWalls('east', HALL_SIZE - storeDepth, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, separatorMaterial);

            // --- Crear pasillos en la planta baja ---
            // Usar las variables ya declaradas arriba
            const sueloLong = HALL_SIZE - 2 * (storeDepth + sueloOffset);
            const norteZ = storeDepth + sueloOffset;
            const surZ = HALL_SIZE - storeDepth - sueloOffset;
            const oesteX = storeDepth + sueloOffset;
            const esteX = HALL_SIZE - storeDepth - sueloOffset;
            
            // Material para el suelo del pasillo de la planta baja (rojo oscuro como el segundo piso)
            const pasilloMaterialPlantaBaja = new THREE.MeshStandardMaterial({ 
                color: 0x4B0000, // Color rojo oscuro igual al del segundo piso
                roughness: 0.8
            });
            
            // Funci√≥n para crear suelo de pasillo de la planta baja
            const createPasilloSueloPlantaBaja = (geometry, position) => {
                const suelo = new THREE.Mesh(geometry, pasilloMaterialPlantaBaja);
                suelo.position.copy(position);
                suelo.receiveShadow = true;
                return suelo;
            };
            
            // Norte - pasillo rojo oscuro
            const nortePasillo = createPasilloSueloPlantaBaja(
                new THREE.BoxGeometry(sueloLong, 0.2, corridorWidth),
                new THREE.Vector3(HALL_SIZE / 2, yOffset - 0.1, norteZ)
            );
            scene.add(nortePasillo);
            collisionObjects.push(new THREE.Box3().setFromObject(nortePasillo));
            
            // Sur - pasillo rojo oscuro
            const surPasillo = createPasilloSueloPlantaBaja(
                new THREE.BoxGeometry(sueloLong, 0.2, corridorWidth),
                new THREE.Vector3(HALL_SIZE / 2, yOffset - 0.1, surZ)
            );
            scene.add(surPasillo);
            collisionObjects.push(new THREE.Box3().setFromObject(surPasillo));
            
            // Oeste - pasillo rojo oscuro
            const oestePasillo = createPasilloSueloPlantaBaja(
                new THREE.BoxGeometry(corridorWidth, 0.2, sueloLong),
                new THREE.Vector3(oesteX, yOffset - 0.1, HALL_SIZE / 2)
            );
            scene.add(oestePasillo);
            collisionObjects.push(new THREE.Box3().setFromObject(oestePasillo));
            
            // Este - pasillo rojo oscuro
            const estePasillo = createPasilloSueloPlantaBaja(
                new THREE.BoxGeometry(corridorWidth, 0.2, sueloLong),
                new THREE.Vector3(esteX, yOffset - 0.1, HALL_SIZE / 2)
            );
            scene.add(estePasillo);
            collisionObjects.push(new THREE.Box3().setFromObject(estePasillo));
            
            // Esquinas - pasillo rojo oscuro
            const createCornerPlantaBaja = (posX, posZ) => {
                const corner = createPasilloSueloPlantaBaja(
                    new THREE.BoxGeometry(corridorWidth, 0.2, corridorWidth),
                    new THREE.Vector3(posX, yOffset - 0.1, posZ)
                );
                scene.add(corner);
                collisionObjects.push(new THREE.Box3().setFromObject(corner));
            };
            createCornerPlantaBaja(oesteX, norteZ); // NO
            createCornerPlantaBaja(esteX, norteZ); // NE
            createCornerPlantaBaja(oesteX, surZ); // SO
            createCornerPlantaBaja(esteX, surZ); // SE

            return linkIndex;
        }

        function createUpperFloorLevel(yOffset, floorMaterial, wallMaterial, separatorMaterial, startLinkIndex) {
            const storeDepth = 12;
            const storeWidth = 8;
            const storeSpacing = 1.5;
            const corridorWidth = 8; // Aumentado para eliminar huecos en el piso
            const numStoresPerSide = Math.floor(HALL_SIZE / (storeWidth + storeSpacing));
            const totalStoresWidth = numStoresPerSide * storeWidth + (numStoresPerSide - 1) * storeSpacing;
            const initialOffset = (HALL_SIZE - totalStoresWidth) / 2;
            let linkIndex = startLinkIndex;

            // Funci√≥n para verificar si una posici√≥n est√° en una esquina
            const isCornerPosition = (index, side) => {
                // Saltar solo la primera y la √∫ltima tienda de cada lado
                return index === 0 || index === numStoresPerSide - 1;
            };

            // --- Crear pasillos con suelo ---
            // Crear materiales para cada cara
            const pasilloMaterialVinotinto = new THREE.MeshStandardMaterial({ 
                color: 0x4B0000, // Color vinotinto m√°s oscuro
                roughness: 0.8
            });
            
            const pasilloMaterialBlanco = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF, // Color blanco
                roughness: 0.8
            });
            
            // Material original para el techo del pasillo
            const techoMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF, // Color blanco
                roughness: 0.8 
            });
            
            // El suelo empieza justo al frente de las tiendas para eliminar huecos
            const sueloOffset = corridorWidth / 2; // mitad del ancho del corredor para que empiece al frente de las tiendas
            const sueloLong = HALL_SIZE - 2 * (storeDepth + sueloOffset);
            const norteZ = storeDepth + sueloOffset;
            const surZ = HALL_SIZE - storeDepth - sueloOffset;
            const oesteX = storeDepth + sueloOffset;
            const esteX = HALL_SIZE - storeDepth - sueloOffset;
            
            // Funci√≥n para crear suelo de pasillo con dos colores
            const createPasilloSuelo = (geometry, position, materialVinotinto, materialBlanco) => {
                const grupo = new THREE.Group();
                
                // Cara superior (vinotinto) - ligeramente m√°s alta
                const caraSuperior = new THREE.Mesh(geometry, materialVinotinto);
                caraSuperior.position.set(0, 0.001, 0); // Ligeramente m√°s alta
                grupo.add(caraSuperior);
                
                // Cara inferior (blanca) - ligeramente m√°s baja
                const caraInferior = new THREE.Mesh(geometry, materialBlanco);
                caraInferior.position.set(0, -0.001, 0); // Ligeramente m√°s baja
                caraInferior.rotation.x = Math.PI; // Rotar 180 grados para que mire hacia abajo
                grupo.add(caraInferior);
                
                grupo.position.copy(position);
                return grupo;
            };
            
            // Norte - vinotinto arriba, blanco abajo
            const norte = createPasilloSuelo(
                new THREE.BoxGeometry(sueloLong, 0.2, corridorWidth),
                new THREE.Vector3(HALL_SIZE / 2, yOffset - 0.1, norteZ),
                pasilloMaterialVinotinto,
                pasilloMaterialBlanco
            );
            scene.add(norte);
            collisionObjects.push(new THREE.Box3().setFromObject(norte));
            
            // Sur - vinotinto arriba, blanco abajo
            const sur = createPasilloSuelo(
                new THREE.BoxGeometry(sueloLong, 0.2, corridorWidth),
                new THREE.Vector3(HALL_SIZE / 2, yOffset - 0.1, surZ),
                pasilloMaterialVinotinto,
                pasilloMaterialBlanco
            );
            scene.add(sur);
            collisionObjects.push(new THREE.Box3().setFromObject(sur));
            
            // Oeste - vinotinto arriba, blanco abajo
            const oeste = createPasilloSuelo(
                new THREE.BoxGeometry(corridorWidth, 0.2, sueloLong),
                new THREE.Vector3(oesteX, yOffset - 0.1, HALL_SIZE / 2),
                pasilloMaterialVinotinto,
                pasilloMaterialBlanco
            );
            scene.add(oeste);
            collisionObjects.push(new THREE.Box3().setFromObject(oeste));
            
            // Este - vinotinto arriba, blanco abajo
            const este = createPasilloSuelo(
                new THREE.BoxGeometry(corridorWidth, 0.2, sueloLong),
                new THREE.Vector3(esteX, yOffset - 0.1, HALL_SIZE / 2),
                pasilloMaterialVinotinto,
                pasilloMaterialBlanco
            );
            scene.add(este);
            collisionObjects.push(new THREE.Box3().setFromObject(este));
            
            // Esquinas - vinotinto arriba, blanco abajo
            const createCorner = (posX, posZ) => {
                const corner = createPasilloSuelo(
                    new THREE.BoxGeometry(corridorWidth, 0.2, corridorWidth),
                    new THREE.Vector3(posX, yOffset - 0.1, posZ),
                    pasilloMaterialVinotinto,
                    pasilloMaterialBlanco
                );
                scene.add(corner);
                collisionObjects.push(new THREE.Box3().setFromObject(corner));
            };
            createCorner(oesteX, norteZ); // NO
            createCorner(esteX, norteZ); // NE
            createCorner(oesteX, surZ); // SO
            createCorner(esteX, surZ); // SE

            // --- Crear techos de pasillos (solo para el segundo piso) ---
            const currentFloor = Math.floor(yOffset / (HALL_HEIGHT + 1));
            if (currentFloor === 1) { // Segundo piso (piso 1, ya que empezamos desde 0)
                const ceilingHeight = 0.2;
                const extendedHeight = HALL_HEIGHT + 1;
                const ceilingY = yOffset + (extendedHeight / 2 + 2.5); // Mucho m√°s alto que el techo de las tiendas
                const extendedCorridorWidth = corridorWidth + 4; // Reducir el sobresaliente del techo
                
                // Norte - techo gris original
                const techoNorte = new THREE.Mesh(new THREE.BoxGeometry(sueloLong, ceilingHeight, extendedCorridorWidth), techoMaterial);
                techoNorte.position.set(HALL_SIZE / 2, ceilingY, norteZ + 2); // Reducir sobresaliente hacia el centro
                // techoNorte.receiveShadow = true;
                // techoNorte.castShadow = true;
                scene.add(techoNorte);
                
                // Sur - techo gris original
                const techoSur = new THREE.Mesh(new THREE.BoxGeometry(sueloLong, ceilingHeight, extendedCorridorWidth), techoMaterial);
                techoSur.position.set(HALL_SIZE / 2, ceilingY, surZ - 2); // Reducir sobresaliente hacia el centro
                // techoSur.receiveShadow = true;
                // techoSur.castShadow = true;
                scene.add(techoSur);
                
                // Oeste - techo gris original
                const techoOeste = new THREE.Mesh(new THREE.BoxGeometry(extendedCorridorWidth, ceilingHeight, sueloLong), techoMaterial);
                techoOeste.position.set(oesteX + 2, ceilingY, HALL_SIZE / 2); // Reducir sobresaliente hacia el centro
                // techoOeste.receiveShadow = true;
                // techoOeste.castShadow = true;
                scene.add(techoOeste);
                
                // Este - techo gris original
                const techoEste = new THREE.Mesh(new THREE.BoxGeometry(extendedCorridorWidth, ceilingHeight, sueloLong), techoMaterial);
                techoEste.position.set(esteX - 2, ceilingY, HALL_SIZE / 2); // Reducir sobresaliente hacia el centro
                // techoEste.receiveShadow = true;
                // techoEste.castShadow = true;
                scene.add(techoEste);
                
                // Esquinas del techo - gris original
                const createCeilingCorner = (posX, posZ) => {
                    const techoCorner = new THREE.Mesh(new THREE.BoxGeometry(extendedCorridorWidth, ceilingHeight, extendedCorridorWidth), techoMaterial);
                    techoCorner.position.set(posX, ceilingY, posZ);
                    // techoCorner.receiveShadow = true;
                    // techoCorner.castShadow = true;
                    scene.add(techoCorner);
                };
                createCeilingCorner(oesteX + 2, norteZ + 2); // NO
                createCeilingCorner(esteX - 2, norteZ + 2); // NE
                createCeilingCorner(oesteX + 2, surZ - 2); // SO
                createCeilingCorner(esteX - 2, surZ - 2); // SE
            }

            // --- Crear techo trapezoidal sobre las tiendas del √∫ltimo piso ---
            // ELIMINADO: Techos trapezoidales para mejorar rendimiento
            // Ya no se necesitan porque solo tenemos 2 pisos
            /*
            if (currentFloor === 3) { // Solo para el √∫ltimo piso (piso 3)
                const trapezoidMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xA0522D, 
                    roughness: 0.8,
                    metalness: 0.1,
                    side: THREE.DoubleSide
                });
                
                // Crear techo trapezoidal para cada lado
                const trapezoidHeight = 6; // M√°s alto y m√°s grande
                const baseWidth = storeWidth + 2; // Un poco m√°s ancho que la tienda
                
                // Norte - techo trapezoidal
                for (let i = 0; i < numStoresPerSide; i++) {
                    const x = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                    const trapezoidGeometry = new THREE.ConeGeometry(baseWidth / 2, trapezoidHeight, 4);
                    const trapezoid = new THREE.Mesh(trapezoidGeometry, trapezoidMaterial);
                    trapezoid.position.set(x, yOffset + (HALL_HEIGHT + 1) / 2 + 3.5 + trapezoidHeight / 2, storeDepth / 2);
                    trapezoid.rotation.y = Math.PI / 4; // Rotar 45 grados
                    trapezoid.castShadow = true;
                    trapezoid.receiveShadow = true;
                    scene.add(trapezoid);
                }
                
                // Sur - techo trapezoidal
                for (let i = 0; i < numStoresPerSide; i++) {
                    const x = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                    const trapezoidGeometry = new THREE.ConeGeometry(baseWidth / 2, trapezoidHeight, 4);
                    const trapezoid = new THREE.Mesh(trapezoidGeometry, trapezoidMaterial);
                    trapezoid.position.set(x, yOffset + (HALL_HEIGHT + 1) / 2 + 3.5 + trapezoidHeight / 2, HALL_SIZE - storeDepth / 2);
                    trapezoid.rotation.y = Math.PI / 4; // Rotar 45 grados
                    trapezoid.castShadow = true;
                    trapezoid.receiveShadow = true;
                    scene.add(trapezoid);
                }
                
                // Oeste - techo trapezoidal
                for (let i = 0; i < numStoresPerSide; i++) {
                    const z = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                    const trapezoidGeometry = new THREE.ConeGeometry(baseWidth / 2, trapezoidHeight, 4);
                    const trapezoid = new THREE.Mesh(trapezoidGeometry, trapezoidMaterial);
                    trapezoid.position.set(storeDepth / 2, yOffset + (HALL_HEIGHT + 1) / 2 + 3.5 + trapezoidHeight / 2, z);
                    trapezoid.rotation.y = Math.PI / 4; // Rotar 45 grados
                    trapezoid.castShadow = true;
                    trapezoid.receiveShadow = true;
                    scene.add(trapezoid);
                }
                
                // Este - techo trapezoidal
                for (let i = 0; i < numStoresPerSide; i++) {
                    const z = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                    const trapezoidGeometry = new THREE.ConeGeometry(baseWidth / 2, trapezoidHeight, 4);
                    const trapezoid = new THREE.Mesh(trapezoidGeometry, trapezoidMaterial);
                    trapezoid.position.set(HALL_SIZE - storeDepth / 2, yOffset + (HALL_HEIGHT + 1) / 2 + 3.5 + trapezoidHeight / 2, z);
                    trapezoid.rotation.y = Math.PI / 4; // Rotar 45 grados
                    trapezoid.castShadow = true;
                    trapezoid.receiveShadow = true;
                    scene.add(trapezoid);
                }
            }
            */

            // --- Crear barandas al borde exterior de los corredores ---
            const railingHeight = 0.8;
            const railMat = new THREE.MeshStandardMaterial({ color: 0x000000, metalness: 0.5, roughness: 0.5 }); // Color negro
            const cornerGap = 2; // Espacio en las esquinas para no bloquear el paso
            const barandaLong = (sueloLong + corridorWidth - cornerGap) / 2; // Longitud de cada tramo
            const railThickness = 0.3; // Grosor de las barandas para hacerlas s√≥lidas
            
            // Norte - dos tramos separados
            const railN1 = new THREE.Mesh(new THREE.BoxGeometry(barandaLong, railingHeight, railThickness), railMat);
            railN1.position.set(storeDepth + corridorWidth + barandaLong / 2, yOffset + railingHeight / 2 - 0.1, storeDepth + corridorWidth);
            scene.add(railN1);
            const railN2 = new THREE.Mesh(new THREE.BoxGeometry(barandaLong, railingHeight, railThickness), railMat);
            railN2.position.set(HALL_SIZE - storeDepth - corridorWidth - barandaLong / 2, yOffset + railingHeight / 2 - 0.1, storeDepth + corridorWidth);
            scene.add(railN2);
            
            // Sur - dos tramos separados
            const railS1 = new THREE.Mesh(new THREE.BoxGeometry(barandaLong, railingHeight, railThickness), railMat);
            railS1.position.set(storeDepth + corridorWidth + barandaLong / 2, yOffset + railingHeight / 2 - 0.1, HALL_SIZE - storeDepth - corridorWidth);
            scene.add(railS1);
            const railS2 = new THREE.Mesh(new THREE.BoxGeometry(barandaLong, railingHeight, railThickness), railMat);
            railS2.position.set(HALL_SIZE - storeDepth - corridorWidth - barandaLong / 2, yOffset + railingHeight / 2 - 0.1, HALL_SIZE - storeDepth - corridorWidth);
            scene.add(railS2);
            
            // Oeste - dos tramos separados
            const railO1 = new THREE.Mesh(new THREE.BoxGeometry(railThickness, railingHeight, barandaLong), railMat);
            railO1.position.set(storeDepth + corridorWidth, yOffset + railingHeight / 2 - 0.1, storeDepth + corridorWidth + barandaLong / 2);
            scene.add(railO1);
            const railO2 = new THREE.Mesh(new THREE.BoxGeometry(railThickness, railingHeight, barandaLong), railMat);
            railO2.position.set(storeDepth + corridorWidth, yOffset + railingHeight / 2 - 0.1, HALL_SIZE - storeDepth - corridorWidth - barandaLong / 2);
            scene.add(railO2);
            
            // Este - dos tramos separados
            const railE1 = new THREE.Mesh(new THREE.BoxGeometry(railThickness, railingHeight, barandaLong), railMat);
            railE1.position.set(HALL_SIZE - storeDepth - corridorWidth, yOffset + railingHeight / 2 - 0.1, storeDepth + corridorWidth + barandaLong / 2);
            scene.add(railE1);
            const railE2 = new THREE.Mesh(new THREE.BoxGeometry(railThickness, railingHeight, barandaLong), railMat);
            railE2.position.set(HALL_SIZE - storeDepth - corridorWidth, yOffset + railingHeight / 2 - 0.1, HALL_SIZE - storeDepth - corridorWidth - barandaLong / 2);
            scene.add(railE2);

            // --- Actualizar colisiones de las barandas despu√©s de agregarlas a la escena ---
            [railN1, railN2, railS1, railS2, railO1, railO2, railE1, railE2].forEach(rail => {
                rail.updateMatrixWorld(true);
                const railBox = new THREE.Box3().setFromObject(rail);
                // Expandir la caja de colisi√≥n para hacer las barandas m√°s efectivas
                railBox.expandByScalar(0.2);
                collisionObjects.push(railBox);
            });

            // Crear tiendas usando la funci√≥n refactorizada
            const storePositions = {
                north: storeDepth / 2,
                south: HALL_SIZE - storeDepth / 2,
                east: HALL_SIZE - storeDepth / 2,
                west: storeDepth / 2
            };
            
            // Crear tiendas en sentido horario: Norte -> Este -> Sur -> Oeste
            let currentLinkIndex = linkIndex;
            
            // Norte
            const northResult = createStoreRow('north', storePositions.north, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, wallMaterial, currentLinkIndex, isCornerPosition);
            currentLinkIndex = northResult.linkIndex;
            
            // Este
            const eastResult = createStoreRow('east', storePositions.east, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, wallMaterial, currentLinkIndex, isCornerPosition);
            currentLinkIndex = eastResult.linkIndex;

            // Sur
            const southResult = createStoreRow('south', storePositions.south, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, wallMaterial, currentLinkIndex, isCornerPosition);
            currentLinkIndex = southResult.linkIndex;

            // Oeste
            const westResult = createStoreRow('west', storePositions.west, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, wallMaterial, currentLinkIndex, isCornerPosition);
            currentLinkIndex = westResult.linkIndex;
            
            linkIndex = currentLinkIndex;

            // --- Crear muros separadores entre tiendas usando la funci√≥n refactorizada ---
            createSeparatorWalls('north', storeDepth, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, separatorMaterial);
            createSeparatorWalls('south', HALL_SIZE - storeDepth, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, separatorMaterial);
            createSeparatorWalls('west', storeDepth, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, separatorMaterial);
            createSeparatorWalls('east', HALL_SIZE - storeDepth, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, separatorMaterial);

            return linkIndex;
        }

        function createStore(position, size, rotationY, linkIdx, depth, wallMaterial, floorY, shopNumber) {
            const storeGroup = new THREE.Group();
            storeGroup.position.copy(position);
            storeGroup.rotation.y = rotationY;
            const wallThickness = 0.2;

            // Determinar el piso actual una sola vez
            const currentFloor = Math.floor(floorY / (HALL_HEIGHT + 1));

            // --- Crear material de pared con el color de la pancarta ---
            const url = storeLinks[linkIdx];
            const domain = new URL(url).hostname.replace('www.', '').split('.')[0];
            const storeColor = new THREE.Color().setHSL((linkIdx * 47) % 360 / 360, 0.6, 0.5); // Mismo color que la pancarta
            const storeWallMaterial = new THREE.MeshStandardMaterial({ 
                color: storeColor,
                roughness: 0.9
            });

            // --- Suelo de la tienda con dos colores ---
            // Crear materiales para cada cara
            const storeFloorMaterialNegro = new THREE.MeshStandardMaterial({ 
                color: 0x000000, // Color negro
                roughness: 0.8
            });
            
            const storeFloorMaterialBlanco = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF, // Color blanco
                roughness: 0.8
            });
            
            // Funci√≥n para crear suelo de tienda con dos colores
            const createStoreFloor = (geometry, position) => {
                const grupo = new THREE.Group();
                
                // Cara superior (negra) - ligeramente m√°s alta
                const caraSuperior = new THREE.Mesh(geometry, storeFloorMaterialNegro);
                caraSuperior.position.set(0, 0.001, 0); // Ligeramente m√°s alta
                grupo.add(caraSuperior);
                
                // Cara inferior (blanca) - ligeramente m√°s baja
                const caraInferior = new THREE.Mesh(geometry, storeFloorMaterialBlanco);
                caraInferior.position.set(0, -0.001, 0); // Ligeramente m√°s baja
                caraInferior.rotation.x = Math.PI; // Rotar 180 grados para que mire hacia abajo
                grupo.add(caraInferior);
                
                grupo.position.copy(position);
                grupo.rotation.x = -Math.PI / 2;
                return grupo;
            };
            
            // Crear suelo de tienda con negro arriba y blanco abajo
            const storeFloor = createStoreFloor(new THREE.PlaneGeometry(size.x, depth), new THREE.Vector3(0, 0, 0));
            
            // Ajustar la posici√≥n del suelo seg√∫n el piso
            if (currentFloor === 1) {
                // Para el segundo piso, subir ligeramente el suelo
                const floorOffset = -0.05 - HALL_HEIGHT / 2; // Reducido de -0.1 a -0.05
                storeFloor.position.set(0, floorOffset, 0);
            } else {
                // Para la planta baja, mantener la posici√≥n original
                storeFloor.position.set(0, -size.y / 2 + 0.05, 0);
            }
            
            // storeFloor.receiveShadow = true;
            // storeFloor.castShadow = false; // Desactivar sombras para mejor rendimiento
            storeGroup.add(storeFloor);

            // --- Paredes (extendidas hasta el siguiente piso) ---
            const extendedHeight = HALL_HEIGHT + 1; // Extender hasta el siguiente piso
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(size.x, extendedHeight, wallThickness), storeWallMaterial);
            backWall.position.z = -depth / 2;
            backWall.position.y = (extendedHeight - size.y) / 2; // Centrar en la nueva altura
            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(depth, extendedHeight, wallThickness), storeWallMaterial);
            leftWall.position.set(-size.x / 2, (extendedHeight - size.y) / 2, 0);
            leftWall.rotation.y = Math.PI / 2;
            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(depth, extendedHeight, wallThickness), storeWallMaterial);
            rightWall.position.set(size.x / 2, (extendedHeight - size.y) / 2, 0);
            rightWall.rotation.y = -Math.PI / 2;
            [backWall, leftWall, rightWall].forEach(wall => {
                // wall.castShadow = false; // Desactivar sombras para mejor rendimiento
                // wall.receiveShadow = true;
                storeGroup.add(wall);
            });

            // --- Techo (para el segundo piso) ---
            if (currentFloor === 1) { // Segundo piso (piso 1, ya que empezamos desde 0)
                const ceilingMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF, // Color blanco
                    roughness: 0.8,
                    side: THREE.DoubleSide
                });
                const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(size.x, depth), ceilingMaterial);
                ceiling.rotation.x = Math.PI / 2;
                ceiling.position.set(0, extendedHeight / 2 + 0.5, 0); // Posicionar m√°s alto que las paredes extendidas
                // ceiling.receiveShadow = true;
                // ceiling.castShadow = false; // Desactivar sombras para mejor rendimiento
                storeGroup.add(ceiling);
            }
            
            // --- Cartel principal ---
            const mainSign = createImagePlane(url, domain, size.x * 0.9, size.y * 0.8, linkIdx, true);
            mainSign.position.z = -depth / 2 + wallThickness + 0.01;
            mainSign.position.y = (extendedHeight - size.y) / 2; // Ajustar posici√≥n vertical
            storeGroup.add(mainSign);

            // --- N√∫mero de tienda ---
            const shopNumberSign = createShopNumberSign(shopNumber, size.x * 0.25, size.y * 0.25);
            shopNumberSign.position.z = -depth / 2 + wallThickness + 0.02;
            shopNumberSign.position.y = (extendedHeight - size.y) / 2 + size.y * 0.4; // Posicionar m√°s abajo
            shopNumberSign.position.x = 0; // Centrar horizontalmente
            storeGroup.add(shopNumberSign);


            // --- Letreros verticales completos para los pasillos ---
            const createVerticalSign = (text, width, height, colorIdx) => {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const canvasW = 256; // Restaurar tama√±o original
                const canvasH = 512; // M√°s alto para texto vertical
                canvas.width = canvasW;
                canvas.height = canvasH;
                
                // Fondo con el mismo color que el cartel principal
                context.fillStyle = `hsl(${colorIdx * 47 % 360}, 60%, 50%)`;
                context.fillRect(0, 0, canvasW, canvasH);
                context.strokeStyle = '#FFFFFF';
                context.lineWidth = 4; // Restaurar grosor original
                context.strokeRect(2, 2, canvasW - 4, canvasH - 4);
                
                // Texto vertical en blanco
                context.fillStyle = '#FFFFFF';
                context.font = `bold ${canvasW * 0.25}px Arial`; // Restaurar tama√±o de fuente original
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                
                // Dividir el texto en caracteres y dibujarlos verticalmente de arriba hacia abajo
                const chars = text.split('');
                const charHeight = canvasH * 0.12; // M√°s espacio entre letras
                const totalHeight = chars.length * charHeight;
                const startY = canvasH / 2 - totalHeight / 2;
                const centerX = canvasW / 2;
                
                chars.forEach((char, index) => {
                    context.fillText(char, centerX, startY + index * charHeight);
                });
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshStandardMaterial({ 
                    map: texture,
                    transparent: true,
                    alphaTest: 0.1
                });
                
                const plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), material);
                return plane;
            };

            // Crear letreros verticales en los bordes de los pasillos (restaurar ambos)
            const verticalSignWidth = 0.8; // Restaurar tama√±o original
            const verticalSignHeight = extendedHeight; // Restaurar altura original
            
            // Letrero en el extremo izquierdo del muro (hacia el pasillo)
            const leftVerticalSign = createVerticalSign(domain.toUpperCase(), verticalSignWidth, verticalSignHeight, linkIdx);
            leftVerticalSign.position.set(-size.x / 2 + wallThickness + 0.02, (extendedHeight - size.y) / 2, depth / 2 - 1);
            leftVerticalSign.rotation.y = Math.PI / 2;
            storeGroup.add(leftVerticalSign);
            
            // N√∫mero de tienda en el extremo izquierdo del muro
            const leftNumberSign = createShopNumberSign(shopNumber, 0.8, 0.8);
            leftNumberSign.position.set(-size.x / 2 + wallThickness + 0.02, (extendedHeight - size.y) / 2 + 1.5, depth / 2 - 0.2);
            leftNumberSign.rotation.y = Math.PI / 2;
            storeGroup.add(leftNumberSign);
            
            // Letrero en el extremo derecho del muro (hacia el pasillo)
            const rightVerticalSign = createVerticalSign(domain.toUpperCase(), verticalSignWidth, verticalSignHeight, linkIdx);
            rightVerticalSign.position.set(size.x / 2 - wallThickness - 0.02, (extendedHeight - size.y) / 2, depth / 2 - 1);
            rightVerticalSign.rotation.y = -Math.PI / 2;
            storeGroup.add(rightVerticalSign);
            
            // N√∫mero de tienda en el extremo derecho del muro
            const rightNumberSign = createShopNumberSign(shopNumber, 0.8, 0.8);
            rightNumberSign.position.set(size.x / 2 - wallThickness - 0.02, (extendedHeight - size.y) / 2 + 1.5, depth / 2 - 0.2);
            rightNumberSign.rotation.y = -Math.PI / 2;
            storeGroup.add(rightNumberSign);

            scene.add(storeGroup);

            // --- Actualizar colisiones ---
            storeGroup.updateMatrixWorld(true);
            [backWall, leftWall, rightWall].forEach(wall => {
                collisionObjects.push(new THREE.Box3().setFromObject(wall));
            });
        }

        function createCentralCubeScreens(x, y, z, size, links, colorOffset, interval) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            const planes = [];

            const cubeGeom = new THREE.BoxGeometry(size, size * 0.6, size);
            const cubeMat = new THREE.MeshStandardMaterial({ color: 0x222, metalness: 0.3, roughness: 0.7 });
            const cube = new THREE.Mesh(cubeGeom, cubeMat);
            cube.position.y = size * 0.3;
            group.add(cube);
            
            for (let i = 0; i < 4; i++) {
                if (i >= links.length) continue;
                const angle = i * Math.PI / 2;
                const url = links[i];
                const domain = new URL(url).hostname.replace('www.', '').split('.')[0];
                const plane = createImagePlane(url, domain, size, size * 0.6, colorOffset + i, true);
                plane.position.set(Math.sin(angle) * (size / 2 + 0.01), size * 0.3, Math.cos(angle) * (size / 2 + 0.01));
                plane.rotation.y = angle;
                group.add(plane);
                planes.push(plane);
            }
            scene.add(group);
            group.updateMatrixWorld(true);
            collisionObjects.push(new THREE.Box3().setFromObject(cube));

            let offset = 0;
            setInterval(() => {
                planes.forEach((plane, i) => {
                    const linkIdx = (offset + i) % links.length;
                    const url = links[linkIdx];
                    const domain = new URL(url).hostname.replace('www.', '').split('.')[0];
                    plane.userData.URL = url;
                    updateImagePlane(plane, url, domain, colorOffset + linkIdx, true);
                });
                offset = (offset + 1) % links.length;
            }, interval);
        }

        function createImagePlane(url, text, width, height, colorIdx, solid) {
            const plane = new THREE.Mesh(
                new THREE.PlaneGeometry(width, height),
                new THREE.MeshStandardMaterial({ roughness: 0.7, metalness: 0.2, transparent: !solid })
            );
            plane.userData.URL = url;
            updateImagePlane(plane, url, text, colorIdx, solid);
            clickableObjects.push(plane);
            return plane;
        }

        // Cache para texturas de logos
        const logoTextureCache = new Map();
        
        function getLogoTexture(domain) {
            const logoFileName = domainToLogoMap[domain];
            if (!logoFileName) {
                return null;
            }
            
            // Verificar si ya est√° en cache
            if (logoTextureCache.has(domain)) {
                return logoTextureCache.get(domain);
            }
            
            try {
                const textureLoader = new THREE.TextureLoader();
                const texture = textureLoader.load(
                    `assets/images/${logoFileName}`,
                    // onLoad callback
                    function(loadedTexture) {
                        console.log(`Logo cargado exitosamente: ${logoFileName}`);
                    },
                    // onProgress callback
                    function(xhr) {
                        // Silenciar progreso para evitar spam
                    },
                    // onError callback
                    function(error) {
                        console.error(`Error cargando logo ${logoFileName}:`, error);
                        // Remover del cache si falla
                        logoTextureCache.delete(domain);
                    }
                );
                
                // Guardar en cache
                logoTextureCache.set(domain, texture);
                return texture;
            } catch (error) {
                console.error(`Error creando textura para ${domain}:`, error);
                return null;
            }
        }

        function createShopNumberSign(number, width, height) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const canvasW = 256;
            const canvasH = 256;
            canvas.width = canvasW;
            canvas.height = canvasH;
            
            // Fondo circular negro
            context.fillStyle = '#000000';
            context.beginPath();
            context.arc(canvasW / 2, canvasH / 2, canvasW / 2 - 10, 0, 2 * Math.PI);
            context.fill();
            
            // Borde blanco
            context.strokeStyle = '#FFFFFF';
            context.lineWidth = 8;
            context.stroke();
            
            // N√∫mero en blanco
            context.fillStyle = '#FFFFFF';
            context.font = `bold ${canvasH * 0.6}px Arial`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(number.toString(), canvasW / 2, canvasH / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshStandardMaterial({ 
                map: texture,
                transparent: true,
                alphaTest: 0.1
            });
            
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), material);
            return plane;
        }

        function updateImagePlane(plane, url, text, colorIdx) {
            try {
                let domain = new URL(url).hostname.replace('www.', '');
                // Extraer el dominio principal (sin subdominios)
                const domainParts = domain.split('.');
                if (domainParts.length > 2) {
                    domain = domainParts[1];
                } else {
                    domain = domainParts[0];
                }
                
                const logoTexture = getLogoTexture(domain);
                
                if (plane.material.map) {
                    plane.material.map.dispose();
                }
                
                if (logoTexture) {
                    plane.material.map = logoTexture;
                } else {
                    // Fallback a la textura generada si no hay logo
                    const texture = getCachedTexture(text, colorIdx, plane.geometry.parameters.width, plane.geometry.parameters.height);
            plane.material.map = texture;
                }
                
            plane.material.needsUpdate = true;
            } catch (error) {
                console.error('Error en updateImagePlane:', error);
                // Fallback seguro
                if (plane.material.map) {
                    plane.material.map.dispose();
                }
                const texture = getCachedTexture(text, colorIdx, plane.geometry.parameters.width, plane.geometry.parameters.height);
                plane.material.map = texture;
                plane.material.needsUpdate = true;
            }
        }

        function createDigitalClockCube(x, y, z, size) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            const planes = [];

            const cubeGeom = new THREE.BoxGeometry(size, size * 0.6, size);
            const cubeMat = new THREE.MeshStandardMaterial({ color: 0x111, metalness: 0.3, roughness: 0.7 });
            const cube = new THREE.Mesh(cubeGeom, cubeMat);
            cube.position.y = size * 0.3;
            group.add(cube);

            for (let i = 0; i < 4; i++) {
                const angle = i * Math.PI / 2;
                const plane = createClockPlane(size, size * 0.6);
                plane.position.set(Math.sin(angle) * (size / 2 + 0.01), size * 0.3, Math.cos(angle) * (size / 2 + 0.01));
                plane.rotation.y = angle;
                group.add(plane);
                planes.push(plane);
            }
            scene.add(group);
            group.updateMatrixWorld(true);
            collisionObjects.push(new THREE.Box3().setFromObject(cube));

            // Agregar al sistema centralizado en lugar de usar setInterval
            planes.forEach(plane => {
                digitalClocks.push({
                    material: plane.material
                });
            });
        }

        function createClockPlane(width, height) {
            const material = new THREE.MeshStandardMaterial({ roughness: 0.7, metalness: 0.2 });
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), material);
            updateClockPlane(material);
            return plane;
        }

        function updateClockPlane(material) {
            const canvas = material.map ? material.map.image : document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 800;
            canvas.height = 400;
            
            context.fillStyle = '#111';
            context.fillRect(0, 0, 800, 400);
            
            const now = new Date();
            const timeStr = now.toLocaleTimeString('es-ES', { hour12: false });
            context.font = 'bold 160px monospace';
            context.fillStyle = '#0ff';
            context.shadowColor = '#0ff';
            context.shadowBlur = 32;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(timeStr, 400, 200);

            if (!material.map) {
                material.map = new THREE.CanvasTexture(canvas);
            } else {
                material.map.needsUpdate = true;
            }
        }

        // --- Manejadores de Eventos ---
        function setupEventListeners() {
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize);
            // Sistema centralizado de eventos de clic
        document.addEventListener('mousedown', handleGlobalClick);
        document.addEventListener('click', handleGlobalClick);
        }
        
        function setupUIButtons() {
            console.log('Configurando botones de UI...');
            
            // Bot√≥n de habitaciones personales
            const roomToggleBtn = document.getElementById('room-toggle-btn');
            if (roomToggleBtn) {
                console.log('Bot√≥n de habitaciones encontrado');
                roomToggleBtn.onclick = () => {
                    console.log('Bot√≥n de habitaciones clickeado');
                    toggleRoomNavigation();
                };
            } else {
                console.error('No se encontr√≥ el bot√≥n de habitaciones');
            }
            
            // Verificar que el bot√≥n se encontr√≥ correctamente
            if (changeAliasBtn) {
                console.log('Bot√≥n de personalizaci√≥n encontrado');
                changeAliasBtn.onclick = () => {
                    console.log('Bot√≥n de personalizaci√≥n clickeado');
                    // Mostrar el panel de personalizaci√≥n completo
                    openCustomizationPanel();
                };
            } else {
                console.error('No se encontr√≥ el bot√≥n de personalizaci√≥n');
            }
            

            // Bot√≥n para regresar al mall
            const returnToMallBtn = document.getElementById('return-to-mall-btn');
            if (returnToMallBtn) {
                console.log('Bot√≥n de regreso al mall encontrado');
                returnToMallBtn.onclick = () => {
                    console.log('Bot√≥n de regreso al mall clickeado');
                    returnToMall();
                };
            } else {
                console.error('No se encontr√≥ el bot√≥n de regreso al mall');
            }
            
            // Configurar controles m√≥viles
            setupMobileControls();
        }
        
        function setupMobileControls() {
            const mobileForwardBtn = document.getElementById('mobile-forward');
            const mobileBackwardBtn = document.getElementById('mobile-backward');
            const mobileLeftBtn = document.getElementById('mobile-left');
            const mobileRightBtn = document.getElementById('mobile-right');
            
            // Funci√≥n auxiliar para configurar controles de botones m√≥viles con efectos visuales
            function setupButtonControls(buttonId, flagSetter) {
                const button = document.getElementById(buttonId);
                if (button) {
                    const setFlag = (value) => (e) => { 
                    e.preventDefault();
                        flagSetter(value); 
                        
                        // Efectos visuales para el bot√≥n
                        if (value) {
                            // Bot√≥n presionado
                            button.style.background = 'rgba(255, 215, 0, 0.8)';
                            button.style.transform = 'scale(0.95)';
                            button.style.border = '3px solid rgba(255, 215, 0, 0.9)';
                            button.style.boxShadow = '0 2px 8px rgba(255, 215, 0, 0.4)';
                        } else {
                            // Bot√≥n liberado
                            button.style.background = 'rgba(75, 0, 0, 0.8)';
                            button.style.transform = 'scale(1)';
                            button.style.border = '3px solid rgba(255, 215, 0, 0.3)';
                            button.style.boxShadow = 'none';
                        }
                    };
                    
                    // Eventos para touch
                    button.addEventListener('touchstart', setFlag(true));
                    button.addEventListener('touchend', setFlag(false));
                    button.addEventListener('touchcancel', setFlag(false));
                    
                    // Eventos para mouse
                    button.addEventListener('mousedown', setFlag(true));
                    button.addEventListener('mouseup', setFlag(false));
                    button.addEventListener('mouseleave', setFlag(false));
                    
                    // Prevenir selecci√≥n de texto
                    button.addEventListener('selectstart', (e) => e.preventDefault());
                    button.addEventListener('dragstart', (e) => e.preventDefault());
                }
            }
            
            // Configurar controles m√≥viles usando la funci√≥n auxiliar
            setupButtonControls('mobile-forward', value => mobileForward = value);
            setupButtonControls('mobile-backward', value => mobileBackward = value);
            setupButtonControls('mobile-left', value => mobileLeft = value);
            setupButtonControls('mobile-right', value => mobileRight = value);
        }

        function onKeyDown(event) {
            // Si el chat est√° abierto, no procesar controles del juego
            if (chatOpen) {
                return;
            }
            
            // Procesar controles para ambas escenas
            const key = event.code.replace('Key', '');
            if (key in keys) keys[key] = true;
            if (event.code === 'ArrowUp') keys.W = true;
            if (event.code === 'ArrowDown') keys.S = true;
            if (event.code === 'ArrowLeft') keys.A = true;
            if (event.code === 'ArrowRight') keys.D = true;
            
            // Controles espec√≠ficos del mall (cambio de pisos)
            if (currentScene === 'mall') {
            if (event.code === 'KeyW' && !keyW) { // W para subir de piso (solo una vez)
                if (currentFloor < MAX_FLOOR) currentFloor++;
                keyW = true;
            }
            if (event.code === 'KeyS' && !keyS) { // S para bajar de piso (solo una vez)
                if (currentFloor > MIN_FLOOR) currentFloor--;
                keyS = true;
            }
            if (event.code === 'KeyA') { // A para moverse hacia la izquierda
                keyA = true;
            }
            if (event.code === 'KeyD') { // D para moverse hacia la derecha
                keyD = true;
                }
            }
            
            // Controles de edici√≥n de muebles en la habitaci√≥n personal
            if (currentScene === 'personal-room' && furnitureEditMode && selectedFurniture) {
                if (event.code === 'KeyW' || event.code === 'ArrowUp') {
                    moveSelectedFurniture('forward');
                }
                if (event.code === 'KeyS' || event.code === 'ArrowDown') {
                    moveSelectedFurniture('backward');
                }
                if (event.code === 'KeyA' || event.code === 'ArrowLeft') {
                    moveSelectedFurniture('left');
                }
                if (event.code === 'KeyD' || event.code === 'ArrowRight') {
                    moveSelectedFurniture('right');
                }
                if (event.code === 'KeyR') {
                    rotateSelectedFurniture();
                }
                if (event.code === 'Enter') {
                    saveFurnitureInventory();
                }
                if (event.code === 'Escape') {
                    deselectFurniture();
                }
            }
        }

        function onKeyUp(event) {
            const key = event.code.replace('Key', '');
            if (key in keys) keys[key] = false;
            if (event.code === 'ArrowUp') keys.W = false;
            if (event.code === 'ArrowDown') keys.S = false;
            if (event.code === 'ArrowLeft') keys.A = false;
            if (event.code === 'ArrowRight') keys.D = false;
            
            // Controles espec√≠ficos del mall
            if (currentScene === 'mall') {
            if (event.code === 'KeyA') keyA = false;
            if (event.code === 'KeyD') keyD = false;
            if (event.code === 'KeyW') keyW = false;
            if (event.code === 'KeyS') keyS = false;
            }
        }

        function onWindowResize() {
            // Actualizar c√°mara y renderer del mall
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Actualizar c√°mara y renderer de la habitaci√≥n personal si existe
            if (personalRoomCamera && personalRoomRenderer) {
                personalRoomCamera.aspect = window.innerWidth / window.innerHeight;
                personalRoomCamera.updateProjectionMatrix();
                personalRoomRenderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        // Sistema centralizado de manejo de eventos de clic
        function handleGlobalClick(event) {
            const target = event.target;
            
            // 1. Verificar si es un clic en elementos de UI - NO procesar
            const isUIElement = target.closest('#ui-container') || 
                               target.closest('#chat-panel') || 
                               target.closest('#simple-panel') ||
                               target.closest('#room-navigation-panel') ||
                               target.closest('#ui-overlay') ||
                               target.closest('button') ||
                               target.closest('input') ||
                               target.closest('select');
            
            // Manejo especial para emoji panel
            const emojiPanel = document.getElementById('emoji-panel');
            const emojiToggle = document.getElementById('emoji-toggle');
            if (emojiPanel && emojiToggle && !emojiPanel.contains(target) && !emojiToggle.contains(target)) {
                emojiPanel.style.display = 'none';
            }
            
            if (isUIElement) {
                return; // NO procesar clics en elementos de UI
            }
            
            // 2. Verificar estado de la aplicaci√≥n
            const overlay = document.getElementById('ui-overlay');
            const simplePanel = document.getElementById('simple-panel');
            const workingPanel = document.getElementById('working-customization-panel');
            
            // Si alg√∫n panel est√° abierto, cerrarlo al hacer clic fuera
            if (chatOpen && !chatPanel.contains(target) && !chatToggleBtn.contains(target)) {
                chatPanel.style.display = 'none';
                chatOpen = false;
                if (overlay) {
                    overlay.style.display = 'none';
                    overlay.style.pointerEvents = 'none';
                }
                return;
            }
            
            if (customizationPanelOpen && !customizationPanel.contains(target)) {
                closeCustomizationPanel();
                return;
            }
            
            if (workingPanel && !workingPanel.contains(target)) {
                closeWorkingPanel();
                return;
            }
            
            // Si el overlay est√° activo, no procesar clics del juego
            if (overlay && overlay.style.display === 'block' && overlay.style.pointerEvents === 'auto') {
                return;
            }
            
            // Si el chat est√° abierto, no procesar controles del juego
            if (chatOpen) {
                return;
            }
            
            // Si el panel de personalizaci√≥n est√° abierto, no procesar clics del juego
            if (simplePanel && simplePanel.style.display === 'block') {
                return;
            }
            
            // 3. Procesar clics del juego
            handleGameClick(event);
        }
        
        function handleGameClick(event) {
            if (event.button !== 0) return; // Solo clic izquierdo
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Si estamos en modo de edici√≥n de muebles, usar la c√°mara de la habitaci√≥n
            if (currentScene === 'personal-room' && furnitureEditMode) {
                raycaster.setFromCamera(mouse, personalRoomCamera);
                const furnitureIntersects = raycaster.intersectObjects(furnitureObjects.map(f => f.mesh));
                
                if (furnitureIntersects.length > 0) {
                    const clickedFurniture = furnitureIntersects[0].object;
                    const furniture = furnitureObjects.find(f => f.mesh === clickedFurniture);
                    if (furniture) {
                        selectFurniture(furniture.id);
                        return;
                    }
                }
            } else {
                // Comportamiento normal del mall
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(clickableObjects);
            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                
                // Verificar si es un clic en el nombre del avatar para personalizaci√≥n
                if (clickedObject.userData && clickedObject.userData.type === 'customization') {
                    openCustomizationPanel();
                    return;
                }
                
                // Verificar si es un clic en una tienda
                if (clickedObject.userData.URL) {
                    window.open(clickedObject.userData.URL, '_blank');
                    }
                }
            }
        }
        
        // Funci√≥n original onMouseDown ahora usa el sistema centralizado
        function onMouseDown(event) {
            handleGlobalClick(event);
        }

        function updateMovement() {
            // Si el chat est√° abierto, no actualizar movimiento
            if (chatOpen) {
                return;
            }
            
            // --- Rotaci√≥n con flechas izquierda/derecha y controles m√≥viles ---
            if (keys.ArrowLeft || mobileLeft) targetRotationY -= ROTATE_SPEED;
            if (keys.ArrowRight || mobileRight) targetRotationY += ROTATE_SPEED;

            // --- Movimiento hacia adelante/atr√°s con flechas y controles m√≥viles ---
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();
            
            const velocity = new THREE.Vector3();
            
            // Movimiento hacia adelante/atr√°s con flechas arriba/abajo y controles m√≥viles
            if (keys.ArrowUp || mobileForward) velocity.add(direction);
            if (keys.ArrowDown || mobileBackward) velocity.sub(direction);
            
            // Movimiento lateral con A y D (teclas)
            const rightDirection = new THREE.Vector3();
            rightDirection.setFromMatrixColumn(camera.matrix, 0);
            rightDirection.y = 0;
            rightDirection.normalize();
            
            if (keyA) velocity.sub(rightDirection); // Moverse hacia la izquierda
            if (keyD) velocity.add(rightDirection); // Moverse hacia la derecha
            
            if (velocity.length() > 0) {
                velocity.normalize().multiplyScalar(MOVE_SPEED);
                const newPosition = targetPosition.clone().add(velocity);
                
                // --- Colisiones optimizadas ---
                const playerBox = new THREE.Box3().setFromCenterAndSize(newPosition, new THREE.Vector3(1.0, CAMERA_HEIGHT, 1.0));
                let collision = false;
                
                // Optimizaci√≥n: solo verificar colisiones cercanas
                const nearbyCollisions = collisionObjects.filter(wallBox => {
                    const distance = wallBox.getCenter(new THREE.Vector3()).distanceTo(newPosition);
                    return distance < 20; // Solo verificar objetos dentro de 20 unidades
                });
                
                for (const wallBox of nearbyCollisions) {
                    if (playerBox.intersectsBox(wallBox)) {
                        collision = true;
                        break;
                    }
                }
                
                if (!collision) {
                    targetPosition.copy(newPosition);
                }
            }

            // --- Cambio de Piso ---
            const floorStep = HALL_HEIGHT + 1;
            const targetY = currentFloor * floorStep + CAMERA_HEIGHT;
            targetPosition.y = targetY;

            // --- Interpolaci√≥n para suavidad ---
            camera.position.lerp(targetPosition, 0.2);
            camera.rotation.y = lerpAngle(camera.rotation.y, targetRotationY, 0.2);
        }

        // --- Funciones del sistema de habitaciones personales ---
        function toggleRoomNavigation() {
            const roomNavigationPanel = document.getElementById('room-navigation-panel');
            if (roomNavigationPanel) {
                if (roomNavigationPanelOpen) {
                    roomNavigationPanel.style.display = 'none';
                    roomNavigationPanelOpen = false;
                } else {
                    roomNavigationPanel.style.display = 'flex';
                    roomNavigationPanelOpen = true;
                }
            }
        }
        
        function closeRoomNavigation() {
            const roomNavigationPanel = document.getElementById('room-navigation-panel');
            if (roomNavigationPanel) {
                roomNavigationPanel.style.display = 'none';
                roomNavigationPanelOpen = false;
            }
        }
        
        async function enterPersonalRoom() {
            if (currentScene === 'personal-room') return;
            
            console.log('[Habitaci√≥n] Entrando a la habitaci√≥n personal...');
            currentScene = 'personal-room';
            
            try {
                // Configurar la habitaci√≥n
                await setupPersonalRoom();
                closeRoomNavigation();
                
                // Initialize furniture persistence with the created scene
                // This needs to happen BEFORE loadFurnitureInventory is called
                if (window.initFurniturePersistence) {
                    window.initFurniturePersistence(personalRoomScene, window.furnitureObjects);
                    console.log('[DEBUG] After initFurniturePersistence call in enterPersonalRoom, personalRoomScene:', personalRoomScene);
                } else {
                    console.error('[Habitaci√≥n] Error: initFurniturePersistence no est√° disponible.');
                    return; // Prevent further errors
                }
                
                // Cargar el inventario de muebles guardado
                console.log('[Habitaci√≥n] Cargando inventario de muebles...');
                const inventory = await loadFurnitureInventory();
                
                if (inventory && inventory.length > 0) {
                    console.log(`[Habitaci√≥n] Se cargaron ${inventory.length} muebles correctamente`);
                    // Actualizar la lista de muebles en la UI
                    if (window.updateFurnitureList) {
                        updateFurnitureList();
                    }
                } else {
                    console.log('[Habitaci√≥n] No hay muebles guardados o hubo un error al cargarlos');
                }
                
                // Mostrar bot√≥n de regreso al mall
                const returnToMallBtn = document.getElementById('return-to-mall-btn');
                if (returnToMallBtn) {
                    returnToMallBtn.style.display = 'flex';
                }
                
                console.log('[Habitaci√≥n] Habitaci√≥n personal lista');
                
            } catch (error) {
                console.error('[Habitaci√≥n] Error al entrar a la habitaci√≥n personal:', error);
                // Mostrar mensaje de error al usuario
                alert('Ocurri√≥ un error al cargar la habitaci√≥n. Por favor, recarga la p√°gina e int√©ntalo de nuevo.');
            }
        }
        
        function returnToMall() {
            if (currentScene === 'mall') return;

            // Guardar muebles antes de salir
            saveFurnitureInventory();
            
            currentScene = 'mall';
            // Limpiar escena de habitaci√≥n personal
            if (personalRoomRenderer) {
                document.body.removeChild(personalRoomRenderer.domElement);
                personalRoomRenderer.dispose();
            }
            // Mostrar escena del mall
            renderer.domElement.style.display = 'block';
            
            // Ocultar bot√≥n de regreso al mall
            const returnToMallBtn = document.getElementById('return-to-mall-btn');
            if (returnToMallBtn) {
                returnToMallBtn.style.display = 'none';
            }
        }
        
        async function setupPersonalRoom() {
            console.log('[Habitaci√≥n] Inicializando habitaci√≥n personal...');
            
            // Ocultar escena del mall
            renderer.domElement.style.display = 'none';
            
            // Crear nueva escena para la habitaci√≥n personal
            personalRoomScene = new THREE.Scene();
            console.log('[DEBUG] personalRoomScene created:', personalRoomScene); // Add this
            personalRoomScene.background = new THREE.Color(0x2C3E50); // Azul oscuro
            
            // Inicializar el array de muebles si no existe
            if (!window.furnitureObjects) {
                window.furnitureObjects = [];
            }
            
            
            
            // Crear c√°mara para la habitaci√≥n
            personalRoomCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            personalRoomCamera.position.set(0, CAMERA_HEIGHT, 3); // Posici√≥n inicial en la habitaci√≥n
            personalRoomCamera.lookAt(0, CAMERA_HEIGHT, 0);
            
            // Configurar posici√≥n y rotaci√≥n objetivo para movimiento suave
            personalRoomTargetPosition = personalRoomCamera.position.clone();
            personalRoomTargetRotationY = personalRoomCamera.rotation.y;
            
            // Crear renderer para la habitaci√≥n
            personalRoomRenderer = new THREE.WebGLRenderer({ antialias: true });
            personalRoomRenderer.setSize(window.innerWidth, window.innerHeight);
            personalRoomRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            personalRoomRenderer.shadowMap.enabled = true;
            personalRoomRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
            personalRoomRenderer.domElement.style.zIndex = '1';
            document.body.appendChild(personalRoomRenderer.domElement);
            
            // Crear iluminaci√≥n para la habitaci√≥n
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            personalRoomScene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            personalRoomScene.add(directionalLight);
            
            // Crear habitaci√≥n
            createPersonalRoom();
            
            // Iniciar la animaci√≥n de la habitaci√≥n
            animatePersonalRoom();
            
            console.log('[Habitaci√≥n] Habitaci√≥n personal inicializada correctamente');
            // Y tambi√©n:
            // if (personalRoomSkyInterval) clearInterval(personalRoomSkyInterval);
            // personalRoomSkyInterval = setInterval(updatePersonalRoomSky, 60000); // Actualizar cada minuto
            // updatePersonalRoomSky();
            
            // Iniciar animaci√≥n de la habitaci√≥n
            animatePersonalRoom();
        }
        
        function createPersonalRoom() {
            // Dimensiones de la habitaci√≥n (el doble de grande)
            const roomWidth = 24;
            const roomHeight = 3.5;
            const roomDepth = 24;
            // Materiales
            const wallMaterial = getCachedMaterial(0xE8E8E8, 0.9); // Gris claro
            const floorMaterial = getCachedMaterial(0x8B4513, 0.8, 0.1); // Marr√≥n madera
            const ceilingMaterial = getCachedMaterial(0xF5F5F5, 0.9); // Blanco
            // Paredes
            const wallGeometry = new THREE.BoxGeometry(roomWidth, roomHeight, 0.2);
            // Pared trasera
            const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
            backWall.position.set(0, roomHeight/2, -roomDepth/2);
            personalRoomScene.add(backWall);
            // Pared izquierda con hueco de ventana (4x2.5 metros)
            const leftWallTop = new THREE.Mesh(new THREE.BoxGeometry(roomWidth, 1.2, 0.2), wallMaterial);
            leftWallTop.position.set(-roomWidth/2, roomHeight - 0.6, 0);
            leftWallTop.rotation.y = Math.PI / 2;
            personalRoomScene.add(leftWallTop);
            
            const leftWallBottom = new THREE.Mesh(new THREE.BoxGeometry(roomWidth, 1.2, 0.2), wallMaterial);
            leftWallBottom.position.set(-roomWidth/2, 0.6, 0);
            leftWallBottom.rotation.y = Math.PI / 2;
            personalRoomScene.add(leftWallBottom);
            
            // Pared izquierda del hueco (lado izquierdo del hueco)
            const leftWallLeft = new THREE.Mesh(new THREE.BoxGeometry(10, 2.5, 0.2), wallMaterial);
            leftWallLeft.position.set(-roomWidth/2, 1.85, -10);
            leftWallLeft.rotation.y = Math.PI / 2;
            personalRoomScene.add(leftWallLeft);
            
            // Pared derecha del hueco (lado derecho del hueco)
            const leftWallRight = new THREE.Mesh(new THREE.BoxGeometry(10, 2.5, 0.2), wallMaterial);
            leftWallRight.position.set(-roomWidth/2, 1.85, 10);
            leftWallRight.rotation.y = Math.PI / 2;
            personalRoomScene.add(leftWallRight);
            
            // Pared derecha con hueco de ventana (4x2.5 metros)
            const rightWallTop = new THREE.Mesh(new THREE.BoxGeometry(roomWidth, 1.2, 0.2), wallMaterial);
            rightWallTop.position.set(roomWidth/2, roomHeight - 0.6, 0);
            rightWallTop.rotation.y = -Math.PI / 2;
            personalRoomScene.add(rightWallTop);
            
            const rightWallBottom = new THREE.Mesh(new THREE.BoxGeometry(roomWidth, 1.2, 0.2), wallMaterial);
            rightWallBottom.position.set(roomWidth/2, 0.6, 0);
            rightWallBottom.rotation.y = -Math.PI / 2;
            personalRoomScene.add(rightWallBottom);
            
            // Pared izquierda del hueco (lado izquierdo del hueco)
            const rightWallLeft = new THREE.Mesh(new THREE.BoxGeometry(10, 2.5, 0.2), wallMaterial);
            rightWallLeft.position.set(roomWidth/2, 1.85, -10);
            rightWallLeft.rotation.y = -Math.PI / 2;
            personalRoomScene.add(rightWallLeft);
            
            // Pared derecha del hueco (lado derecho del hueco)
            const rightWallRight = new THREE.Mesh(new THREE.BoxGeometry(10, 2.5, 0.2), wallMaterial);
            rightWallRight.position.set(roomWidth/2, 1.85, 10);
            rightWallRight.rotation.y = -Math.PI / 2;
            personalRoomScene.add(rightWallRight);
            // Pared frontal (con puerta)
            const frontWallLeft = new THREE.Mesh(new THREE.BoxGeometry(roomWidth/2 - 0.5, roomHeight, 0.2), wallMaterial);
            frontWallLeft.position.set(-roomWidth/4 - 0.25, roomHeight/2, roomDepth/2);
            personalRoomScene.add(frontWallLeft);
            const frontWallRight = new THREE.Mesh(new THREE.BoxGeometry(roomWidth/2 - 0.5, roomHeight, 0.2), wallMaterial);
            frontWallRight.position.set(roomWidth/4 + 0.25, roomHeight/2, roomDepth/2);
            personalRoomScene.add(frontWallRight);
            // Puerta m√°s grande y decorativa
            const doorWidth = 1.8;
            const doorHeight = 2.8;
            const doorThickness = 0.12;
            const doorGeometry = new THREE.BoxGeometry(doorWidth, doorHeight, doorThickness);
            const doorMaterial = getCachedMaterial(0x8B5A2B, 0.92, 0.18); // Madera rica
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, doorHeight/2, roomDepth/2 + 0.01);
            door.castShadow = true;
            personalRoomScene.add(door);

            // Marco decorativo
            const frameMaterial = getCachedMaterial(0xA0522D, 0.7, 0.18);
            const frameThickness = 0.14;
            const frameDepth = 0.16;
            // Lados
            const frameLeft = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, doorHeight + 0.18, frameDepth), frameMaterial);
            frameLeft.position.set(-doorWidth/2 - frameThickness/2, doorHeight/2, roomDepth/2 + 0.01);
            personalRoomScene.add(frameLeft);
            const frameRight = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, doorHeight + 0.18, frameDepth), frameMaterial);
            frameRight.position.set(doorWidth/2 + frameThickness/2, doorHeight/2, roomDepth/2 + 0.01);
            personalRoomScene.add(frameRight);
            // Arriba
            const frameTop = new THREE.Mesh(new THREE.BoxGeometry(doorWidth + frameThickness*2, frameThickness, frameDepth), frameMaterial);
            frameTop.position.set(0, doorHeight + frameThickness/2, roomDepth/2 + 0.01);
            personalRoomScene.add(frameTop);

            // Paneles decorativos en la puerta
            const panelMat = getCachedMaterial(0xC19A6B, 0.65, 0.22);
            for (let i = 0; i < 4; i++) {
                const panelGeo = new THREE.BoxGeometry(doorWidth * 0.7, 0.38, 0.04);
                const panel = new THREE.Mesh(panelGeo, panelMat);
                panel.position.set(0, 2.1 - i * 0.6, roomDepth/2 + doorThickness/2 + 0.025);
                personalRoomScene.add(panel);
            }

            // Manija elegante (tipo pomo dorado)
            const knobGeo = new THREE.SphereGeometry(0.09, 24, 24);
            const knobMat = getCachedMaterial(0xFFD700, 0.7, 0.8); // Dorado
            const knob = new THREE.Mesh(knobGeo, knobMat);
            knob.position.set(doorWidth/2 - 0.18, doorHeight/2, roomDepth/2 + doorThickness/2 + 0.08);
            personalRoomScene.add(knob);

            // Placa bajo la manija
            const plateGeo = new THREE.CylinderGeometry(0.07, 0.07, 0.02, 24);
            const plateMat = getCachedMaterial(0xB8860B, 0.6, 0.5);
            const plate = new THREE.Mesh(plateGeo, plateMat);
            plate.rotation.x = Math.PI / 2;
            plate.position.set(doorWidth/2 - 0.18, doorHeight/2, roomDepth/2 + doorThickness/2 + 0.06);
            personalRoomScene.add(plate);
            // --- Huecos de ventana en las paredes laterales ---
            // Los huecos est√°n creados por las paredes segmentadas arriba
            // No se necesitan ventanas transparentes, solo los huecos en las paredes

            // === Piso ===
            const floorGeometry = new THREE.BoxGeometry(roomWidth, 0.2, roomDepth);
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.position.set(0, 0.1, 0);
            floor.receiveShadow = true;
            personalRoomScene.add(floor);

            // === Techo ===
            const ceilingGeometry = new THREE.BoxGeometry(roomWidth, 0.2, roomDepth);
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.position.set(0, roomHeight + 0.1, 0);
            ceiling.receiveShadow = false;
            personalRoomScene.add(ceiling);

            // Limpiar solo el array de muebles (NO borrar posiciones guardadas)
            furnitureObjects = [];

        }
        
        
        
        function updatePersonalRoomMovement() {
            // Si el chat est√° abierto, no actualizar movimiento
            if (chatOpen) {
                return;
            }
            
            // --- Rotaci√≥n con flechas izquierda/derecha y controles m√≥viles ---
            if (keys.ArrowLeft || mobileLeft) personalRoomTargetRotationY += ROTATE_SPEED;
            if (keys.ArrowRight || mobileRight) personalRoomTargetRotationY -= ROTATE_SPEED;

            // --- Movimiento hacia adelante/atr√°s con flechas y controles m√≥viles ---
            const direction = new THREE.Vector3();
            personalRoomCamera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();
            
            const velocity = new THREE.Vector3();
            
            // Movimiento hacia adelante/atr√°s con flechas arriba/abajo y controles m√≥viles
            if (keys.ArrowUp || mobileForward) velocity.add(direction);
            if (keys.ArrowDown || mobileBackward) velocity.sub(direction);
            
            // Movimiento lateral con A y D (teclas)
            const rightDirection = new THREE.Vector3();
            rightDirection.setFromMatrixColumn(personalRoomCamera.matrix, 0);
            rightDirection.y = 0;
            rightDirection.normalize();
            
            if (keyA) velocity.sub(rightDirection); // Moverse hacia la izquierda
            if (keyD) velocity.add(rightDirection); // Moverse hacia la derecha
            
            if (velocity.length() > 0) {
                velocity.normalize().multiplyScalar(MOVE_SPEED);
                const newPosition = personalRoomTargetPosition.clone().add(velocity);
                
                // --- L√≠mites de la habitaci√≥n (expandidos para exploraci√≥n completa) ---
                const roomBounds = {
                    minX: -11.6,  // M√°s cerca del muro izquierdo
                    maxX: 11.6,   // M√°s cerca del muro derecho
                    minZ: -11.6,  // M√°s cerca del muro trasero
                    maxZ: 11.6    // M√°s cerca del muro frontal
                };
                
                // Aplicar l√≠mites de la habitaci√≥n
                newPosition.x = Math.max(roomBounds.minX, Math.min(roomBounds.maxX, newPosition.x));
                newPosition.z = Math.max(roomBounds.minZ, Math.min(roomBounds.maxZ, newPosition.z));
                
                personalRoomTargetPosition.copy(newPosition);
            }

            // --- Mantener altura fija en la habitaci√≥n ---
            personalRoomTargetPosition.y = CAMERA_HEIGHT;
        }
        
        function animatePersonalRoom() {
            requestAnimationFrame(animatePersonalRoom);
            
            // Actualizar movimiento en la habitaci√≥n personal
            updatePersonalRoomMovement();
            
            // Aplicar movimiento suave a la c√°mara
            personalRoomCamera.position.lerp(personalRoomTargetPosition, 0.2);
            personalRoomCamera.rotation.y = lerpAngle(personalRoomCamera.rotation.y, personalRoomTargetRotationY, 0.2);
            
            personalRoomRenderer.render(personalRoomScene, personalRoomCamera);
        }
        
        function customizeRoom() {
            // Funci√≥n placeholder para personalizaci√≥n de habitaci√≥n
            alert('Funci√≥n de personalizaci√≥n de habitaci√≥n pr√≥ximamente disponible');
        }
        
        // --- Funciones del sistema de edici√≥n de muebles ---
        function toggleFurnitureEditMode() {
            if (currentScene !== 'personal-room') {
                alert('Debes estar en tu habitaci√≥n para editar muebles');
                return;
            }
            
            furnitureEditMode = !furnitureEditMode;
            
            if (furnitureEditMode) {
                // Limpiar todos los resaltados al entrar en modo de edici√≥n
                clearAllFurnitureHighlights();
                openFurnitureEditPanel();
                setupFurnitureSelection();
            } else {
                closeFurnitureEditPanel();
                deselectFurniture();
            }
        }
        
        function openFurnitureEditPanel() {
            const furnitureEditPanel = document.getElementById('furniture-edit-panel');
            if (furnitureEditPanel) {
                furnitureEditPanel.style.display = 'flex';
                furnitureEditPanelOpen = true;
                updateFurnitureList();
            }
        }
        
        function closeFurnitureEditPanel() {
            const furnitureEditPanel = document.getElementById('furniture-edit-panel');
            if (furnitureEditPanel) {
                furnitureEditPanel.style.display = 'none';
                furnitureEditPanelOpen = false;
            }
            furnitureEditMode = false;
            // Limpiar todos los resaltados al cerrar el panel
            clearAllFurnitureHighlights();
            deselectFurniture();
        }
        
        function setupFurnitureSelection() {
            // Hacer todos los muebles clickeables
            furnitureObjects.forEach(furniture => {
                if (furniture.mesh) {
                    furniture.mesh.userData.clickable = true;
                    furniture.mesh.userData.furnitureId = furniture.id;
                }
            });
        }
        
        function updateFurnitureList() {
            const furnitureList = document.getElementById('furniture-list');
            if (!furnitureList) return;
            
            furnitureList.innerHTML = '';
            
            if (furnitureObjects.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.style.cssText = 'padding: 16px; text-align: center; color: #bdc3c7; font-style: italic;';
                emptyMessage.textContent = 'No hay muebles en la habitaci√≥n. Usa el bot√≥n "Agregar Mueble" para comenzar.';
                furnitureList.appendChild(emptyMessage);
                return;
            }
            
            furnitureObjects.forEach(furniture => {
                const furnitureItem = document.createElement('div');
                furnitureItem.style.cssText = 'padding: 12px; margin: 6px 0; background: rgba(52,73,94,0.8); border-radius: 8px; cursor: pointer; border: 2px solid transparent; transition: all 0.2s; position: relative;';
                
                // Crear contenedor para el contenido y el bot√≥n
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; justify-content: space-between; align-items: center;';
                
                // Contenido del mueble
                const furnitureInfo = document.createElement('div');
                furnitureInfo.innerHTML = `
                    <div style="font-weight: bold; color: #fff; font-size: 16px; margin-bottom: 4px;">${furniture.name}</div>
                    <div style="font-size: 14px; color: #bdc3c7;">Posici√≥n: (${furniture.mesh.position.x.toFixed(1)}, ${furniture.mesh.position.z.toFixed(1)})</div>
                `;
                
                // Bot√≥n de eliminar
                const deleteButton = document.createElement('button');
                deleteButton.innerHTML = 'üóëÔ∏è';
                deleteButton.title = 'Eliminar mueble';
                deleteButton.style.cssText = 'background: rgba(231, 76, 60, 0.2); border: none; color: #e74c3c; font-size: 16px; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s;';
                
                // Efectos hover para el bot√≥n
                deleteButton.onmouseenter = (e) => {
                    e.stopPropagation();
                    deleteButton.style.background = 'rgba(231, 76, 60, 0.8)';
                    deleteButton.style.color = 'white';
                };
                
                deleteButton.onmouseleave = (e) => {
                    e.stopPropagation();
                    deleteButton.style.background = 'rgba(231, 76, 60, 0.2)';
                    deleteButton.style.color = '#e74c3c';
                };

                // Add click handler for delete button
                deleteButton.onclick = (e) => {
                    e.stopPropagation(); // Prevent furniture item selection
                    if (confirm('¬øEst√°s seguro de que quieres eliminar este mueble?')) {
                        removeFurniture(furniture.id);
                        updateFurnitureList(); // Re-render the list after deletion
                        showNotification(`üóëÔ∏è ${furniture.name} eliminado.`, 'info');
                    }
                };

                
                // Agregar elementos al contenedor
                content.appendChild(furnitureInfo);
                content.appendChild(deleteButton);
                furnitureItem.appendChild(content);
                
                // Manejar selecci√≥n del mueble
                furnitureItem.onclick = (e) => {
                    // Evitar que el clic en el bot√≥n de eliminar active la selecci√≥n
                    if (e.target === deleteButton || deleteButton.contains(e.target)) {
                        return;
                    }
                    selectFurniture(furniture.id);
                };
                
                furnitureItem.onmouseenter = () => {
                    furnitureItem.style.borderColor = '#3498db';
                    // Resaltar el mueble en la escena
                    if (furniture.mesh) {
                        furniture.mesh.traverse(child => {
                            if (child.isMesh) {
                                child.material.emissive = new THREE.Color(0x444444);
                            }
                        });
                    }
                };
                
                furnitureItem.onmouseleave = () => {
                    if (!selectedFurniture || selectedFurniture.id !== furniture.id) {
                        furnitureItem.style.borderColor = 'transparent';
                        // Quitar resaltado del mueble en la escena
                        if (furniture.mesh) {
                            furniture.mesh.traverse(child => {
                                if (child.isMesh) {
                                    child.material.emissive = new THREE.Color(0x000000);
                                }
                            });
                        }
                    }
                };
                
                if (selectedFurniture && selectedFurniture.id === furniture.id) {
                    furnitureItem.style.borderColor = '#27ae60';
                    furnitureItem.style.background = 'rgba(39,174,96,0.8)';
                }
                
                furnitureList.appendChild(furnitureItem);
            });
        }
        
        
        
        function selectFurniture(furnitureId) {
            const furniture = furnitureObjects.find(f => f.id === furnitureId);
            if (!furniture) return;
            
            // Limpiar todos los resaltados primero
            clearAllFurnitureHighlights();
            
            selectedFurniture = furniture;
            
            // Ocultar la ventana de la habitaci√≥n cuando se selecciona un mueble
            const roomNavigationPanel = document.getElementById('room-navigation-panel');
            if (roomNavigationPanel) {
                roomNavigationPanel.style.display = 'none';
            }
            // Ocultar el panel de edici√≥n de muebles cuando se selecciona un mueble
            const furnitureEditPanel = document.getElementById('furniture-edit-panel');
            if (furnitureEditPanel) {
                furnitureEditPanel.style.display = 'none';
            }
            
            // Resaltar SOLO el mueble seleccionado
            if (furniture.mesh) {
                if (furniture.mesh.children && furniture.mesh.children.length > 0) {
                    // Si es un grupo, resaltar todos los hijos
                    furniture.mesh.children.forEach(child => {
                        if (child.material) {
                            child.material.emissive = new THREE.Color(0x27ae60);
                            child.material.emissiveIntensity = 0.3;
                        }
                    });
                } else {
                    // Si es un mueble individual, resaltar directamente
                    if (furniture.mesh.material) {
                        furniture.mesh.material.emissive = new THREE.Color(0x27ae60);
                        furniture.mesh.material.emissiveIntensity = 0.3;
                    }
                }
            }
            
            updateFurnitureList();
        }
        
        function clearAllFurnitureHighlights() {
            // Limpiar resaltado de todos los muebles
            furnitureObjects.forEach(furniture => {
                if (furniture.mesh) {
                    if (furniture.mesh.children && furniture.mesh.children.length > 0) {
                        // Si es un grupo, quitar resaltado de todos los hijos
                        furniture.mesh.children.forEach(child => {
                            if (child.material) {
                                child.material.emissive = new THREE.Color(0x000000);
                                child.material.emissiveIntensity = 0;
                            }
                        });
                    } else {
                        // Si es un mueble individual, quitar resaltado directamente
                        if (furniture.mesh.material) {
                            furniture.mesh.material.emissive = new THREE.Color(0x000000);
                            furniture.mesh.material.emissiveIntensity = 0;
                        }
                    }
                }
            });
        }
        
        function deselectFurniture() {
            if (selectedFurniture && selectedFurniture.mesh) {
                if (selectedFurniture.mesh.children && selectedFurniture.mesh.children.length > 0) {
                    // Si es un grupo, quitar resaltado de todos los hijos
                    selectedFurniture.mesh.children.forEach(child => {
                        if (child.material) {
                            child.material.emissive = new THREE.Color(0x000000);
                            child.material.emissiveIntensity = 0;
                        }
                    });
                } else {
                    // Si es un mueble individual, quitar resaltado directamente
                    if (selectedFurniture.mesh.material) {
                        selectedFurniture.mesh.material.emissive = new THREE.Color(0x000000);
                        selectedFurniture.mesh.material.emissiveIntensity = 0;
                    }
                }
            }
            selectedFurniture = null;
            updateFurnitureList();
            
            // Mostrar la ventana de la habitaci√≥n cuando se deselecciona un mueble
            const roomNavigationPanel = document.getElementById('room-navigation-panel');
            if (roomNavigationPanel && roomNavigationPanelOpen) {
                roomNavigationPanel.style.display = 'flex';
            }
            // Mostrar el panel de edici√≥n de muebles cuando se deselecciona un mueble
            const furnitureEditPanel = document.getElementById('furniture-edit-panel');
            if (furnitureEditPanel && furnitureEditMode) {
                furnitureEditPanel.style.display = 'flex';
            }
        }
        
        function moveSelectedFurniture(direction) {
            if (!selectedFurniture || !selectedFurniture.mesh) return;
            
            const moveSpeed = 0.12; // velocidad reducida para controles m√≥viles
            const currentPosition = selectedFurniture.mesh.position.clone();
            
            switch (direction) {
                case 'forward':
                    currentPosition.z -= moveSpeed;
                    break;
                case 'backward':
                    currentPosition.z += moveSpeed;
                    break;
                case 'left':
                    currentPosition.x -= moveSpeed;
                    break;
                case 'right':
                    currentPosition.x += moveSpeed;
                    break;
            }
            
            // Aplicar l√≠mites de la habitaci√≥n (expandidos)
            const roomBounds = {
                minX: -8.0,
                maxX: 8.0,
                minZ: -8.0,
                maxZ: 8.0
            };
            
            currentPosition.x = Math.max(roomBounds.minX, Math.min(roomBounds.maxX, currentPosition.x));
            currentPosition.z = Math.max(roomBounds.minZ, Math.min(roomBounds.maxZ, currentPosition.z));
            
            // Mover el grupo completo
            selectedFurniture.mesh.position.set(currentPosition.x, currentPosition.y, currentPosition.z);
            updateFurnitureList();
            
            // Guardar autom√°ticamente la posici√≥n sin deseleccionar
            saveFurnitureInventory();
        }
        
        function rotateSelectedFurniture() {
            if (!selectedFurniture || !selectedFurniture.mesh) return;
            
            selectedFurniture.mesh.rotation.y += Math.PI / 4; // Rotar 45 grados
            updateFurnitureList();
            
            // Guardar autom√°ticamente la rotaci√≥n sin deseleccionar
            saveFurnitureInventory();
        }
        
        

        function animate(currentTime) {
            requestAnimationFrame(animate);
            // Obtener delta time del reloj para animaciones
            const deltaTime = clock.getDelta();
            // Control de FPS
            const frameDeltaTime = currentTime - lastTime;
            if (frameDeltaTime < frameInterval) {
                return;
            }
            lastTime = currentTime - (frameDeltaTime % frameInterval);
            frameCount++;
            // Sistema de timing centralizado para actualizaciones peri√≥dicas
            updatePeriodicSystems(currentTime);
            // Solo actualizar y renderizar si estamos en la escena del mall
            if (currentScene === 'mall') {
                updateMovement();
                updateAvatarPositions(); // Actualizar posiciones de avatares
                updateAvatarAnimations(deltaTime); // Animaciones de avatares
            ensureAvatarVisibility(); // Verificar visibilidad de avatares
            
            // Asegurar que las animaciones est√©n siempre activas
            userAvatars.forEach((avatar, alias) => {
                ensureAnimationState(avatar);
                // Prevenir pose T espec√≠ficamente en m√≥vil
                preventTPoseOnMobile(avatar);
            });
                // --- Mostrar botones de piso si el usuario est√° sobre el pasillo rojo oscuro (solo m√≥vil) ---
                if (window.IS_MOBILE) {
                    // Raycast hacia abajo desde la c√°mara
                    const downRay = new THREE.Raycaster();
                    const from = camera.position.clone();
                    const to = from.clone();
                    to.y -= 2; // 2 metros hacia abajo
                    downRay.set(from, new THREE.Vector3(0, -1, 0));
                    const intersects = downRay.intersectObjects(scene.children, true);
                    let onRedHall = false;
                    for (let i = 0; i < intersects.length; i++) {
                        const obj = intersects[i].object;
                        if (obj.material && obj.material.color && obj.material.color.getHex() === 0x4B0000) {
                            onRedHall = true;
                            break;
                        }
                    }
                    const floorBtns = document.getElementById('mobile-floor-buttons');
                    if (onRedHall) {
                        if (floorBtns.style.display !== 'flex') {
                            floorBtns.style.display = 'flex';
                        }
                        // Cancelar cualquier timeout de ocultar
                        clearTimeout(window._hideFloorBtnsTimeout);
                    } else {
                        if (floorBtns.style.display !== 'none') {
                            floorBtns.style.display = 'none';
                        }
                    }
                }
                renderer.render(scene, camera);
            }
        }
        
        // Funci√≥n centralizada para manejar todas las actualizaciones peri√≥dicas
        function updatePeriodicSystems(currentTime) {
            // Actualizar el color del cielo
            if (timingSystem.shouldUpdate(lastSkyUpdate, UPDATE_INTERVALS.SKY)) {
                scene.background = getSkyColor();
                timingSystem.updateLastTime('SKY');
            }
            
            // Enviar posici√≥n del usuario
            if (timingSystem.shouldUpdate(lastPositionUpdate, UPDATE_INTERVALS.POSITION)) {
                sendUserPosition();
                timingSystem.updateLastTime('POSITION');
            }
            
            // Actualizar carteles rotativos
            if (timingSystem.shouldUpdate(lastRotatingSignUpdate, UPDATE_INTERVALS.ROTATING_SIGN)) {
                updateRotatingSigns();
                timingSystem.updateLastTime('ROTATING_SIGN');
            }
            
            // Actualizar relojes digitales
            if (timingSystem.shouldUpdate(lastClockUpdate, UPDATE_INTERVALS.CLOCK)) {
                updateDigitalClocks();
                timingSystem.updateLastTime('CLOCK');
            }
        }
        
        // Variables globales para carteles rotativos y relojes
        let rotatingSigns = [];
        let digitalClocks = [];
        let rotatingSignTextIndexes = {};
        
        // Funci√≥n para actualizar carteles rotativos
        function updateRotatingSigns() {
            rotatingSigns.forEach((sign, index) => {
                if (sign.texts && sign.texts.length > 0) {
                    const textIndex = rotatingSignTextIndexes[index] || 0;
                    const nextIndex = (textIndex + 1) % sign.texts.length;
                    rotatingSignTextIndexes[index] = nextIndex;
                    updateRotatingSign(sign.material, sign.texts[nextIndex]);
                }
            });
        }
        
        // Funci√≥n para actualizar relojes digitales
        function updateDigitalClocks() {
            digitalClocks.forEach(clock => {
                updateClockPlane(clock.material);
            });
        }
        
        // Funci√≥n para limpiar recursos
        function cleanup() {
            // Limpiar cache de texturas
            logoTextureCache.forEach(texture => {
                if (texture && texture.dispose) {
                    texture.dispose();
                }
            });
            logoTextureCache.clear();
            
            // Limpiar cache de materiales
            materialCache.forEach(material => {
                if (material && material.dispose) {
                    material.dispose();
                }
            });
            materialCache.clear();
            
            // Limpiar cache de texturas generadas
            textureCache.forEach(texture => {
                if (texture && texture.dispose) {
                    texture.dispose();
                }
            });
            textureCache.clear();
            
            // Limpiar mixers de animaci√≥n
            userAvatars.forEach((avatar, alias) => {
                if (avatar.mixer) {
                    avatar.mixer.stopAllAction();
                    avatar.mixer.uncacheRoot(avatar.group);
                }
            });
            
            // Limpiar arrays del sistema centralizado
            rotatingSigns = [];
            digitalClocks = [];
            rotatingSignTextIndexes = {};
        }
        
        // Enhanced cleanup function
        function cleanup() {
            console.log('Cleaning up resources...');
            
            // Remove event listeners
            window.removeEventListener('resize', onWindowResize);
            window.removeEventListener('keydown', onKeyDown);
            window.removeEventListener('keyup', onKeyUp);
            window.removeEventListener('click', handleGlobalClick);
            window.removeEventListener('beforeunload', cleanup);
            
            // Remove mobile touch controls if they exist
            if (mobileJoystick) {
                mobileJoystick.destroy();
                document.body.removeChild(mobileJoystick.element);
            }
            
            // Dispose of all textures
            textureCache.forEach((texture, key) => {
                if (texture && texture.dispose) {
                    texture.dispose();
                    if (texture.image && texture.image.src) {
                        URL.revokeObjectURL(texture.image.src);
                    }
                }
            });
            textureCache.clear();
            
            // Dispose of all materials
            materialCache.forEach((material, key) => {
                if (material && material.dispose) {
                    material.dispose();
                }
            });
            materialCache.clear();
            
            // Dispose of geometries
            scene.traverse((object) => {
                if (object.geometry) {
                    object.geometry.dispose();
                }
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(material => material.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
            });
            
            // Clear the scene
            while(scene.children.length > 0) { 
                scene.remove(scene.children[0]); 
            }
            
            // Dispose of renderer
            if (renderer) {
                renderer.dispose();
                renderer.forceContextLoss();
                renderer.domElement = null;
                renderer = null;
            }
            
            // Clear all intervals and timeouts
            let id = window.setTimeout(function() {}, 0);
            while (id--) {
                window.clearTimeout(id);
            }
            
            id = window.setInterval(function() {}, 0);
            while (id--) {
                window.clearInterval(id);
            }
            
            console.log('Cleanup completed');
        }
        
        // Add cleanup on page unload
        window.addEventListener('beforeunload', cleanup);
        
        // Add visibility change handler to pause rendering when tab is not visible
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                // Free up memory when tab is not visible
                if (renderer) {
                    renderer.clear();
                }
            }
        });

        function lerpAngle(a, b, t) {
            let diff = b - a;
            while (diff < -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;
            return a + diff * t;
        }

        // --- Chat UI Logic ---
        const chatToggleBtn = document.getElementById('chat-toggle-btn');
        const chatPanel = document.getElementById('chat-panel');
        const chatCloseBtn = document.getElementById('chat-close-btn');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');
        const emojiToggle = document.getElementById('emoji-toggle');
        const emojiPanel = document.getElementById('emoji-panel');
        const usersList = document.getElementById('users-list');
        const changeAliasBtn = document.getElementById('change-alias-btn');
        let userAlias = localStorage.getItem('userAlias') || '';
        let chatOpen = false;
        let connectedUsers = [];
        
        chatToggleBtn.onclick = () => {
            const simplePanel = document.getElementById('simple-panel');
            if (simplePanel && simplePanel.style.display === 'block') {
                closeSimplePanel();
            }
            chatPanel.style.display = 'flex';
            chatOpen = true;
            chatInput.focus();
            // Forzar scroll abajo al abrir
            setTimeout(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }, 50);
            // El overlay NO debe mostrarse al abrir el chat
        };
        chatCloseBtn.onclick = () => {
            chatPanel.style.display = 'none';
            chatOpen = false;
            // El overlay NO debe ocultarse al cerrar el chat
        };

        // --- Emojis ---
        const emojis = ['üòä', 'üòÇ', '‚ù§Ô∏è', 'üëç', 'üéâ', 'üî•', 'üòé', 'ü§î', 'üò¢', 'üò°', 'üëã', 'üí™', 'üéØ', '‚≠ê', 'üíØ', 'üöÄ', 'üíé', 'üéÆ', 'üçï', '‚òï', 'üåÆ', 'üç∫', 'üéµ', 'üé¨', '‚öΩ', 'üèÄ', 'üéæ', 'üèà', '‚ö°', 'üåà', 'üåô', '‚òÄÔ∏è'];
        function createEmojiPanel() {
            emojiPanel.innerHTML = '';
            emojis.forEach(emoji => {
                const btn = document.createElement('button');
                btn.className = 'emoji-btn';
                btn.textContent = emoji;
                btn.onclick = () => {
                    chatInput.value += emoji;
                    chatInput.focus();
                    emojiPanel.style.display = 'none';
                };
                emojiPanel.appendChild(btn);
            });
        }
        emojiToggle.onclick = () => {
            if (emojiPanel.style.display === 'none' || !emojiPanel.style.display) {
                emojiPanel.style.display = 'flex';
                createEmojiPanel();
            } else {
                emojiPanel.style.display = 'none';
            }
        };

        // El manejo de emoji panel ahora est√° integrado en handleGlobalClick

        // --- Firebase Chat Logic ---
        function handleSendMessage() {
            const message = chatInput.value.trim();
            if (message.length > 0 && userAlias) {
                    sendMessage(message);
                chatInput.value = '';
            }
        }
        if (chatSendBtn && chatInput) {
            chatSendBtn.onclick = handleSendMessage;
            chatInput.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    handleSendMessage();
                }
            });
        } else {
            console.warn('chatSendBtn o chatInput no existen en el DOM al inicializar.');
        }

        // Alias setup and connect to chat
        if (!userAlias) {
            userAlias = 'Usuario_' + Math.floor(Math.random() * 10000);
            localStorage.setItem('userAlias', userAlias);
        }
        if (userAlias) {
            changeAliasBtn.style.display = 'flex';
        }
        connectToChat(userAlias); // Provided by firebase-config.js

        // --- Funciones de personalizaci√≥n de avatar ---
        const saveCustomizationBtn = document.getElementById('save-customization-btn');
        const resetCustomizationBtn = document.getElementById('reset-customization-btn');
        
        


        function openCustomizationPanel() {
            console.log('Abriendo panel simple de personalizaci√≥n');
            
            // Cerrar chat si est√° abierto
            if (chatOpen) {
                chatPanel.style.display = 'none';
                chatOpen = false;
            }
            
            const simplePanel = document.getElementById('simple-panel');
            if (simplePanel) {
                // Actualizar el alias actual
                const currentAliasElement = document.getElementById('current-alias');
                if (currentAliasElement) {
                    currentAliasElement.textContent = userAlias || 'Sin alias';
                }
                
                // Poblar el input con el alias actual
                const aliasInput = document.getElementById('simple-alias-input');
                if (aliasInput) {
                    aliasInput.value = userAlias || '';
                    // Agregar event listener para actualizar vista previa en tiempo real
                    aliasInput.addEventListener('input', function() {
                        updateAvatarPreview();
                    });
                }
                
                // Mostrar el panel primero
                simplePanel.style.display = 'block';
                simplePanel.style.zIndex = '31000';
                simplePanel.style.pointerEvents = 'auto';
                customizationPanelOpen = true;
                
                // Inicializar vista previa del avatar
                updateAvatarPreview();
                
                console.log('‚úÖ Panel simple mostrado');
                
                // Mostrar overlay despu√©s del panel, pero con pointer-events: none para el panel
            const overlay = document.getElementById('ui-overlay');
            if (overlay) {
                overlay.style.display = 'block';
                    overlay.style.pointerEvents = 'none'; // Cambiar a none para que no interfiera
                overlay.style.zIndex = '20000';
            }
            } else {
                console.log('‚ùå Panel simple no encontrado');
            }
        }
        

        
        
        
        
        
        
        
        
        
        function updateAvatarPreview(skinKey) {
    // Contenedor para el canvas 3D
    const container = document.getElementById('avatar-3d-preview-container');
    if (!container) return;

    // Limpiar canvas anterior si existe
    if (container._threePreviewCleanup) {
        container._threePreviewCleanup();
        container._threePreviewCleanup = null;
    }
    container.innerHTML = '';

    // Crear renderer Three.js
    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setClearColor(0x222222, 1);
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // Crear escena y c√°mara para preview
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(32, container.clientWidth / container.clientHeight, 0.1, 10);
    camera.position.set(0, 1.0, 3.1); // M√°s lejos y centrado
    camera.lookAt(0, 1.0, 0);

    // Luz direccional y ambiental
    const ambient = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 0.7);
    dir.position.set(2, 4, 4);
    scene.add(dir);

    // Obtener skin seleccionada
    let skinName = window.currentCustomization && window.currentCustomization.skin ? window.currentCustomization.skin : 'humanMaleA';
    let skinFile = window.skinFileMap && window.skinFileMap[skinName] ? window.skinFileMap[skinName] : 'assets/kenney 3d characters/Skins/humanMaleA.png';

    // Cargar modelo FBX y textura
    const fbxLoader = new THREE.FBXLoader();
    const textureLoader = new THREE.TextureLoader();
    let avatarMesh = null;
    let animationFrameId = null;
    let disposed = false;

    Promise.all([
        new Promise(resolve => fbxLoader.load('assets/kenney 3d characters/Model/characterMedium.fbx', resolve)),
        new Promise(resolve => textureLoader.load(skinFile, resolve))
    ]).then(([avatar, texture]) => {
        if (disposed) return;
        avatar.traverse(child => {
            if (child.isMesh) {
                child.material.map = texture;
                child.material.needsUpdate = true;
            }
        });
        avatar.position.set(0, 0.45, 0); // Subir el modelo para que se vea completo
        avatar.scale.set(0.0033, 0.0033, 0.0033); // Un poco m√°s grande, pero a√∫n visible completo
        avatar.rotation.y = Math.PI/6; // Ligeramente girado para mejor vista
        scene.add(avatar);
        avatarMesh = avatar;
        animate();
    });

    // Animaci√≥n de rotaci√≥n lenta
    function animate() {
        if (disposed) return;
        if (avatarMesh) {
            avatarMesh.rotation.y += 0.012;
        }
        renderer.render(scene, camera);
        animationFrameId = requestAnimationFrame(animate);
    }

    // Cleanup para evitar fugas
    container._threePreviewCleanup = function() {
        disposed = true;
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        renderer.dispose();
        while(scene.children.length > 0) scene.remove(scene.children[0]);
        if (renderer.domElement && renderer.domElement.parentNode)
            renderer.domElement.parentNode.removeChild(renderer.domElement);
    };
}           
        
        function saveSimpleCustomization() {
            console.log('Guardando personalizaci√≥n');
            const aliasInput = document.getElementById('simple-alias-input');
            const newAlias = aliasInput ? aliasInput.value.trim() : '';
            // Validar alias
            if (newAlias.length > 20) {
                alert('El nombre no puede tener m√°s de 20 caracteres');
                return;
            }
            // Guardar alias
            userAlias = newAlias;
            // Guardar en localStorage
            const customizationData = {
                alias: userAlias,
                skin: currentCustomization && currentCustomization.skin ? currentCustomization.skin : 'humanMaleA'
            };
            localStorage.setItem('avatarCustomization', JSON.stringify(customizationData));
            // Actualizar nombre en el avatar
            updateAvatarName && updateAvatarName();

            // --- NUEVO: Eliminar y recrear avatar con la nueva skin y colores ---
            // Obtener posici√≥n y piso actuales
            let position = { x: 25, y: 2, z: 25 };
            let floor = 0;
            if (userAvatars.has(userAlias)) {
            const myAvatar = userAvatars.get(userAlias);
                if (myAvatar && myAvatar.group) {
                    position = {
                        x: myAvatar.group.position.x,
                        y: myAvatar.group.position.y,
                        z: myAvatar.group.position.z
                    };
                }
                if (typeof myAvatar.floor !== 'undefined') {
                    floor = myAvatar.floor;
                } else if (typeof currentFloor !== 'undefined') {
                    floor = currentFloor;
                }
            } else if (typeof currentFloor !== 'undefined') {
                floor = currentFloor;
            }

            // Eliminar avatar anterior
            removeUserAvatar(userAlias);
            // Crear avatar nuevo con nueva skin y colores
            createUserAvatar(userAlias, position, floor, customizationData);

            // Enviar alias al servidor si est√° conectado
            if (typeof isConnected !== 'undefined' && isConnected) {
                sendAlias && sendAlias();
            }
            // Cerrar panel
            closeSimplePanel && closeSimplePanel();
            console.log('‚úÖ Personalizaci√≥n guardada y avatar actualizado:', customizationData);
        }
        
        function closeSimplePanel() {
            const panel = document.getElementById('simple-panel');
            if (panel) {
                panel.style.display = 'none';
                customizationPanelOpen = false;
                // Ocultar overlay y permitir clics
                const overlay = document.getElementById('ui-overlay');
                if (overlay) {
                    overlay.style.display = 'none';
                    overlay.style.pointerEvents = 'none';
                }
                panel.style.zIndex = '21000';
                panel.style.pointerEvents = 'auto';
                console.log('Panel simple cerrado');
            }
        }
        
        // --- SKIN SELECTION ARROWS LOGIC ---
document.addEventListener('DOMContentLoaded', function() {
    // [CASCADE-FIX-2025] Forzado commit para rutas de skins.
// Skins disponibles
    const skinList = [
    // Kenney pack original
    { key: 'humanMaleA', label: 'Humano Masculino', img: 'assets/kenney 3d characters/Skins/humanMaleA.png' },
    { key: 'humanFemaleA', label: 'Humano Femenino', img: 'assets/kenney 3d characters/Skins/humanFemaleA.png' },
    { key: 'zombieMaleA', label: 'Zombie Masculino', img: 'assets/kenney 3d characters/Skins/zombieMaleA.png' },
    { key: 'zombieFemaleA', label: 'Zombie Femenino', img: 'assets/kenney 3d characters/Skins/zombieFemaleA.png' },
    // Kannei 3d characters 1
    { key: 'criminalMaleA', label: 'Criminal Masculino', img: 'assets/kannei 3d characters 1/Skins/criminalMaleA.png' },
    { key: 'cyborgFemaleA', label: 'Cyborg Femenino', img: 'assets/kannei 3d characters 1/Skins/cyborgFemaleA.png' },
    { key: 'skaterFemaleA', label: 'Skater Femenina', img: 'assets/kannei 3d characters 1/Skins/skaterFemaleA.png' },
    { key: 'skaterMaleA', label: 'Skater Masculino', img: 'assets/kannei 3d characters 1/Skins/skaterMaleA.png' },
    // Kennei 3d characters 2
    { key: 'survivorFemaleA', label: 'Sobreviviente Femenina', img: 'assets/kennei 3d characters 2/Skins/survivorFemaleA.png' },
    { key: 'survivorMaleB', label: 'Sobreviviente Masculino', img: 'assets/kennei 3d characters 2/Skins/survivorMaleB.png' },
    { key: 'zombieA', label: 'Zombie A', img: 'assets/kennei 3d characters 2/Skins/zombieA.png' },
    { key: 'zombieC', label: 'Zombie C', img: 'assets/kennei 3d characters 2/Skins/zombieC.png' }
];
    // Obtener elementos
    const prevBtn = document.getElementById('skin-prev-btn');
    const nextBtn = document.getElementById('skin-next-btn');
    // Eliminado img, solo canvas 3D y label
    const label = document.getElementById('skin-preview-label');
    // Inicializar √≠ndice
    let currentIdx = skinList.findIndex(s => s.key === (currentCustomization && currentCustomization.skin ? currentCustomization.skin : 'humanMaleA'));
    if (currentIdx === -1) currentIdx = 0;
    // Funci√≥n para actualizar preview
    function updateSkinPreview(idx) {
        label.textContent = skinList[idx].label;
        window.currentCustomization.skin = skinList[idx].key;
        // Aplicar el skin al avatar inmediatamente
        applyCustomizationToAvatar();
        // Actualizar preview si existe
        if (typeof updateAvatarPreview === 'function') updateAvatarPreview();
        console.log('[updateSkinPreview] Skin cambiado a:', skinList[idx].key);
    }
    // Asignar eventos
    prevBtn && prevBtn.addEventListener('click', function() {
        currentIdx = (currentIdx - 1 + skinList.length) % skinList.length;
        updateSkinPreview(currentIdx);
    });
    nextBtn && nextBtn.addEventListener('click', function() {
        currentIdx = (currentIdx + 1) % skinList.length;
        updateSkinPreview(currentIdx);
    });
    // Inicializar preview
    updateSkinPreview(currentIdx);
    updateAvatarPreview();

    // Alias input para preview
    const aliasInput = document.getElementById('simple-alias-input');
    if (aliasInput) {
        aliasInput.addEventListener('input', function() {
            updateAvatarPreview();
        });
    }
});

        function closeWorkingPanel() {
            const panel = document.getElementById('working-customization-panel');
            if (panel) {
                panel.remove();
            }
            customizationPanelOpen = false;
        }
        
        function changeShirtColor(color) {
            currentCustomization.shirtColor = color;
            applyCustomizationToAvatar();
            console.log('Color de camisa cambiado a:', color);
        }
        
        function saveSimpleCustomization() {
            const aliasInput = document.getElementById('simple-alias-input');
            const newAlias = aliasInput.value.trim();
            
            if (newAlias.length > 0) {
                userAlias = newAlias;
                localStorage.setItem('userAlias', userAlias);
                
                if (isConnected) {
                    sendAlias();
                }
                
                console.log('Alias guardado:', newAlias);
            }
            
            // Aplicar la personalizaci√≥n al avatar antes de guardar
            applyCustomizationToAvatar();
            
            // Guardar en localStorage
            localStorage.setItem('avatarCustomization', JSON.stringify(window.currentCustomization));
            
            closeSimplePanel();
            showNotification('‚úÖ Personalizaci√≥n guardada exitosamente!', 'success');
        }
        
        
        

        

        

        


        function closeCustomizationPanel() {
            customizationPanel.style.display = 'none';
            customizationPanelOpen = false;
        }

        function createSkinSelection() {
    const skinOptions = document.querySelectorAll('.skin-option');
    skinOptions.forEach(btn => {
        btn.onclick = () => {
            const selectedSkin = btn.getAttribute('data-skin');
            window.currentCustomization.skin = selectedSkin;
            updateSelectedSkin();
            updateAvatarPreview();
            // --- FORZAR ENV√çO INMEDIATO DE SKIN A TODOS ---
            if (typeof sendPosition === 'function' && typeof camera !== 'undefined' && typeof currentFloor !== 'undefined') {
                const position = camera.position ? { x: camera.position.x, y: camera.position.y, z: camera.position.z } : { x: 0, y: 0, z: 0 };
                const rotation = camera.rotation ? camera.rotation.y : 0;
                sendPosition(position, currentFloor, rotation);
            }
        };
    });
}

function updateSelectedSkin() {
    const skinOptions = document.querySelectorAll('.skin-option');
    skinOptions.forEach(btn => {
        if (btn.getAttribute('data-skin') === currentCustomization.skin) {
            btn.classList.add('selected');
        } else {
            btn.classList.remove('selected');
        }
    });
}

        

        

        function resetCustomization() {
            // Restablecer a colores por defecto
            currentCustomization = {
                skin: 'humanMaleA'
            };
            
            // Aplicar cambios
            applyCustomizationToAvatar();
            updateSelectedSkin();
        }

        function loadCustomization() {
            const saved = localStorage.getItem('avatarCustomization');
            if (saved) {
                try {
                    window.currentCustomization = JSON.parse(saved);
                    // Si falta la propiedad skin, asignar valor por defecto
                    if (!window.currentCustomization.skin) window.currentCustomization.skin = 'humanMaleA';
                    applyCustomizationToAvatar();
                } catch (error) {
                    console.error('Error cargando personalizaci√≥n:', error);
                }
            }
        }

        // --- Aplica una skin espec√≠fica a cualquier avatar (propio o remoto) ---
function applySkinToAvatar(avatarData, skinName) {
    console.log('[applySkinToAvatar] llamada para alias:', avatarData && avatarData.group && avatarData.group.name, 'skin:', skinName);
    if (!avatarData || !avatarData.group || !skinName) {
        console.warn('[applySkinToAvatar] Avatar o skin inv√°lido:', avatarData, skinName);
        return;
    }
    const group = avatarData.group;
    const skinFileMap = window.skinFileMap;
    const texturePath = skinFileMap[skinName];
    if (!texturePath) {
        console.warn('[applySkinToAvatar] Skin no encontrada en skinFileMap:', skinName);
        return;
    }
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load(texturePath, (texture) => {
        group.traverse(child => {
            if (child.isMesh && child.material) {
                child.material.map = texture;
                child.material.needsUpdate = true;
            }
        });
        console.log('[applySkinToAvatar] Skin aplicada a avatar remoto:', skinName);
    }, undefined, (error) => {
        console.error('[applySkinToAvatar] Error al cargar textura remota:', error);
    });
}

function applyCustomizationToAvatar() {
            if (!window.currentCustomization) return;
            
            console.log('[applyCustomizationToAvatar] Aplicando personalizaci√≥n:', window.currentCustomization);
            
            // Actualizar el avatar del usuario actual
            if (userAvatars.has(userAlias)) {
                const avatarData = userAvatars.get(userAlias);
                if (avatarData && avatarData.group) {
    const group = avatarData.group;
    // --- Aplicar skin seleccionada ---
    const skinFileMap = window.skinFileMap;
    const skinKey = window.currentCustomization.skin || 'humanMaleA';
    const texturePath = skinFileMap[skinKey];
    if (!texturePath) {
        console.warn('[applyCustomizationToAvatar] Skin no encontrada en skinFileMap:', skinKey);
        return;
    }
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load(texturePath, (texture) => {
        group.traverse(child => {
            if (child.isMesh && child.material) {
                child.material.map = texture;
                child.material.needsUpdate = true;
            }
        });
        console.log('[applyCustomizationToAvatar] Skin aplicado exitosamente:', skinKey);
    }, undefined, (error) => {
        console.error('[applyCustomizationToAvatar] Error al cargar textura:', error);
    });

    // --- Aplicar colores de camisa si est√°n definidos ---
    if (window.currentCustomization.shirtColor) {
                        console.log('[applyCustomizationToAvatar] Aplicando color de camisa:', currentCustomization.shirtColor);
                        
                        group.traverse(child => {
                            if (child.isMesh && child.material) {
                                // Buscar el material de la camisa (puede variar seg√∫n el modelo)
                                if (child.material.name && child.material.name.toLowerCase().includes('shirt')) {
                                    child.material.color.setHex(currentCustomization.shirtColor);
                                    child.material.needsUpdate = true;
                                }
                            }
                        });
                    }
                }
            }
            
            // Guardar la personalizaci√≥n en localStorage
            localStorage.setItem('avatarCustomization', JSON.stringify(window.currentCustomization));
            
            console.log('[applyCustomizationToAvatar] Personalizaci√≥n aplicada y guardada');
        }


        // Cargar personalizaci√≥n al iniciar
        loadCustomization();

        function sendUserPosition() {
            if (userAlias) {
                
            }
        }

        function updateAvatarPosition(alias, position, floor, rotation = 0, skin = null) {
            console.log('[updateAvatarPosition] Llamada para alias:', alias, 'posici√≥n:', position, 'floor:', floor, 'skin:', skin);
            console.log('[updateAvatarPosition] window.IS_MOBILE:', window.IS_MOBILE, 'userAlias:', userAlias);
            console.log('[updateAvatarPosition] Total avatares antes:', userAvatars.size);
            
            if (!position || typeof position.x !== 'number' || typeof position.y !== 'number' || typeof position.z !== 'number') {
                console.warn('Posici√≥n inv√°lida para alias:', alias, position);
                return;
            }
            if (typeof floor !== 'number') {
                console.warn('Floor inv√°lido para alias:', alias, floor);
                return;
            }
            if (typeof rotation !== 'number') {
                console.warn('Rotaci√≥n inv√°lida para alias:', alias, rotation);
                return;
            }
            // No crear avatar para el usuario propio
            if (alias === userAlias) {
                console.log('[updateAvatarPosition] Saltando avatar propio:', alias);
                return;
            }
            let avatar = userAvatars.get(alias);
            if (!avatar) {
                console.log('[updateAvatarPosition] Creando nuevo avatar para:', alias);
                // Solo pasar skin si existe
                let custom = {};
                if (skin) custom.skin = skin;
                createUserAvatar(alias, position, floor, custom);
                avatar = userAvatars.get(alias);
            }
            if (avatar) {
                console.log('[updateAvatarPosition] Actualizando avatar existente para:', alias);
                // Actualizaci√≥n de posici√≥n y rotaci√≥n en tiempo real
                const floorStep = HALL_HEIGHT + 1;
                const targetY = floor * floorStep;
                avatar.targetPosition.set(position.x, targetY, position.z);
                avatar.currentFloor = floor;
                let normalizedRotation = rotation;
                while (normalizedRotation > Math.PI) normalizedRotation -= 2 * Math.PI;
                while (normalizedRotation < -Math.PI) normalizedRotation += 2 * Math.PI;
                avatar.targetRotation = normalizedRotation;

                // --- SINCRONIZAR SKIN REMOTA ---
        if (skin) {
            if (avatar.currentSkin !== skin) {
                console.log('[updateAvatarPosition] Skin remota cambi√≥ para', alias, ':', avatar.currentSkin, '=>', skin);
                applySkinToAvatar(avatar, skin);
                avatar.currentSkin = skin;
            } else {
                // Forzar re-aplicaci√≥n aunque sea igual, para casos de p√©rdida de textura
                console.log('[updateAvatarPosition] Skin remoto igual pero forzando re-aplicaci√≥n para', alias, ':', skin);
                applySkinToAvatar(avatar, skin);
            }
        }
            } else {
                console.warn('[updateAvatarPosition] No se pudo crear/obtener avatar para:', alias);
            }
            console.log('[updateAvatarPosition] Total avatares despu√©s:', userAvatars.size);
        }


        // Asegurar que el DOM est√© completamente cargado antes de inicializar
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
        
        // Funci√≥n para detectar dispositivo m√≥vil
        function isMobileDevice() {
            // Detecci√≥n m√°s robusta de dispositivos m√≥viles
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            const isMobileUA = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
            const isMobileWidth = window.innerWidth <= 768;
            const hasTouchSupport = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            
            const isMobile = isMobileUA || isMobileWidth || hasTouchSupport;
            
            console.log('[Mobile Detection] User Agent:', userAgent);
            console.log('[Mobile Detection] Window Width:', window.innerWidth);
            console.log('[Mobile Detection] Touch Support:', hasTouchSupport);
            console.log('[Mobile Detection] Mobile UA:', isMobileUA);
            console.log('[Mobile Detection] Mobile Width:', isMobileWidth);
            console.log('[Mobile Detection] Final Is Mobile:', isMobile);
            
            return isMobile;
        }
        
        // Funci√≥n para mostrar/ocultar controles m√≥viles
        function toggleMobileControls() {
            const mobileControls = document.getElementById('mobile-controls');
            const mobileRotationControls = document.getElementById('mobile-rotation-controls');
            
            if (mobileControls) {
                if (isMobileDevice()) {
                    mobileControls.style.display = 'block';
                } else {
                    mobileControls.style.display = 'none';
                }
            }
            
            if (mobileRotationControls) {
                if (isMobileDevice()) {
                    mobileRotationControls.style.display = 'block';
                } else {
                    mobileRotationControls.style.display = 'none';
                }
            }
        }
        
        // Detectar cambios de tama√±o de ventana
        window.addEventListener('resize', toggleMobileControls);
        
        // Inicializar controles m√≥viles al cargar
        document.addEventListener('DOMContentLoaded', toggleMobileControls);
        
        // Funci√≥n de depuraci√≥n para dispositivos m√≥viles
        function debugMobileDetection() {
            console.log('=== DEBUG MOBILE DETECTION ===');
            console.log('User Agent:', navigator.userAgent);
            console.log('Window Width:', window.innerWidth);
            console.log('Window Height:', window.innerHeight);
            console.log('Screen Width:', screen.width);
            console.log('Screen Height:', screen.height);
            console.log('Device Pixel Ratio:', window.devicePixelRatio);
            console.log('Touch Support:', 'ontouchstart' in window);
            console.log('window.IS_MOBILE constant:', window.IS_MOBILE);
            console.log('isMobileDevice() result:', isMobileDevice());
            console.log('================================');
        }
        
        // Ejecutar depuraci√≥n al cargar
        document.addEventListener('DOMContentLoaded', debugMobileDetection);
        
        // Funci√≥n de prueba para crear avatar de test
        function createTestAvatar() {
            console.log('[createTestAvatar] Creando avatar de prueba');
            const testPosition = { x: 0, y: 0, z: 0 };
            const testCustom = { skin: 'humanMaleA' };
            createUserAvatar('TEST_USER', testPosition, 0, testCustom);
        }
        
        
        
        // Funci√≥n para simular datos de posici√≥n de otro usuario
        function simulateOtherUserPosition() {
            console.log('[simulateOtherUserPosition] Simulando posici√≥n de otro usuario');
            const testPosition = { x: 5, y: 0, z: 5 };
            updateAvatarPosition('SIMULATED_USER', testPosition, 0, 0, 'humanMaleA');
        }
        
        // Exponer funci√≥n de simulaci√≥n globalmente
        window.simulateOtherUserPosition = simulateOtherUserPosition;
        
        
        // Lista de muebles disponibles de la carpeta 3d furniture
        const availableFurniture = [
            // Muebles de sala
            { name: 'Sof√° Moderno', file: 'loungeDesignSofa.fbx', category: 'Sala' },
            { name: 'Sof√° Largo', file: 'loungeSofaLong.fbx', category: 'Sala' },
            { name: 'Sof√° Esquinero', file: 'loungeSofaCorner.fbx', category: 'Sala' },
            { name: 'Sof√° con Otom√°n', file: 'loungeSofaOttoman.fbx', category: 'Sala' },
            { name: 'Sof√° Esquinero Moderno', file: 'loungeDesignSofaCorner.fbx', category: 'Sala' },
            { name: 'Silla de Relajaci√≥n', file: 'loungeChairRelax.fbx', category: 'Sala' },
            { name: 'Silla Moderna', file: 'loungeChair.fbx', category: 'Sala' },
            { name: 'Silla de Dise√±o', file: 'loungeDesignChair.fbx', category: 'Sala' },
            
            // Mesas
            { name: 'Mesa de Centro', file: 'tableCoffee.fbx', category: 'Mesas' },
            { name: 'Mesa de Centro Cuadrada', file: 'tableCoffeeSquare.fbx', category: 'Mesas' },
            { name: 'Mesa de Centro de Vidrio', file: 'tableCoffeeGlass.fbx', category: 'Mesas' },
            { name: 'Mesa de Centro Cuadrada de Vidrio', file: 'tableCoffeeGlassSquare.fbx', category: 'Mesas' },
            { name: 'Mesa Redonda', file: 'tableRound.fbx', category: 'Mesas' },
            { name: 'Mesa de Vidrio', file: 'tableGlass.fbx', category: 'Mesas' },
            { name: 'Mesa Cruzada', file: 'tableCross.fbx', category: 'Mesas' },
            { name: 'Mesa Cruzada con Tela', file: 'tableCrossCloth.fbx', category: 'Mesas' },
            { name: 'Mesa con Tela', file: 'tableCloth.fbx', category: 'Mesas' },
            { name: 'Mesa de Centro Cuadrada', file: 'tableCoffeeSquare.fbx', category: 'Mesas' },
            { name: 'Mesa de Centro de Vidrio', file: 'tableCoffeeGlass.fbx', category: 'Mesas' },
            { name: 'Mesa de Centro Cuadrada de Vidrio', file: 'tableCoffeeGlassSquare.fbx', category: 'Mesas' },
            { name: 'Mesa Redonda', file: 'tableRound.fbx', category: 'Mesas' },
            { name: 'Mesa de Vidrio', file: 'tableGlass.fbx', category: 'Mesas' },
            { name: 'Mesa Cruzada', file: 'tableCross.fbx', category: 'Mesas' },
            { name: 'Mesa Cruzada con Tela', file: 'tableCrossCloth.fbx', category: 'Mesas' },
            { name: 'Mesa con Tela', file: 'tableCloth.fbx', category: 'Mesas' },
            { name: 'Mesa', file: 'table.fbx', category: 'Mesas' },
            
            // Dormitorio
            { name: 'Cama con Coj√≠n Bajo', file: 'benchCushionLow.fbx', category: 'Dormitorio' },
            { name: 'Coj√≠n Azul', file: 'pillowBlue.fbx', category: 'Dormitorio' },
            { name: 'Coj√≠n Azul Largo', file: 'pillowBlueLong.fbx', category: 'Dormitorio' },
            { name: 'Coj√≠n Largo', file: 'pillowLong.fbx', category: 'Dormitorio' },
            { name: 'Coj√≠n', file: 'pillow.fbx', category: 'Dormitorio' },
            
            // Cocina
            { name: 'Estufa El√©ctrica', file: 'kitchenStoveElectric.fbx', category: 'Cocina' },
            { name: 'Estufa', file: 'kitchenStove.fbx', category: 'Cocina' },
            { name: 'Fregadero', file: 'kitchenSink.fbx', category: 'Cocina' },
            { name: 'Microondas', file: 'kitchenMicrowave.fbx', category: 'Cocina' },
            { name: 'Refrigerador Peque√±o', file: 'kitchenFridgeSmall.fbx', category: 'Cocina' },
            { name: 'Refrigerador Grande', file: 'kitchenFridgeLarge.fbx', category: 'Cocina' },
            { name: 'Refrigerador Empotrado', file: 'kitchenFridgeBuiltIn.fbx', category: 'Cocina' },
            { name: 'Refrigerador', file: 'kitchenFridge.fbx', category: 'Cocina' },
            { name: 'Cafetera', file: 'kitchenCoffeeMachine.fbx', category: 'Cocina' },
            { name: 'Licuadora', file: 'kitchenBlender.fbx', category: 'Cocina' },
            { name: 'Gabinete Superior', file: 'kitchenCabinetUpper.fbx', category: 'Cocina' },
            { name: 'Gabinete Superior Doble', file: 'kitchenCabinetUpperDouble.fbx', category: 'Cocina' },
            { name: 'Gabinete Superior Bajo', file: 'kitchenCabinetUpperLow.fbx', category: 'Cocina' },
            { name: 'Gabinete Superior Esquinero', file: 'kitchenCabinetUpperCorner.fbx', category: 'Cocina' },
            { name: 'Gabinete con Cajones', file: 'kitchenCabinetDrawer.fbx', category: 'Cocina' },
            { name: 'Gabinete Esquinero Redondo', file: 'kitchenCabinetCornerRound.fbx', category: 'Cocina' },
            { name: 'Gabinete Esquinero Interior', file: 'kitchenCabinetCornerInner.fbx', category: 'Cocina' },
            { name: 'Gabinete', file: 'kitchenCabinet.fbx', category: 'Cocina' },
            { name: 'Barra de Cocina', file: 'kitchenBar.fbx', category: 'Cocina' },
            { name: 'Extremo de Barra', file: 'kitchenBarEnd.fbx', category: 'Cocina' },
            { name: 'Campana Moderna', file: 'hoodModern.fbx', category: 'Cocina' },
            { name: 'Campana Grande', file: 'hoodLarge.fbx', category: 'Cocina' },
            
            // Ba√±o
            { name: 'Ducha Redonda', file: 'showerRound.fbx', category: 'Ba√±o' },
            { name: 'Ducha', file: 'shower.fbx', category: 'Ba√±o' },
            { name: 'Inodoro Cuadrado', file: 'toiletSquare.fbx', category: 'Ba√±o' },
            { name: 'Inodoro', file: 'toilet.fbx', category: 'Ba√±o' },
            { name: 'Lavadora y Secadora Apiladas', file: 'washerDryerStacked.fbx', category: 'Ba√±o' },
            { name: 'Lavadora', file: 'washer.fbx', category: 'Ba√±o' },
            { name: 'Secadora', file: 'dryer.fbx', category: 'Ba√±o' },
            
            // Iluminaci√≥n
            { name: 'L√°mpara de Pared', file: 'lampWall.fbx', category: 'Iluminaci√≥n' },
            { name: 'L√°mpara de Mesa Cuadrada', file: 'lampSquareTable.fbx', category: 'Iluminaci√≥n' },
            { name: 'L√°mpara de Piso Cuadrada', file: 'lampSquareFloor.fbx', category: 'Iluminaci√≥n' },
            { name: 'L√°mpara de Techo Cuadrada', file: 'lampSquareCeiling.fbx', category: 'Iluminaci√≥n' },
            { name: 'L√°mpara de Mesa Redonda', file: 'lampRoundTable.fbx', category: 'Iluminaci√≥n' },
            { name: 'L√°mpara de Piso Redonda', file: 'lampRoundFloor.fbx', category: 'Iluminaci√≥n' },
            { name: 'Ventilador de Techo', file: 'ceilingFan.fbx', category: 'Iluminaci√≥n' },
            
            // Electr√≥nicos
            { name: 'Televisi√≥n Moderna', file: 'televisionModern.fbx', category: 'Electr√≥nicos' },
            { name: 'Televisi√≥n Vintage', file: 'televisionVintage.fbx', category: 'Electr√≥nicos' },
            { name: 'Televisi√≥n con Antena', file: 'televisionAntenna.fbx', category: 'Electr√≥nicos' },
            { name: 'Radio', file: 'radio.fbx', category: 'Electr√≥nicos' },
            { name: 'Laptop', file: 'laptop.fbx', category: 'Electr√≥nicos' },
            { name: 'Pantalla de Computadora', file: 'computerScreen.fbx', category: 'Electr√≥nicos' },
            { name: 'Mouse de Computadora', file: 'computerMouse.fbx', category: 'Electr√≥nicos' },
            { name: 'Altavoz Peque√±o', file: 'speakerSmall.fbx', category: 'Electr√≥nicos' },
            { name: 'Altavoz', file: 'speaker.fbx', category: 'Electr√≥nicos' },
            
            // Escritorio
            { name: 'Escritorio Esquinero', file: 'deskCorner.fbx', category: 'Escritorio' },
            { name: 'Silla de Bar Cuadrada', file: 'stoolBarSquare.fbx', category: 'Escritorio' },
            { name: 'Silla de Bar', file: 'stoolBar.fbx', category: 'Escritorio' },
            
            // Almacenamiento
            { name: 'Estanter√≠a con Puertas', file: 'bookcaseClosedDoors.fbx', category: 'Almacenamiento' },
            { name: 'Mesa Lateral con Cajones', file: 'sideTableDrawers.fbx', category: 'Almacenamiento' },
            { name: 'Mesa Lateral', file: 'sideTable.fbx', category: 'Almacenamiento' },
            { name: 'Gabinete de TV con Puertas', file: 'cabinetTelevisionDoors.fbx', category: 'Almacenamiento' },
            { name: 'Perchero de Pared', file: 'coatRack.fbx', category: 'Almacenamiento' },
            { name: 'Perchero de Pie', file: 'coatRackStanding.fbx', category: 'Almacenamiento' },
            { name: 'Caja de Cart√≥n Cerrada', file: 'cardboardBoxClosed.fbx', category: 'Almacenamiento' },
            { name: 'Caja de Cart√≥n Abierta', file: 'cardboardBoxOpen.fbx', category: 'Almacenamiento' },
            
            // Decoraci√≥n
            { name: 'Planta en Maceta', file: 'pottedPlant.fbx', category: 'Decoraci√≥n' },
            { name: 'Planta Peque√±a 1', file: 'plantSmall1.fbx', category: 'Decoraci√≥n' },
            { name: 'Planta Peque√±a 2', file: 'plantSmall2.fbx', category: 'Decoraci√≥n' },
            { name: 'Planta Peque√±a 3', file: 'plantSmall3.fbx', category: 'Decoraci√≥n' },
            { name: 'Alfombra Cuadrada', file: 'rugSquare.fbx', category: 'Decoraci√≥n' },
            { name: 'Alfombra Redondeada', file: 'rugRounded.fbx', category: 'Decoraci√≥n' },
            { name: 'Alfombra Redonda', file: 'rugRound.fbx', category: 'Decoraci√≥n' },
            { name: 'Alfombra Rectangular', file: 'rugRectangle.fbx', category: 'Decoraci√≥n' },
            { name: 'Alfombra de Entrada', file: 'rugDoormat.fbx', category: 'Decoraci√≥n' },
            { name: 'Panel de Pared', file: 'paneling.fbx', category: 'Decoraci√≥n' },
            
            // Miscel√°neos
            { name: 'Tostadora', file: 'toaster.fbx', category: 'Miscel√°neos' },
            { name: 'Papelera', file: 'trashcan.fbx', category: 'Miscel√°neos' },
            { name: 'Escaleras Abiertas', file: 'stairsOpen.fbx', category: 'Miscel√°neos' },
            { name: 'Escaleras Abiertas Individuales', file: 'stairsOpenSingle.fbx', category: 'Miscel√°neos' },
            { name: 'Escaleras Esquineras', file: 'stairsCorner.fbx', category: 'Miscel√°neos' },
            { name: 'Escaleras', file: 'stairs.fbx', category: 'Miscel√°neos' },
            { name: 'Ventana Deslizante', file: 'wallWindowSlide.fbx', category: 'Miscel√°neos' },
            { name: 'Ventana', file: 'wallWindow.fbx', category: 'Miscel√°neos' },
            { name: 'Pared Media', file: 'wallHalf.fbx', category: 'Miscel√°neos' },
            { name: 'Pared', file: 'wall.fbx', category: 'Miscel√°neos' },
            { name: 'Pared Esquinera Redonda', file: 'wallCornerRond.fbx', category: 'Miscel√°neos' },
            { name: 'Pared Esquinera', file: 'wallCorner.fbx', category: 'Miscel√°neos' },
            { name: 'Puerta Ancha', file: 'wallDoorwayWide.fbx', category: 'Miscel√°neos' },
            { name: 'Puerta', file: 'wallDoorway.fbx', category: 'Miscel√°neos' },
            { name: 'Puerta Frontal', file: 'doorwayFront.fbx', category: 'Miscel√°neos' },
            { name: 'Puerta Abierta', file: 'doorwayOpen.fbx', category: 'Miscel√°neos' },
            { name: 'Piso Completo', file: 'floorFull.fbx', category: 'Miscel√°neos' },
            { name: 'Piso Medio', file: 'floorHalf.fbx', category: 'Miscel√°neos' },
            { name: 'Piso Esquinero Redondo', file: 'floorCornerRound.fbx', category: 'Miscel√°neos' },
            { name: 'Piso Esquinero', file: 'floorCorner.fbx', category: 'Miscel√°neos' }
        ];
        
        // Funci√≥n para cargar un mueble GLB (antes FBX)
        function loadFurnitureGLB(furnitureData, position = { x: 0, y: 0, z: 0 }, rotation = 0, scale = { x: 1, y: 1, z: 1 }) {
            return new Promise((resolve, reject) => {
                // Verificar que estamos en la habitaci√≥n personal
                if (currentScene !== 'personal-room') {
                    reject(new Error('Debes estar en la habitaci√≥n personal para agregar muebles'));
                    return;
                }
                
                // Verificar que la escena existe
                if (!personalRoomScene) {
                    reject(new Error('La escena de la habitaci√≥n personal no est√° inicializada'));
                    return;
                }
                
                // Usar GLTFLoader para modelos .glb
                const gltfLoader = new THREE.GLTFLoader();
                let fileName = furnitureData.file;
                if (fileName.toLowerCase().endsWith('.fbx')) {
                    fileName = fileName.replace(/\.fbx$/i, '.glb');
                }
                const modelPath = `assets/3d furniture/Models/GLTF format/${fileName}`;

                console.log(`Intentando cargar mueble: ${furnitureData.name} desde ${modelPath}`);

                gltfLoader.load(
                    modelPath,
                    (gltf) => {
                        // gltf.scene es el objeto principal
                        const object = gltf.scene;
                        console.log(`Modelo cargado exitosamente: ${furnitureData.name}`);

                        // Configurar el objeto cargado
                        // Calcular la caja delimitadora para determinar la altura del modelo
                        const box = new THREE.Box3().setFromObject(object);
                        const size = box.getSize(new THREE.Vector3());
                        
                        // Guardar la altura del modelo para usarla al guardar
                        furnitureData.modelHeight = size.y;
                        
                        // Establecer la posici√≥n del objeto
                        // La posici√≥n Y proporcionada siempre es 0 (base del modelo)
                        // Ajustamos la posici√≥n para que la base del modelo est√© en Y=0
                        object.position.set(
                            position.x || 0,
                            (position.y || 0) + (size.y / 2), // Ajustar para que la base est√© en Y=0
                            position.z || 0
                        );
                        
                        // Establecer la rotaci√≥n
                        object.rotation.y = rotation || 0;

                        // Calcular escala apropiada basada en el tama√±o del modelo
                        // Reutilizamos la caja delimitadora ya calculada
                        const maxDimension = Math.max(size.x, size.y, size.z);

                        // Escala base para que el mueble tenga un tama√±o apropiado en la habitaci√≥n
                        let scale = 1.0;
                        if (maxDimension > 0) {
                            // Si el mueble es muy grande, reducirlo
                            if (maxDimension > 5) {
                                scale = 0.5 / maxDimension;
                            } else if (maxDimension > 2) {
                                scale = 1.0 / maxDimension;
                            } else if (maxDimension < 0.5) {
                                scale = 1.0 / maxDimension;
                            }
                        }

                        // Aplicar escala (m√°s grande)
                        const finalScale = scale * 2.0;
                        object.scale.set(finalScale, finalScale, finalScale);

                        console.log(`Escala aplicada: ${scale} (tama√±o original: ${maxDimension.toFixed(2)})`);

                        // Aplicar materiales si es necesario
                        object.traverse((child) => {
                            if (child.isMesh) {
                                if (child.material) {
                                    child.material.roughness = 0.8;
                                    child.material.metalness = 0.2;
                                }
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });

                        // Crear objeto de mueble con todos los campos necesarios
                        const furnitureObject = {
                            id: furnitureData.id || `furniture_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                            name: furnitureData.name || 'Mueble sin nombre',
                            category: furnitureData.category || 'general',
                            file: furnitureData.file || '',
                            mesh: object,
                            originalPosition: { ...position },
                            originalRotation: rotation || 0,
                            // Asegurarse de que las propiedades de posici√≥n, rotaci√≥n y escala est√©n presentes
                            position: {
                                x: position?.x || 0,
                                y: position?.y || 0,
                                z: position?.z || 0
                            },
                            rotation: {
                                y: rotation || 0
                            },
                            scale: {
                                x: (furnitureData.scale?.x !== undefined) ? furnitureData.scale.x : 1,
                                y: (furnitureData.scale?.y !== undefined) ? furnitureData.scale.y : 1,
                                z: (furnitureData.scale?.z !== undefined) ? furnitureData.scale.z : 1
                            }
                        };
                        
                        console.log('[loadFurnitureGLB] Mueble creado:', furnitureObject);

                        // Agregar a la escena y al array de muebles
                        personalRoomScene.add(object);
                        furnitureObjects.push(furnitureObject);

                        console.log(`Mueble agregado exitosamente: ${furnitureData.name} (ID: ${furnitureObject.id})`);
                        console.log(`Total de muebles en la habitaci√≥n: ${furnitureObjects.length}`);

                        resolve(furnitureObject);
                    },
                    (progress) => {
                        if (progress && progress.loaded && progress.total) {
                            console.log(`Cargando ${furnitureData.name}: ${(progress.loaded / progress.total * 100).toFixed(1)}%`);
                        }
                    },
                    (error) => {
                        console.error(`Error al cargar ${furnitureData.name}:`, error);
                        reject(error);
                    }
                );
            });
        }
        
        // Funci√≥n para agregar mueble desde el panel
        function addFurnitureFromPanel(furnitureData, button) {
            console.log(`Intentando agregar mueble: ${furnitureData.name}`);
            
            // Verificar que estamos en la habitaci√≥n personal
            if (currentScene !== 'personal-room') {
                showNotification('Debes estar en tu habitaci√≥n personal para agregar muebles. Entra primero a tu habitaci√≥n.', 'error');
                if (button) {
                    button.textContent = originalText;
                    button.disabled = false;
                }
                return;
            }
            
            // Posici√≥n por defecto en el centro de la habitaci√≥n
            const defaultPosition = { x: 0, y: 0, z: 0 };
            
            // Mostrar indicador de carga
            const originalText = button ? button.textContent : 'Agregar';
            if (button) {
                button.textContent = 'Cargando...';
                button.disabled = true;
            }
            
            loadFurnitureGLB(furnitureData, defaultPosition, 0)
                .then((furnitureObject) => {
                    console.log(`Mueble agregado exitosamente: ${furnitureObject.name}`);
                    
                    // Actualizar la lista de muebles
                    updateAvailableFurnitureList(); // Re-render the list to reflect changes
                    
                    // Seleccionar el mueble reci√©n agregado
                    selectFurniture(furnitureObject.id);
                    
                    // Mostrar mensaje de √©xito
                    showNotification(`‚úÖ ${furnitureData.name} agregado exitosamente`, 'success');
                    
                    // Restaurar bot√≥n
                    if (button) {
                        button.textContent = originalText;
                        button.disabled = false;
                    }
                })
                .catch((error) => {
                    console.error('Error al agregar mueble:', error);
                    
                    // Mostrar mensaje de error
                    showNotification(`‚ùå Error al agregar ${furnitureData.name}: ${error.message}`, 'error');
                    
                    // Restaurar bot√≥n
                    if (button) {
                        button.textContent = originalText;
                        button.disabled = false;
                    }
                });
        }
        
        // Funciones para el panel de selecci√≥n de muebles
        function openFurnitureSelectionPanel() {
            const panel = document.getElementById('furniture-selection-panel');
            if (panel) {
                panel.style.display = 'flex';
                updateAvailableFurnitureList();
            }
        }
        
        function closeFurnitureSelectionPanel() {
            const panel = document.getElementById('furniture-selection-panel');
            if (panel) {
                panel.style.display = 'none';
            }
        }
        
        async function updateAvailableFurnitureList() {
            const furnitureList = document.getElementById('available-furniture-list');
            const categoryFilter = document.getElementById('furniture-category-filter');
            if (!furnitureList) return;
            
            const selectedCategory = categoryFilter ? categoryFilter.value : 'all';
            
            furnitureList.innerHTML = '';

            const availableFurniture = await getAvailableFurniture();
            
            const filteredFurniture = selectedCategory === 'all' 
                ? availableFurniture 
                : availableFurniture.filter(f => f.category === selectedCategory);
            
            filteredFurniture.forEach(furniture => {
                const furnitureItem = document.createElement('div');
                furnitureItem.style.cssText = 'padding: 12px; margin: 6px; background: rgba(52,73,94,0.8); border-radius: 8px; cursor: pointer; border: 2px solid transparent; transition: all 0.2s; display: flex; justify-content: space-between; align-items: center;';
                furnitureItem.innerHTML = `
                    <div>
                        <div style="font-weight: bold; color: #fff; font-size: 14px; margin-bottom: 4px;">${furniture.name}</div>
                        <div style="font-size: 12px; color: #bdc3c7;">${furniture.category}</div>
                    </div>
                    <button class="add-furniture-btn" data-furniture='${JSON.stringify(furniture)}' style="padding: 6px 12px; background: #27ae60; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">+</button>
                `;
                
                furnitureItem.onmouseenter = () => furnitureItem.style.borderColor = '#3498db';
                furnitureItem.onmouseleave = () => furnitureItem.style.borderColor = 'transparent';
                
                furnitureList.appendChild(furnitureItem);
            });
        }
        
        // Event listener para el filtro de categor√≠as
        document.addEventListener('DOMContentLoaded', function() {
            const categoryFilter = document.getElementById('furniture-category-filter');
            if (categoryFilter) {
                categoryFilter.addEventListener('change', updateAvailableFurnitureList);
            }

            const furnitureList = document.getElementById('available-furniture-list');
            if (furnitureList) {
                furnitureList.addEventListener('click', function(event) {
                    const target = event.target;
                    if (target.classList.contains('add-furniture-btn')) {
                        const furnitureDataString = target.dataset.furniture;
                        try {
                            const furnitureData = JSON.parse(furnitureDataString);
                            addFurnitureFromPanel(furnitureData, target); // Pass the button element as well
                        } catch (e) {
                            console.error('Error parsing furniture data from button:', e);
                        }
                    }
                });
            }
        });
        
        
        // Funci√≥n para mostrar notificaciones
        function showNotification(message, type = 'info') {
            // Crear elemento de notificaci√≥n
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                border-radius: 8px;
                color: white;
                font-weight: bold;
                z-index: 50000;
                max-width: 300px;
                word-wrap: break-word;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                transform: translateX(100%);
                transition: transform 0.3s ease-out;
            `;
            
            // Configurar colores seg√∫n el tipo
            switch(type) {
                case 'success':
                    notification.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                    break;
                case 'error':
                    notification.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
                    break;
                case 'warning':
                    notification.style.background = 'linear-gradient(135deg, #f39c12, #e67e22)';
                    break;
                default:
                    notification.style.background = 'linear-gradient(135deg, #3498db, #2980b9)';
            }
            
            notification.textContent = message;
            document.body.appendChild(notification);
            
            // Animar entrada
            setTimeout(() => {
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            // Auto-eliminar despu√©s de 3 segundos
            setTimeout(() => {
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }
        
        // Exponer funci√≥n de debug globalmente
        

        // Configurar overlay al cargar la p√°gina
        document.addEventListener('DOMContentLoaded', () => {
            const overlay = document.getElementById('ui-overlay');
            if (overlay) {
                overlay.style.pointerEvents = 'auto';
            }
        });

        
       

        // Mostrar prompt de alias si no existe
        if (!userAlias) {
            userAlias = prompt('Ingresa tu alias:');
            if (userAlias) {
                localStorage.setItem('userAlias', userAlias);
            } else {
                userAlias = 'Usuario_' + Math.floor(Math.random() * 10000);
                localStorage.setItem('userAlias', userAlias);
            }
        }

        // Conectar al chat de Firebase
        connectToChat(userAlias);

        

        // Sistema de posici√≥n centralizado - manejado por updatePeriodicSystems()

        // Funci√≥n mejorada para mostrar mensajes en el chat
        function addMessageToChat(alias, message, type = 'user', timestamp = null, isPrivate = false, recipient = null) {
            const chatMessages = document.getElementById('chat-messages');
            if (!chatMessages) return;
            let timeStr = '';
            if (timestamp) {
                const date = new Date(timestamp);
                timeStr = `<span style="color:#aaa; font-size:11px; margin-left:8px;">${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>`;
            }
            const isOwn = (alias === userAlias || type === 'own');
            const msgDiv = document.createElement('div');
            msgDiv.className = isOwn ? 'chat-message own' : 'chat-message';
            msgDiv.style.margin = '6px 0';
            msgDiv.style.textAlign = isOwn ? 'right' : 'left';
            if (isPrivate) {
                msgDiv.style.background = 'rgba(255,215,0,0.12)';
                msgDiv.style.border = '1px solid #FFD700';
                msgDiv.innerHTML = `<span style="color:${isOwn ? '#FFD700' : '#4ECDC4'}; font-weight:bold;">${alias} (privado):</span> <span style="color:#fff;">${message}</span> ${timeStr}`;
            } else {
                msgDiv.innerHTML = `<span style="color:${isOwn ? '#FFD700' : '#4ECDC4'}; font-weight:bold;">${alias}:</span> <span style="color:#fff;">${message}</span> ${timeStr}`;
            }
            chatMessages.appendChild(msgDiv);
            // Limitar a los √∫ltimos 10 mensajes
            while (chatMessages.children.length > 10) {
                chatMessages.removeChild(chatMessages.firstChild);
            }
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        window.addMessageToChat = addMessageToChat;

        // Listener de mensajes de Firebase - ELIMINADO para evitar duplicados
        // El listener principal est√° en firebase-config.js

        // Sistema de Firebase listeners optimizado - manejado en firebase-config.js
        // Los listeners espec√≠ficos (child_added, child_changed, child_removed) est√°n configurados all√≠

        // --- Eliminar avatar de usuario de la escena y del mapa ---
function removeUserAvatar(alias) {
    const avatar = userAvatars.get(alias);
            if (avatar) {
                if (avatar.group) {
        scene.remove(avatar.group);
                }
                // Limpiar mixer de animaci√≥n
                if (avatar.mixer) {
                    avatar.mixer.stopAllAction();
                    avatar.mixer.uncacheRoot(avatar.group);
                }
    }
    userAvatars.delete(alias);
    pendingAvatarLoads.delete(alias);
}
        
        // Exponer funci√≥n para uso en firebase-config.js
        window.removeUserAvatar = removeUserAvatar;

// --- Control de cargas pendientes para evitar duplicados por race conditions ---
const pendingAvatarLoads = new Set();

// --- Funci√≥n para crear un avatar de usuario con animaciones correctamente cargadas ---
function createUserAvatar(alias, position = {x:0, y:0, z:0}, floor = 0, custom = {}) {
    console.log('[createUserAvatar] llamado para alias:', alias, position, floor, custom);
    console.log('[createUserAvatar] window.IS_MOBILE:', window.IS_MOBILE, 'userAlias:', userAlias);
    
    // Si ya hay una carga pendiente para este alias, no la repitas
    if (pendingAvatarLoads.has(alias)) {
        console.log('[createUserAvatar] Carga pendiente para:', alias);
        return;
    }
    
    // Elimina cualquier avatar anterior con el mismo alias para evitar duplicados
    removeUserAvatar(alias);
    
    // Si por alguna raz√≥n sigue existiendo, no continuar
    if (userAvatars.has(alias)) {
        console.log('[createUserAvatar] Avatar ya existe para:', alias);
        return;
    }
    
    pendingAvatarLoads.add(alias);
    
    const modelPath = 'assets/kenney 3d characters/Model/characterMedium.fbx';
    
    // Elegir el skin correcto
    let skinName = (custom && custom.skin) ? custom.skin : (currentCustomization && currentCustomization.skin ? currentCustomization.skin : 'humanMaleA');
    const skinFileMap = {
        'humanMaleA': 'humanMaleA.png',
        'humanFemaleA': 'humanFemaleA.png',
        'zombieMaleA': 'zombieMaleA.png',
        'zombieFemaleA': 'zombieFemaleA.png'
    };
    const texturePath = `assets/kenney 3d characters/Skins/${skinFileMap[skinName] || 'humanMaleA.png'}`;
    
    const fbxLoader = new THREE.FBXLoader();
    const textureLoader = new THREE.TextureLoader();
    
    // Calcular la posici√≥n Y correcta para el piso
    const floorStep = HALL_HEIGHT + 1;
    const correctY = floor * floorStep;
    
    // Usaremos Promises para manejar las cargas as√≠ncronas de forma limpia
    const modelPromise = new Promise(resolve => fbxLoader.load(modelPath, resolve));
    const texturePromise = new Promise(resolve => textureLoader.load(texturePath, resolve));
    const idleAnimPromise = new Promise(resolve => fbxLoader.load('assets/kenney 3d characters/Animations/idle.fbx', resolve));
    const runAnimPromise = new Promise(resolve => fbxLoader.load('assets/kenney 3d characters/Animations/run.fbx', resolve));
    
    Promise.all([modelPromise, texturePromise, idleAnimPromise, runAnimPromise])
        .then(([avatar, texture, idleAnimation, runAnimation]) => {
            
            pendingAvatarLoads.delete(alias);
            
            // Si el alias ya no es v√°lido (fue eliminado durante la carga), no agregues el avatar
            if (userAvatars.has(alias)) return;
            
            // Aplicar la textura al modelo
            avatar.traverse(child => {
                if (child.isMesh) {
                    child.material.map = texture;
                    child.material.needsUpdate = true;
                }
            });
            
            // Configurar posici√≥n y escala
            avatar.position.set(position.x, correctY, position.z);
            avatar.scale.set(0.009, 0.009, 0.009);
            scene.add(avatar);
            
            // --- L√ìGICA DE ANIMACI√ìN CORRECTA ---
            const mixer = new THREE.AnimationMixer(avatar);
            const actions = {};

            // REGISTRO ROBUSTO EN userAvatars
            userAvatars.set(alias, {
                group: avatar,
                mixer,
                actions,
                targetPosition: avatar.position.clone(),
                targetRotation: avatar.rotation.y,
                isMoving: false,
                currentFloor: floor
            }); // Registro robusto tras setup


            // Los clips de animaci√≥n vienen en el array `animations` de los archivos cargados
            const idleClip = idleAnimation.animations[0];
            // Diagn√≥stico y selecci√≥n inteligente de clip para 'run'
let runClip = undefined;
if (runAnimation && Array.isArray(runAnimation.animations) && runAnimation.animations.length > 0) {
    console.log('--- CLIPS ENCONTRADOS EN run.fbx ---');
    runAnimation.animations.forEach((clip, i) => {
        console.log(`Clip #${i}: Nombre='${clip.name}', Duraci√≥n=${clip.duration}, Tracks=${clip.tracks.length}`);
        clip.tracks.forEach((track, j) => {
            console.log(`   Track #${j}: ${track.name}, Keyframes: ${track.times.length}`);
        });
    });
    // Seleccionar el clip con mayor duraci√≥n (usualmente el de animaci√≥n, no el de pose)
    runClip = runAnimation.animations.reduce((best, clip) => {
        return (!best || clip.duration > best.duration) ? clip : best;
    }, undefined);
    console.log('Clip seleccionado para RUN:', runClip ? runClip.name : 'Ninguno');
} else {
    console.warn('runAnimation.animations no existe o est√° vac√≠o');
}
console.log('runClip:', runClip);
console.log('--- FIN DIAGN√ìSTICO RAW ---');

            if (idleClip) {
                actions.idle = mixer.clipAction(idleClip);
                actions.idle.setLoop(THREE.LoopRepeat, Infinity);
                actions.idle.timeScale = 1.0; // Velocidad normal para ambos dispositivos
                actions.idle.clampWhenFinished = false;
                actions.idle.play(); // Iniciar en 'idle' por defecto
                console.log('Animaci√≥n Idle cargada para:', alias);
            }
            
            if (runClip) {
                // Renombramos el clip para que coincida con lo que buscamos ('run')
                runClip.name = 'run';
                actions.run = mixer.clipAction(runClip);
                // Configurar animaci√≥n de correr para que sea m√°s fluida
                actions.run.setLoop(THREE.LoopRepeat, Infinity);
                actions.run.timeScale = 1.0; // Velocidad normal para ambos dispositivos
                actions.run.clampWhenFinished = false; // Evitar que se quede en la √∫ltima pose
                console.log('Animaci√≥n Run cargada para:', alias);
                
                // Reasignar tracks para eliminar prefijo 'mixamorig:' si existe
                if (runClip.tracks) {
                runClip.tracks.forEach(track => {
                    if (track.name.startsWith('mixamorig:')) {
                        track.name = track.name.replace('mixamorig:', '');
                    }
                });
                }
            }
            
            // Si no se carg√≥ ninguna animaci√≥n, al menos el avatar aparecer√° est√°tico
            if (Object.keys(actions).length === 0) {
                console.warn(`No se cargaron clips de animaci√≥n para el avatar ${alias}`);
            }
            
            // --- FIN DE LA L√ìGICA DE ANIMACI√ìN ---
            
            printAllBones({ group: avatar }); // Debug: mostrar huesos en consola
            console.log('Avatar a√±adido:', alias, avatar.position, avatar.scale);
            
            // Guardar el avatar y su mixer
            userAvatars.set(alias, {
                group: avatar,
                mixer: mixer,
                actions: actions,
                targetPosition: new THREE.Vector3(position.x, correctY, position.z),
                targetRotation: 0,
                currentFloor: floor,
                isMoving: false
            });
            
        }).catch(error => {
            pendingAvatarLoads.delete(alias);
            console.error('[createUserAvatar] Error loading avatar for:', alias, error);
        });
}

        // --- Utilidad para debug: imprimir huesos del modelo FBX ---
        function printAllBones(avatar) {
            if (!avatar || !avatar.group) return;
            console.log('--- Huesos del avatar:', avatar.group.name, '---');
            avatar.group.traverse(child => {
                if (child.isBone) {
                    console.log('Bone:', child.name);
                }
            });
        }
       
        // Utilidad opcional para hashCode de string (alias)
        if (!String.prototype.hashCode) {
    String.prototype.hashCode = function() {
        var hash = 0, i, chr;
        if (this.length === 0) return hash;
        for (i = 0; i < this.length; i++) {
            chr   = this.charCodeAt(i);
            hash  = ((hash << 5) - hash) + chr;
            hash |= 0; // Convert to 32bit integer
        }
        return hash;
    };
}
        // --- Funci√≥n para actualizar todas las posiciones de avatares ---
function updateAvatarPositions() {
    console.log('[updateAvatarPositions] Total avatares:', userAvatars.size, 'window.IS_MOBILE:', window.IS_MOBILE);
    userAvatars.forEach((avatar, alias) => {
        console.log('[updateAvatarPositions] Procesando avatar:', alias, 'visible:', avatar.group.visible);
                // Interpolar posici√≥n y rotaci√≥n
        avatar.group.position.lerp(avatar.targetPosition, 0.2);
                avatar.group.rotation.y = lerpAngle(avatar.group.rotation.y, avatar.targetRotation, 0.2);

                // --- L√ìGICA DE CONTROL DE ANIMACI√ìN MEJORADA ---
                const isNowMoving = avatar.group.position.distanceTo(avatar.targetPosition) > 0.1;

                if (isNowMoving && !avatar.isMoving) {
                    // Empez√≥ a moverse: cambia de 'idle' a 'run'
                    if (avatar.actions && avatar.actions.run && avatar.actions.idle) {
                        // Transici√≥n simple sin fade para evitar cortes
                        avatar.actions.idle.stop();
                        avatar.actions.run.reset().play();
                        console.log('[Animation] Cambio directo idle -> run para:', alias);
                    } else if (avatar.actions && avatar.actions.run && avatar.actions.default) {
                        avatar.actions.default.stop();
                        avatar.actions.run.reset().play();
                        console.log('[Animation] Cambio directo default -> run para:', alias);
                    }
                    avatar.isMoving = true;
                } else if (!isNowMoving && avatar.isMoving) {
                    // Dej√≥ de moverse: cambia de 'run' a 'idle'
                    if (avatar.actions && avatar.actions.run && avatar.actions.idle) {
                        avatar.actions.run.stop();
                        avatar.actions.idle.reset().play();
                        console.log('[Animation] Cambio directo run -> idle para:', alias);
                    } else if (avatar.actions && avatar.actions.run && avatar.actions.default) {
                        avatar.actions.run.stop();
                        avatar.actions.default.reset().play();
                        console.log('[Animation] Cambio directo run -> default para:', alias);
                    }
                    avatar.isMoving = false;
                }
            });
        }

        // --- Funci√≥n para actualizar animaciones de avatares ---
        function updateAvatarAnimations(deltaTime) {
            userAvatars.forEach((avatar, alias) => {
                if (avatar.mixer) {
                    // deltaTime ya est√° en segundos desde THREE.Clock
                    avatar.mixer.update(deltaTime);
                }
            });
        }

        // --- Funci√≥n para verificar y corregir visibilidad de avatares ---
        function ensureAvatarVisibility() {
            userAvatars.forEach((avatar, alias) => {
                if (avatar.group && !avatar.group.visible) {
                    console.log('[ensureAvatarVisibility] Forzando visibilidad para avatar:', alias);
                    avatar.group.visible = true;
                }
            });
        }
        
        // --- Funci√≥n para mejorar la fluidez de las animaciones ---
        function smoothAnimationTransition(avatar, fromAction, toAction, duration = 0.15) {
            if (!fromAction || !toAction) return;
            
            // Asegurar que las acciones est√©n configuradas correctamente
            fromAction.setLoop(THREE.LoopRepeat, Infinity);
            toAction.setLoop(THREE.LoopRepeat, Infinity);
            toAction.clampWhenFinished = false;
            toAction.timeScale = 1.0; // Velocidad consistente
            
            // Transici√≥n suave con duraci√≥n fija
            fromAction.fadeOut(0.2);
            toAction.reset().fadeIn(0.2).play();
            
            console.log('[Animation] Transici√≥n completada para:', avatar.group.name);
        }
        
        // --- Funci√≥n para asegurar que las animaciones est√©n siempre activas ---
        function ensureAnimationState(avatar) {
            if (!avatar.actions) return;
            
            // Verificar que siempre haya una animaci√≥n activa
            let hasActiveAction = false;
            Object.values(avatar.actions).forEach(action => {
                if (action.isRunning() && action.getEffectiveWeight() > 0.1) {
                    hasActiveAction = true;
                }
            });
            
            // Si no hay animaci√≥n activa, activar idle
            if (!hasActiveAction && avatar.actions.idle) {
                avatar.actions.idle.reset().play();
                avatar.actions.idle.timeScale = 1.0;
                avatar.actions.idle.setEffectiveWeight(1.0);
                console.log('[Animation] Reactivando animaci√≥n idle');
            }
        }
        
        // --- Funci√≥n espec√≠fica para prevenir pose T en m√≥vil ---
        function preventTPoseOnMobile(avatar) {
            if (!avatar.actions) return;
            
            // Verificar si el avatar est√° en pose T (sin animaci√≥n activa)
            let hasActiveAnimation = false;
            Object.values(avatar.actions).forEach(action => {
                if (action.isRunning() && action.getEffectiveWeight() > 0.1) {
                    hasActiveAnimation = true;
                }
            });
            
            // Si no hay animaci√≥n activa, forzar la animaci√≥n idle
            if (!hasActiveAnimation && avatar.actions.idle) {
                console.log('[Animation] Detectada pose T, forzando animaci√≥n idle');
                avatar.actions.idle.reset().play();
                avatar.actions.idle.timeScale = 1.0;
                avatar.actions.idle.setEffectiveWeight(1.0);
            }
        }

        

        function openSimplePanel() {
            const panel = document.getElementById('simple-panel');
            if (panel) {
                panel.style.display = 'block';
                customizationPanelOpen = true;
                // Inicializar vista previa del avatar
                updateAvatarPreview();
                // Inicializar selecci√≥n de skin
                createSkinSelection();
                // Actualizar selecci√≥n de skin
                updateSelectedSkin();
            }
        }

        
        

        // Eliminar definici√≥n duplicada de addMessageToChat y el listener de mensajes p√∫blicos en index.html
        // Dejar solo la versi√≥n de addMessageToChat que soporta mensajes privados y exponerla en window
        window.addMessageToChat = addMessageToChat;

        // --- Sistema de posici√≥n centralizado ---
        function sendUserPosition() {
                if (
                    typeof camera !== 'undefined' &&
                    camera.position &&
                    typeof camera.position.x !== 'undefined' &&
                    typeof camera.position.y !== 'undefined' &&
                    typeof camera.position.z !== 'undefined'
                ) {
                    const position = {
                        x: camera.position.x,
                        y: camera.position.y,
                        z: camera.position.z
                    };
                    const floor = typeof currentFloor !== 'undefined' ? currentFloor : 0;
                    const rotation = typeof camera.rotation !== 'undefined' ? -camera.rotation.y : 0;
                    console.log('[sendUserPosition] Enviando posici√≥n:', position, 'floor:', floor, 'rotation:', rotation, 'window.IS_MOBILE:', window.IS_MOBILE);
                    sendPosition(position, floor, rotation);
                } else {
                    console.warn('[sendUserPosition] Camera no disponible o posici√≥n inv√°lida');
                }
        }
        
        // Iniciar al conectar
        document.addEventListener('DOMContentLoaded', () => {
            connectToChat(userAlias);
        });
        
        // Limpiar al cerrar la p√°gina
        window.addEventListener('beforeunload', () => {
            disconnectFromChat();
        });

        // Funci√≥n para controlar los eventos del canvas seg√∫n el estado de la UI
        function updateCanvasPointerEvents() {
            const canvas = renderer.domElement;
            const chatOpen = document.getElementById('chat-panel').style.display === 'flex';
            const panelOpen = document.getElementById('simple-panel').style.display === 'block';
            
            if (chatOpen || panelOpen) {
                canvas.style.pointerEvents = 'none';
            } else {
                canvas.style.pointerEvents = 'auto';
            }
        }

        // --- Ventanas independientes para chats privados ---
        const privateChatsContainer = document.getElementById('private-chats-container');
        const privateChatWindows = {};
        const privateChatListeners = {};

        function openPrivateChatWindow(alias) {
            if (!alias || alias === userAlias) return;
            if (privateChatWindows[alias]) {
                // Traer al frente
                privateChatWindows[alias].style.zIndex = Date.now();
                privateChatWindows[alias].style.display = 'block';
                privateChatsContainer.style.pointerEvents = 'auto';
                return;
            }
            // Crear ventana
            const win = document.createElement('div');
            win.className = 'private-chat-window';
            win.style.cssText = `width:320px; height:380px; background:rgba(30,30,30,0.97); border-radius:10px; box-shadow:0 4px 24px #000a; position:relative; margin-bottom:16px; margin-left:16px; display:block; pointer-events:auto; overflow:hidden; border:2px solid #FFD700;`;
            win.style.zIndex = Date.now();
            win.innerHTML = `
                <div style="background:#222; color:#FFD700; padding:10px 14px; font-weight:bold; display:flex; align-items:center; justify-content:space-between;">
                    <span>Chat privado con ${alias}</span>
                    <button style="background:none; border:none; color:#FFD700; font-size:18px; cursor:pointer;" title="Cerrar">‚úñ</button>
                </div>
                <div class="private-chat-messages" style="flex:1; padding:10px; overflow-y:auto; height:260px; background:rgba(34,34,34,0.95);"></div>
                <div style="padding:10px; border-top:1px solid #333; background:rgba(34,34,34,0.95); display:flex;">
                    <input class="private-chat-input" type="text" placeholder="Escribe un mensaje privado..." style="flex:1; border:none; background:#333; color:#fff; border-radius:6px; padding:8px; font-size:15px;">
                    <button class="private-chat-send-btn" style="background:#FFD700; color:#222; border:none; border-radius:6px; margin-left:8px; padding:8px 14px; font-size:15px; cursor:pointer;">Enviar</button>
                </div>
            `;
            privateChatsContainer.appendChild(win);
            privateChatsContainer.style.pointerEvents = 'auto';
            privateChatWindows[alias] = win;
            // Cerrar ventana
            win.querySelector('button[title="Cerrar"]').onclick = () => closePrivateChatWindow(alias);
            // Enviar mensaje
            const input = win.querySelector('.private-chat-input');
            const sendBtn = win.querySelector('.private-chat-send-btn');
            sendBtn.onclick = () => {
                const msg = input.value.trim();
                if (msg) {
                    sendPrivateMessage(alias, msg);
                    input.value = '';
                }
            };
            input.addEventListener('keydown', e => {
                if (e.key === 'Enter') sendBtn.onclick();
            });
            // Cargar historial y escuchar nuevos mensajes
            loadPrivateChatHistory(alias, win.querySelector('.private-chat-messages'));
        }
        function closePrivateChatWindow(alias) {
            if (privateChatWindows[alias]) {
                privateChatsContainer.removeChild(privateChatWindows[alias]);
                delete privateChatWindows[alias];
            }
            if (privateChatListeners[alias]) {
                privateChatListeners[alias]();
                delete privateChatListeners[alias];
            }
            // Si no quedan ventanas, desactivar pointer-events
            if (Object.keys(privateChatWindows).length === 0) {
                privateChatsContainer.style.pointerEvents = 'none';
            }
        }
        function loadPrivateChatHistory(alias, messagesDiv) {
            // Limpiar mensajes previos
            messagesDiv.innerHTML = '';
            const chatId = getPrivateChatId(userAlias, alias);
            const privateRef = firebase.database().ref('privateMessages').child(chatId);
            // Cargar √∫ltimos 20 mensajes
            const loadedTimestamps = new Set();
            privateRef.limitToLast(20).once('value', snapshot => {
                const msgs = [];
                snapshot.forEach(child => {
                    const msg = child.val();
                    msgs.push(msg);
                    if (msg.timestamp) loadedTimestamps.add(msg.timestamp);
                });
                msgs.forEach(msg => {
                    appendPrivateMessage(messagesDiv, msg, alias);
                });
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            });
            // Escuchar nuevos mensajes (solo si no est√°n ya en el historial)
            const listener = privateRef.limitToLast(1).on('child_added', snap => {
                const msg = snap.val();
                if (!msg.timestamp || !loadedTimestamps.has(msg.timestamp)) {
                    appendPrivateMessage(messagesDiv, msg, alias);
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                }
            });
            // Guardar funci√≥n para limpiar listener
            privateChatListeners[alias] = () => privateRef.off('child_added', listener);
        }
        function appendPrivateMessage(messagesDiv, msg, otherAlias) {
            const isOwn = msg.from === userAlias;
            const div = document.createElement('div');
            div.className = isOwn ? 'chat-message own' : 'chat-message';
            div.style.margin = '6px 0';
            div.style.textAlign = isOwn ? 'right' : 'left';
            div.innerHTML = `<span style="color:${isOwn ? '#FFD700' : '#4ECDC4'}; font-weight:bold;">${isOwn ? 'T√∫' : otherAlias}:</span> <span style="color:#fff;">${msg.message}</span> <span style="color:#aaa; font-size:11px; margin-left:8px;">${msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : ''}</span>`;
            messagesDiv.appendChild(div);
            // Limitar a los √∫ltimos 20 mensajes
            while (messagesDiv.children.length > 20) {
                messagesDiv.removeChild(messagesDiv.firstChild);
            }
        }
        // UI: Al hacer clic en un usuario, abrir ventana privada
        usersList.addEventListener('click', function(e) {
            const userItem = e.target.closest('.user-item');
            if (userItem && !userItem.classList.contains('own')) {
                const alias = userItem.textContent.replace(' (T√∫)', '').trim();
                openPrivateChatWindow(alias);
            }
        });

        // Devuelve el color del cielo seg√∫n la hora actual (d√≠a, atardecer, noche)
        function getSkyColorByHour() {
            const hour = new Date().getHours();
            if (hour >= 7 && hour < 18) {
                return 0x87CEEB; // D√≠a: azul claro
            } else if (hour >= 18 && hour < 20) {
                return 0xFFA07A; // Atardecer: naranja/rojo suave
            } else {
                return 0x223366; // Noche: azul oscuro
            }
        }

        // --- Variables globales para el cielo de la habitaci√≥n personal ---
        
    </script>
    <script>
        // ... existing code ...
        // --- Al final del setupEventListeners o en DOMContentLoaded ---
        document.addEventListener('DOMContentLoaded', function() {
            if (window.IS_MOBILE) {
                // Ocultar botones al inicio
                const floorBtns = document.getElementById('mobile-floor-buttons');
                floorBtns.style.display = 'none';
                // Listeners para los botones
                document.getElementById('btn-floor-1').onclick = function(e) {
                    e.stopPropagation();
                    currentFloor = 0;
                    floorBtns.style.display = 'none';
                };
                document.getElementById('btn-floor-2').onclick = function(e) {
                    e.stopPropagation();
                    currentFloor = 1;
                    floorBtns.style.display = 'none';
                };
            }
        });
        // ... existing code ...
        // --- En handleGameClick, despu√©s de raycaster.setFromCamera(mouse, camera); ---
            // Detectar si se hizo clic en la franja roja oscura de los pasillos (solo m√≥vil)
            if (window.IS_MOBILE && scene && scene.children && raycaster && typeof raycaster.intersectObjects === 'function') {
                const intersectsAll = raycaster.intersectObjects(scene.children, true);
                for (let i = 0; i < intersectsAll.length; i++) {
                    const obj = intersectsAll[i].object;
                    // Detectar por color/material del pasillo rojo oscuro
                    if (obj.material && obj.material.color && obj.material.color.getHex() === 0x4B0000) {
                        // Mostrar botones de piso
                        const floorBtns = document.getElementById('mobile-floor-buttons');
                        floorBtns.style.display = 'flex';
                        // Ocultar autom√°ticamente despu√©s de 4 segundos si no se presiona
                        clearTimeout(window._hideFloorBtnsTimeout);
                        window._hideFloorBtnsTimeout = setTimeout(() => {
                            floorBtns.style.display = 'none';
                        }, 4000);
                        break;
                    }
                }
            }
        // ... existing code ...
    </script>
    <script defer src="https://analytics.vercel.com/script.js" data-api="/api/event" data-domain="3d-mall-chat.vercel.app"></script>
</body>
