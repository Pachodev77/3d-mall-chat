<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paseo Virtual por Centro Comercial</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            mix-blend-mode: difference;
            z-index: 10;
            pointer-events: none;
        }
        #chat-toggle-btn {
            position: fixed;
            top: 16px;
            left: 16px;
            width: 36px;
            height: 36px;
            background: #222;
            color: #fff;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            z-index: 22000;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            font-size: 20px;
            transition: background 0.2s;
        }
        #chat-toggle-btn:hover {
            background: #444;
        }
        #chat-panel {
            position: fixed;
            top: 60px;
            left: 16px;
            width: 480px;
            max-width: 90vw;
            height: 600px;
            background: rgba(30,30,30,0.85);
            border-radius: 12px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.4);
            z-index: 31000;
            display: none;
            flex-direction: column;
            overflow: hidden;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }
        #chat-header {
            background: rgba(24,24,24,0.9);
            color: #fff;
            padding: 12px 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        #chat-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        #chat-main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        #users-sidebar {
            width: 140px;
            background: rgba(34,34,34,0.9);
            border-left: 1px solid #333;
            padding: 8px;
            overflow-y: auto;
        }
        #users-title {
            color: #aaa;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
        }
        .user-item {
            color: #fff;
            font-size: 12px;
            padding: 4px 6px;
            margin-bottom: 2px;
            border-radius: 4px;
            background: #333;
            border-left: 3px solid transparent;
        }
        #emoji-panel {
            position: absolute;
            bottom: 70px;
            left: 10px;
            right: 10px;
            background: rgba(51,51,51,0.95);
            border-radius: 8px;
            padding: 10px;
            display: none;
            flex-wrap: wrap;
            gap: 4px;
            max-height: 140px;
            overflow-y: auto;
            backdrop-filter: blur(5px);
        }
        .emoji-btn {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: background 0.2s;
        }
        .emoji-btn:hover {
            background: #555;
        }
        #emoji-toggle {
            background: none;
            border: none;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            padding: 4px;
            margin-right: 4px;
        }
        #chat-close-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
        }
        #chat-messages {
            flex: 1;
            padding: 12px;
            overflow-y: auto;
            color: #eee;
            font-size: 15px;
        }
        #chat-input-area {
            display: flex;
            border-top: 1px solid #333;
            background: rgba(34,34,34,0.9);
            padding: 10px;
        }
        #chat-input {
            flex: 1;
            border: none;
            background: #333;
            color: #fff;
            border-radius: 6px;
            padding: 8px;
            font-size: 15px;
        }
        #chat-send-btn {
            background: #4B0000;
            color: #fff;
            border: none;
            border-radius: 6px;
            margin-left: 8px;
            padding: 8px 14px;
            font-size: 15px;
            cursor: pointer;
            transition: background 0.2s;
        }
        #chat-send-btn:hover {
            background: #800000;
        }
        #alias-prompt {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1002;
        }
        #alias-prompt input {
            padding: 10px;
            font-size: 16px;
            border-radius: 6px;
            border: none;
            margin-bottom: 12px;
        }
        #alias-prompt button {
            padding: 8px 18px;
            font-size: 15px;
            border-radius: 6px;
            border: none;
            background: #4B0000;
            color: #fff;
            cursor: pointer;
        }
        #change-alias-btn {
            position: fixed;
            top: 16px;
            left: 60px;
            width: 36px;
            height: 36px;
            background: #333;
            color: #fff;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            z-index: 22000;
            display: none;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            font-size: 16px;
            transition: background 0.2s;
        }
        #change-alias-btn:hover {
            background: #555;
        }
        
        /* Estilos para el panel de personalización simple */
        #simple-panel.customization-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 1100px;
            max-width: 99vw;
            height: 700px;
            background: linear-gradient(135deg, rgba(20,20,20,0.98), rgba(30,30,30,0.98));
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            z-index: 31000; /* Siempre por encima del overlay */
            display: none;
            flex-direction: column;
            overflow: hidden;
            backdrop-filter: blur(20px);
            border: 2px solid #4B0000;
            pointer-events: auto;
        }
        
        #simple-panel .panel-header {
            background: linear-gradient(135deg, #4B0000, #800000);
            color: #fff;
            padding: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 2px solid #FFD700;
        }
        
        #simple-panel .panel-header > div {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        #simple-panel .panel-header > div span:first-child {
            font-size: 28px;
        }
        
        #simple-panel .panel-header > div span:last-child {
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        #simple-panel .panel-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            color: #eee;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            min-height: 0;
            min-width: 0;
        }
        
        #simple-panel .options-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        #simple-panel .preview-column {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        #simple-panel .option-section {
            padding: 8px;
            background: linear-gradient(135deg, rgba(40,40,40,0.8), rgba(50,50,50,0.8));
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            margin-bottom: 4px;
        }
        
        #simple-panel .section-title {
            margin: 0 0 8px 0;
            color: #FFD700;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        #simple-panel .section-title span:first-child {
            font-size: 16px;
        }
        
        #simple-panel .color-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
        }
        
        #simple-panel .preview-section {
            padding: 10px;
            background: linear-gradient(135deg, rgba(40,40,40,0.8), rgba(50,50,50,0.8));
            border-radius: 6px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            text-align: center;
        }
        
        #simple-panel .avatar-preview {
            width: 150px;
            height: 200px;
            margin: 0 auto;
            position: relative;
            background: linear-gradient(135deg, rgba(20,20,20,0.5), rgba(30,30,30,0.5));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #333;
        }
        
        #simple-panel .panel-footer {
            padding: 8px 10px;
            background: linear-gradient(135deg, rgba(34,34,34,0.95), rgba(44,44,44,0.95));
            border-top: 1px solid #333;
            display: flex;
            gap: 6px;
            justify-content: flex-end;
        }
        
        /* Estilos adicionales para elementos específicos */
        #simple-panel .close-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            padding: 6px;
            border-radius: 6px;
            transition: all 0.3s;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #simple-panel .section-icon {
            font-size: 16px;
        }

        #simple-panel #simple-alias-input {
            width: 100%;
            padding: 12px;
            font-size: 14px;
            border-radius: 6px;
            border: 2px solid #333;
            background: rgba(20,20,20,0.8);
            color: #fff;
            box-sizing: border-box;
            transition: all 0.3s;
            outline: none;
        }

        #simple-panel #simple-alias-input:focus {
            border-color: #FFD700;
        }

        #customization-actions {
            padding: 16px 20px;
            background: rgba(34,34,34,0.9);
            border-top: 1px solid #333;
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            width: 100%;
            min-height: 60px;
            box-sizing: border-box;
        }
        
        .customization-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        #save-customization-btn {
            background: linear-gradient(135deg, #4B0000, #800000);
            color: #fff;
        }
        
        #save-customization-btn:hover {
            background: linear-gradient(135deg, #800000, #B22222);
            transform: translateY(-1px);
        }
        
        #reset-customization-btn {
            background: #333;
            color: #ccc;
        }
        
        #reset-customization-btn:hover {
            background: #555;
            color: #fff;
        }
        
        /* Estilos para los botones de color */
        .color-option {
            width: 30px;
            height: 30px;
            border: 2px solid #333;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--color, #333);
        }
        .color-option[data-color] {
            border: 2px solid #333;
        }
        .color-option:hover {
            border-color: #FFD700;
        }
        
        /* Animaciones para el panel */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        #simple-panel {
            animation: slideIn 0.3s ease-out;
        }
        
        /* Estilos para el input de alias */
        #simple-alias-input:focus {
            border-color: #FFD700 !important;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3) !important;
        }
        
        /* Estilos para los botones del footer */
        #simple-panel button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4) !important;
        }
        
        #simple-panel button:active {
            transform: translateY(0);
        }
        .chat-message {
            padding: 6px 10px;
            border-radius: 8px;
            margin-bottom: 4px;
            background: rgba(40,40,40,0.7);
            display: inline-block;
            max-width: 90%;
            word-break: break-word;
        }
        .chat-message.own {
            background: linear-gradient(90deg, #FFD70033, #FFD70011);
        }
        /* Overlay para bloquear clics al fondo cuando el panel de personalización está abierto */
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.5);
            z-index: 20000; /* Debe estar debajo del panel de personalización */
            pointer-events: none; /* Solo se activa cuando el panel está abierto */
            display: none; /* Solo se muestra cuando el panel está abierto */
        }
        /* Panel de personalización siempre por encima del overlay */
        #simple-panel.customization-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 1100px;
            max-width: 99vw;
            height: 700px;
            background: linear-gradient(135deg, rgba(20,20,20,0.98), rgba(30,30,30,0.98));
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            z-index: 31000; /* Siempre por encima del overlay */
            display: none;
            flex-direction: column;
            overflow: hidden;
            backdrop-filter: blur(20px);
            border: 2px solid #4B0000;
            pointer-events: auto;
        }
    </style>
</head>
<body>
    <!-- Contenedor de UI completamente separado del canvas -->
    <div id="ui-container" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 30000;">
        <div id="ui-overlay"></div>
    <div id="crosshair"></div>
        <button id="chat-toggle-btn" title="Abrir chat" style="pointer-events: auto;">💬</button>
        <button id="change-alias-btn" title="Personalizar avatar" style="pointer-events: auto;">👤</button>
    </div>
        <!-- Panel de personalización completamente rediseñado -->
    <div id="simple-panel" class="customization-panel">
        <!-- Header elegante -->
        <div class="panel-header">
            <div>
                <span>👤</span>
                <span>Personalizar Avatar</span>
            </div>
            <button onclick="closeSimplePanel()" class="close-btn">✖</button>
        </div>
        
        <!-- Contenido principal -->
        <div class="panel-content">
            <!-- Columna izquierda - Opciones -->
            <div class="options-column">
                <!-- Sección de Alias -->
                <div class="option-section">
                    <h3 class="section-title">
                        <span class="section-icon">📝</span>
                        Nombre del Avatar
                    </h3>
                    <input type="text" id="simple-alias-input" placeholder="Escribe tu nombre..." maxlength="20">
                </div>
                
                <!-- Sección de Colores de Camisa -->
                <div class="option-section">
                    <h3 class="section-title">
                        <span class="section-icon">👕</span>
                        Color de Camisa
                    </h3>
                    <div id="shirt-colors" class="color-grid">
                        <!-- Los colores se agregarán dinámicamente -->
                    </div>
                </div>
                
                <!-- Sección de Colores de Pantalón -->
                <div class="option-section">
                    <h3 class="section-title">
                        <span style="font-size: 20px;">👖</span>
                        Color de Pantalón
                    </h3>
                    <div id="pants-colors" class="color-grid">
                        <!-- Los colores se agregarán dinámicamente -->
                    </div>
                </div>
                
                <!-- Sección de Colores de Zapatos -->
                <div class="option-section">
                    <h3 class="section-title">
                        <span style="font-size: 20px;">👞</span>
                        Color de Zapatos
                    </h3>
                    <div id="shoes-colors" class="color-grid">
                        <!-- Los colores se agregarán dinámicamente -->
                    </div>
                </div>
            </div>
            
            <!-- Columna derecha - Vista previa -->
            <div class="preview-column">
                <!-- Vista previa del avatar -->
                <div class="preview-section">
                    <h3 style="margin: 0 0 20px 0; color: #FFD700; font-size: 18px; text-transform: uppercase; letter-spacing: 1px; display: flex; align-items: center; justify-content: center; gap: 10px;">
                        <span style="font-size: 20px;">👤</span>
                        Vista Previa
                    </h3>
                    <div id="avatar-preview" class="avatar-preview">
                        <div style="color: #ccc; font-size: 14px;">Avatar en tiempo real</div>
                    </div>
                </div>
                <!-- Eliminada la tarjeta de 'Nombre Actual' y alias -->
            </div>
        </div>
        
        <!-- Footer con botones -->
        <div class="panel-footer">
            <button onclick="resetSimpleCustomization()" style="padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; background: linear-gradient(135deg, #555, #777); color: #fff; transition: all 0.3s; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">🔄 Restablecer</button>
            <button onclick="saveSimpleCustomization()" style="padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; background: linear-gradient(135deg, #4B0000, #800000); color: #fff; transition: all 0.3s; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">💾 Guardar</button>
        </div>
    </div>
    <div id="chat-panel">
        <div id="chat-header">
            Chat
            <button id="chat-close-btn" title="Cerrar">✖</button>
        </div>
        <div id="chat-content">
            <div id="chat-main">
                <div id="chat-messages"></div>
                <div id="chat-input-area">
                    <button id="emoji-toggle" title="Emojis">😊</button>
                    <input id="chat-input" type="text" placeholder="Escribe un mensaje..." autocomplete="off" />
                    <button id="chat-send-btn">Enviar</button>
                </div>
                <div id="emoji-panel"></div>
            </div>
            <div id="users-sidebar">
                <div id="users-title">Usuarios</div>
                <div id="users-list"></div>
            </div>
        </div>
    </div>
    
    <!-- Panel de personalización de avatar -->
    <!-- Eliminado: <div id="customization-panel">...</div> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="/firebase-config.js"></script>
    <script>
        // URLs de las tiendas proporcionadas por el usuario (duplicadas para llenar todos los pisos)
        const originalStoreLinks = [
            "https://www.ipweb.pro/en/?Davincho88", "https://ipgold.biz/?r=meramente42@gmail.com", "https://surfe.be/ext/2837287",
            "https://sproutgigs.com/?a=0675642e", "https://r.adbtc.top/2847448", "https://www.coinpayu.com/?r=everest101",
            "https://surfio.site/i/794", "https://serfclick.net/i/277142", "https://faucetcrypto.com/r/1373767",
            "https://earnbitmoon.club/?ref=1075373", "https://viefaucet.com?r=6383ddeaec6d7776fc69e555", "https://simplebits.io/ref/OLkiv6stfLj_",
            "https://tap-coin.de/refer/user/4365", "https://btcadspace.com/ref/p4ch3c0", "https://trustdice.win/faucet/?ref=u_mapachox101",
            "http://cointiply.com/r/4yDJAp", "https://autofaucet.dutchycorp.space/?r=sakreto", "https://freebitco.in/?r=49843181",
            "https://faucetpay.io/?r=2136351", "https://r.honeygain.me/MERAM588A9", "https://pawns.app/?r=585883",
            "https://teaserfast.ru/u/mapachox", "https://addon.money/p/343495", "https://everve.net/ref/961754/",
            "https://swashapp.io/download?referral_code=3opl7k4ztf53", "https://addslice.com/?crew=JHVJ6", "https://earnapp.com/i/4zbftm2",
            "https://node.optimai.network/register?ref=F471454F", "https://dashboard.teneo.pro/auth/signup?referralCode=ERPr2", "https://app.nodepay.ai/register?ref=kOYHwfDuFNSSZg2",
            "https://www.jumptask.io/r/budapygirazu", "https://payeer.com/?partner=23994523", "https://rollercoin.com/?r=m9dnpgsp",
            "https://bux.money/u/239006", "https://www.swagbucks.com/p/register?rb=119244201&rp=1", "https://app.getgrass.io/register?referralCode=SwWRadefuICY8DI",
            "https://freecash.com/r/116249823271721789104", "https://r.honeygain.me/AIRRIFADB7", "https://www.binance.com/referral/earn-together/refertoearn2000usdc/claim?hl=en&ref=GRO_14352_ZBFKF",
            "https://www.paidwork.com/?r=meramente42", "https://www.bybit.com/invite?ref=VWN6NL", "https://app-earnings-link.com/givvyMusic/hoty216dfkvisgv",
            "https://swcapp.com/i/davehz", "https://app-earnings-link.com/givvyStream/a6dd8fsmn6t6qhfjjw5", "https://app-earnings-link.com/givvyScratchCardNew/euz9t4x3bmk6"
        ];

        // Mapeo de dominios a nombres de archivo de logos
        const domainToLogoMap = {
            'ipweb': 'ipweb-logo.png',
            'ipgold': 'ipgold-logo.png',
            'surfe': 'surfe-logo.png',
            'sproutgigs': 'sproutgigs-logo.png',
            'adbtc': 'adbtc-logo.png',
            'coinpayu': 'coinpayu-logo.png',
            'surfio': 'surfio-logo.png',
            'serfclick': 'serfclick-logo.png',
            'faucetcrypto': 'faucetcrypto-logo.png',
            'earnbitmoon': 'earnbitmoon-logo.png',
            'viefaucet': 'viefaucet-logo.png',
            'simplebits': 'simplebits-logo.png',
            'tap-coin': 'tapcoin-logo.png',
            'btcadspace': 'btcadspace-logo.png',
            'trustdice': 'trustdice-logo.png',
            'cointiply': 'cointiply-logo.png',
            'autofaucet': 'autofaucet-logo.png',
            'freebitco': 'freebitcoin-logo.png',
            'faucetpay': 'faucetpay-logo.png',
            'honeygain': 'honeygain-logo.png',
            'pawns': 'pawns-logo.png',
            'teaserfast': 'teaserfast-logo.png',
            'addon': 'addonmoney-logo.png',
            'everve': 'everve-logo.png',
            'swashapp': 'swash-logo.png',
            'addslice': 'addslice-logo.png',
            'earnapp': 'earnapp-logo.png',
            'optimai': 'optimai-logo.png',
            'teneo': 'teneo-logo.png',
            'nodepay': 'nodepay-logo.png',
            'jumptask': 'jumptask-logo.png',
            'payeer': 'payeer-logo.png',
            'rollercoin': 'rollercoin-logo.png',
            'bux': 'buxmoney-logo.png',
            'swagbucks': 'swagbucks-logo.png',
            'grass': 'grass-logo.png',
            'getgrass': 'grass-logo.png', // Agregar alias para app.getgrass.io
            'freecash': 'freecash-logo.png',
            'binance': 'binance-logo.png',
            'paidwork': 'paidwork-logo.png',
            'bybit': 'bybit-logo.png',
            'givvyMusic': 'givvymusic-logo.png',
            'givvyStream': 'givvystream-logo.png',
            'givvyScratchCardNew': 'givvystream-logo.png', // Usar givvystream como fallback
            'swcapp': 'swcapp-logo.png',
            'app-earnings-link': 'givvystream-logo.png' // Agregar alias para app-earnings-link.com
        };

        // Duplicar los enlaces 5 veces para asegurar que hay suficientes para todos los pisos
        const storeLinks = [];
        for (let i = 0; i < 5; i++) {
            storeLinks.push(...originalStoreLinks);
        }

        // --- Constantes y Configuración Global ---
        const HALL_SIZE = 90; // Aumentado 1.5 veces (60 * 1.5 = 90)
        const HALL_HEIGHT = 4;
        const MOVE_SPEED = 0.8;
        const ROTATE_SPEED = 0.1;
        const CAMERA_HEIGHT = 1.6;
        const MAX_FLOOR = 1; // Cambiado de 4 a 1 (solo 2 pisos: planta baja + 1 piso superior)
        const MIN_FLOOR = 0;

        // --- Variables de la Escena ---
        let scene, camera, renderer;
        const clickableObjects = [];
        const collisionObjects = [];
        const keys = { W: false, S: false, A: false, D: false, ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        
        // --- Variables para Avatares de Usuarios ---
        const userAvatars = new Map(); // Mapa de alias -> avatar
        const avatarColors = [
            0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFFEAA7,
            0xDDA0DD, 0x98D8C8, 0xF7DC6F, 0xBB8FCE, 0x85C1E9,
            0xF8C471, 0x82E0AA, 0xF1948A, 0x85C1E9, 0xD7BDE2,
            0xF9E79F, 0xABEBC6, 0xFAD7A0, 0xAED6F1, 0xF5B7B1
        ];

        // --- Variables de personalización de avatar ---
        const customizationColors = [
            // Colores vibrantes para camisas
            0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFFEAA7, 0xDDA0DD,
            0x98D8C8, 0xF7DC6F, 0xBB8FCE, 0x85C1E9, 0xF8C471, 0x82E0AA,
            0xF1948A, 0xD7BDE2, 0xF9E79F, 0xABEBC6, 0xFAD7A0, 0xAED6F1,
            // Colores más oscuros para pantalones
            0x2C3E50, 0x34495E, 0x8B4513, 0x654321, 0x2F4F4F, 0x696969,
            0x556B2F, 0x8B0000, 0x4B0082, 0x191970, 0x006400, 0x8B4513,
            0x654321, 0x2F4F4F, 0x696969, 0x556B2F, 0x8B0000, 0x4B0082,
            // Colores para zapatos
            0x8B4513, 0x654321, 0x000000, 0x2F4F4F, 0x696969, 0x8B0000,
            0x4B0082, 0x191970, 0x006400, 0x8B4513, 0x654321, 0x2F4F4F,
            0x696969, 0x556B2F, 0x8B0000, 0x4B0082, 0x191970, 0x006400
        ];
        
        let currentCustomization = {
            shirtColor: 0x4ECDC4, // Color por defecto
            pantsColor: 0x2C3E50, // Color por defecto
            shoesColor: 0x8B4513  // Color por defecto
        };
        
        let customizationPanelOpen = false;

        // --- Variables de Interacción y Movimiento ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let targetPosition;
        let targetRotationY;
        let currentFloor = 0;
        let keyA = false;
        let keyD = false;
        let keyW = false;
        let keyS = false;
        let shopNumberCounter = 1; // Contador global para numerar las tiendas

        // Función para obtener el siguiente número de tienda solo cuando se crea una
        const getNextShopNumber = () => {
            return shopNumberCounter++;
        };

        // --- Variables de rendimiento ---
        let lastTime = 0;
        let frameCount = 0;
        let fps = 60;
        const targetFPS = 60;
        const frameInterval = 1000 / targetFPS;
        let lastSkyUpdate = 0; // Para actualizar el cielo cada minuto

        // --- Cache de materiales para reutilización ---
        const materialCache = new Map();
        const textureCache = new Map();

        function getCachedMaterial(color, roughness = 0.8, metalness = 0.2) {
            const key = `${color}-${roughness}-${metalness}`;
            if (!materialCache.has(key)) {
                materialCache.set(key, new THREE.MeshStandardMaterial({ 
                    color, 
                    roughness, 
                    metalness 
                }));
            }
            return materialCache.get(key);
        }

        function getCachedTexture(text, colorIdx, width, height) {
            const key = `${text}-${colorIdx}-${width}-${height}`;
            if (!textureCache.has(key)) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const canvasW = Math.min(512, width * 64); // Reducir tamaño del canvas
                const canvasH = Math.min(512, height * 64);
                canvas.width = canvasW;
                canvas.height = canvasH;
                
                context.fillStyle = `hsl(${colorIdx * 47 % 360}, 60%, 50%)`;
                context.fillRect(0, 0, canvasW, canvasH);
                
                context.font = `bold ${canvasH * 0.3}px Arial`;
                context.fillStyle = 'white';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text.charAt(0).toUpperCase() + text.slice(1), canvasW / 2, canvasH / 2);

                const texture = new THREE.CanvasTexture(canvas);
                textureCache.set(key, texture);
            }
            return textureCache.get(key);
        }

        // --- Función para obtener el color del cielo según la hora ---
        function getSkyColor() {
            const now = new Date();
            const hour = now.getHours();
            
            // Transiciones suaves entre colores según la hora
            if (hour >= 6 && hour < 12) {
                // Mañana: azul claro
                return new THREE.Color(0x87CEEB); // Sky blue
            } else if (hour >= 12 && hour < 18) {
                // Tarde: azul más intenso
                return new THREE.Color(0x4682B4); // Steel blue
            } else if (hour >= 18 && hour < 20) {
                // Atardecer: naranja/rosa
                return new THREE.Color(0xFF7F50); // Coral
            } else if (hour >= 20 && hour < 22) {
                // Anochecer: azul oscuro
                return new THREE.Color(0x191970); // Midnight blue
            } else {
                // Noche: negro
                return new THREE.Color(0x000000); // Black
            }
        }

        function init() {
            // --- Configuración de la Escena, Cámara y Renderer ---
            setupScene();
            setupLighting();
            createMall();

            // --- Event Listeners ---
            setupEventListeners();
            
            // --- Configurar botones de UI ---
            setupUIButtons();

            // --- Iniciar Animación ---
            animate();
        }

        function setupScene() {
            scene = new THREE.Scene();
            scene.background = getSkyColor(); // Color dinámico del cielo
            scene.fog = new THREE.Fog(0x1a1a1a, 15, 105); // Ajustado para el nuevo tamaño

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(25, CAMERA_HEIGHT, 25); // Posición más cerca del centro
            camera.lookAt(HALL_SIZE / 2, CAMERA_HEIGHT, HALL_SIZE / 2);

            targetPosition = camera.position.clone();
            targetRotationY = camera.rotation.y;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limitar pixel ratio
            renderer.shadowMap.enabled = false; // Desactivar sombras completamente
            renderer.domElement.style.zIndex = '1'; // Asegurar que el canvas esté por debajo de la UI
            document.body.appendChild(renderer.domElement);
        }

        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // Aumentar intensidad para compensar falta de sombras
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); // Reducir intensidad
            directionalLight.position.set(30, 45, 15); // Ajustado para el nuevo tamaño
            directionalLight.castShadow = false; // Desactivar sombras
            scene.add(directionalLight);
        }

        function createMall() {
            // --- Materiales ---
            const floorMaterial = getCachedMaterial(0x444444, 0.8, 0.2);
            const wallMaterial = getCachedMaterial(0x6B8E23, 0.9); // Verde oliva
            const separatorMaterial = getCachedMaterial(0xFFFFFF, 0.9); // Blanco para muros separadores

            // --- Creación del Centro Comercial ---
            let linkIndex = 0;
            
            // Planta baja con tiendas
            linkIndex = createFloorLevel(0, floorMaterial, wallMaterial, separatorMaterial, linkIndex);
            
            // Solo un piso superior con tiendas y pasillos (piso 1)
            const floorY = 1 * (HALL_HEIGHT + 1);
            linkIndex = createUpperFloorLevel(floorY, floorMaterial, wallMaterial, separatorMaterial, linkIndex);

            // --- Estructura Central completa ---
            const centralStructureY = 0;
            const cubeSize = 6;
            createCentralCubeScreens(HALL_SIZE / 2, centralStructureY, HALL_SIZE / 2, cubeSize, storeLinks.slice(0, 4), 0, 2500);
            createCentralCubeScreens(HALL_SIZE / 2, centralStructureY + cubeSize * 0.8, HALL_SIZE / 2, cubeSize, storeLinks.slice(4, 8), 100, 2000);
            createCentralCubeScreens(HALL_SIZE / 2, centralStructureY + cubeSize * 1.6, HALL_SIZE / 2, cubeSize, storeLinks.slice(8, 12), 200, 1800);
            const clockCubeY = centralStructureY + cubeSize * 2.4;
            createDigitalClockCube(HALL_SIZE / 2, clockCubeY, HALL_SIZE / 2, cubeSize);

            // Cúpula
            const pyramidHeight = cubeSize * 1.5;
            const pyramidGeometry = new THREE.ConeGeometry(cubeSize / Math.SQRT2 * 1.2, pyramidHeight, 4);
            const pyramidMaterial = getCachedMaterial(0xA0522D, 0.8, 0.1); // Sienna
            const pyramid = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
            pyramid.position.set(HALL_SIZE / 2, clockCubeY + cubeSize * 0.8 + pyramidHeight / 2, HALL_SIZE / 2);
            pyramid.rotation.y = Math.PI / 4;
            // pyramid.castShadow = false; // Desactivar sombras para mejor rendimiento
            // pyramid.receiveShadow = true;
            scene.add(pyramid);

            // Crear área de descanso completa (restaurar 8 mesas)
            const gardenRadius = 8;
            const tableCount = 8; // Restaurar 8 mesas
            
            for (let i = 0; i < tableCount; i++) {
                const angle = (i / tableCount) * Math.PI * 2;
                const radius = gardenRadius + Math.random() * 2 - 1; // Variación en el radio
                
                // Crear mesa
                const tableTopGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.1, 8);
                const tableTopMaterial = getCachedMaterial(new THREE.Color().setHSL(0.1, 0.3, 0.7));
                const tableTop = new THREE.Mesh(tableTopGeometry, tableTopMaterial);
                
                // Patas de la mesa
                const tableLegGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.7, 6);
                const tableLegMaterial = getCachedMaterial(new THREE.Color().setHSL(0.05, 0.2, 0.5));
                
                // Posicionar mesa
                const tableX = HALL_SIZE / 2 + Math.cos(angle) * radius;
                const tableZ = HALL_SIZE / 2 + Math.sin(angle) * radius;
                
                tableTop.position.set(tableX, 0.85, tableZ);
                // tableTop.castShadow = false; // Desactivar sombras para mejor rendimiento
                // tableTop.receiveShadow = true;
                scene.add(tableTop);
                
                // Agregar 4 patas a la mesa
                for (let j = 0; j < 4; j++) {
                    const legAngle = (j / 4) * Math.PI * 2;
                    const legRadius = 0.6;
                    const leg = new THREE.Mesh(tableLegGeometry, tableLegMaterial);
                    leg.position.set(
                        tableX + Math.cos(legAngle) * legRadius,
                        0.35,
                        tableZ + Math.sin(legAngle) * legRadius
                    );
                    // leg.castShadow = false; // Desactivar sombras para mejor rendimiento
                    // leg.receiveShadow = true;
                    scene.add(leg);
                }
                
                // Crear parasol sobre la mesa
                const parasolPoleGeometry = new THREE.CylinderGeometry(0.03, 0.03, 2.5, 6);
                const parasolPoleMaterial = getCachedMaterial(new THREE.Color().setHSL(0.05, 0.2, 0.5));
                const parasolPole = new THREE.Mesh(parasolPoleGeometry, parasolPoleMaterial);
                parasolPole.position.set(tableX, 2.1, tableZ);
                // parasolPole.castShadow = false; // Desactivar sombras para mejor rendimiento
                // parasolPole.receiveShadow = true;
                scene.add(parasolPole);
                
                // Tela del parasol
                const parasolGeometry = new THREE.ConeGeometry(1.2, 0.3, 8);
                const parasolMaterial = getCachedMaterial(0x000080); // Azul oscuro
                const parasol = new THREE.Mesh(parasolGeometry, parasolMaterial);
                parasol.position.set(tableX, 3.25, tableZ);
                parasol.rotation.x = 0; // Quitar la rotación para que apunte hacia arriba (invertido)
                // parasol.castShadow = false; // Desactivar sombras para mejor rendimiento
                // parasol.receiveShadow = true;
                scene.add(parasol);
                
                // Crear sillas completas (restaurar 4 sillas por mesa)
                const chairCount = 4; // Restaurar 4 sillas
                for (let k = 0; k < chairCount; k++) {
                    // Posicionar sillas en los 4 puntos cardinales alrededor de la mesa
                    const chairAngle = (k / chairCount) * Math.PI * 2; // 0°, 90°, 180°, 270°
                    const chairRadius = 1.8; // Distancia fija desde la mesa
                    
                    // Asiento de la silla
                    const seatGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.4);
                    const seatMaterial = getCachedMaterial(new THREE.Color().setHSL(0.08, 0.4, 0.6));
                    const seat = new THREE.Mesh(seatGeometry, seatMaterial);
                    
                    const chairX = tableX + Math.cos(chairAngle) * chairRadius;
                    const chairZ = tableZ + Math.sin(chairAngle) * chairRadius;
                    
                    seat.position.set(chairX, 0.45, chairZ);
                    // seat.castShadow = false; // Desactivar sombras para mejor rendimiento
                    // seat.receiveShadow = true;
                    scene.add(seat);
                    

                    
                    // Patas de la silla
                    for (let l = 0; l < 4; l++) {
                        const chairLegGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.45, 6);
                        const chairLegMaterial = getCachedMaterial(new THREE.Color().setHSL(0.05, 0.2, 0.5));
                        const chairLeg = new THREE.Mesh(chairLegGeometry, chairLegMaterial);
                        
                        const legOffsetX = (l % 2 === 0 ? -1 : 1) * 0.15;
                        const legOffsetZ = (l < 2 ? -1 : 1) * 0.15;
                        
                        chairLeg.position.set(chairX + legOffsetX, 0.225, chairZ + legOffsetZ);
                        // chairLeg.castShadow = false; // Desactivar sombras para mejor rendimiento
                        // chairLeg.receiveShadow = true;
                        scene.add(chairLeg);
                    }
                }
            }
        }

        function createFloorLevel(yOffset, floorMaterial, wallMaterial, separatorMaterial, startLinkIndex) {
            // --- Suelo con textura de madera realista ---
            // Crear textura de madera usando canvas
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Configuración de la textura de madera
            const boardWidth = 64; // Ancho de cada tabla de madera
            const boardHeight = 512; // Altura de cada tabla
            const numBoards = 8; // Número de tablas de madera
            
            // Color único de madera
            const woodColor = '#8B4513'; // Saddle Brown - tono uniforme
            
            // Crear patrón de tablas de madera organizadas
            for (let i = 0; i < numBoards; i++) {
                const x = i * boardWidth;
                
                // Color base de la tabla (mismo para todas)
                ctx.fillStyle = woodColor;
                ctx.fillRect(x, 0, boardWidth, boardHeight);
                
                // Agregar vetas de madera organizadas
                ctx.strokeStyle = '#654321'; // Color más oscuro para las vetas
                ctx.lineWidth = 1;
                
                // Vetas horizontales organizadas (espaciado uniforme)
                for (let v = 0; v < 20; v++) {
                    const y = v * 25 + 12; // Espaciado uniforme sin variación aleatoria
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + boardWidth, y);
                    ctx.stroke();
                }
                
                // Vetas verticales organizadas (espaciado uniforme)
                ctx.strokeStyle = '#5D4037';
                ctx.lineWidth = 0.5;
                for (let v = 0; v < 5; v++) {
                    const vx = x + v * 15 + 8; // Espaciado uniforme sin variación aleatoria
                    ctx.beginPath();
                    ctx.moveTo(vx, 0);
                    ctx.lineTo(vx, boardHeight);
                    ctx.stroke();
                }
                
                // Agregar variación sutil de color para realismo (mismo tono)
                ctx.fillStyle = 'rgba(139, 69, 19, 0.1)';
                ctx.fillRect(x, 0, boardWidth, boardHeight);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 2); // Repetir la textura para cubrir el área
            
            const woodFloorMaterial = new THREE.MeshStandardMaterial({ 
                map: texture,
                roughness: 0.7, 
                metalness: 0.0,
                bumpMap: texture,
                bumpScale: 0.1
            });
            
            // Calcular el tamaño del área central (sin tiendas ni corredores)
            const storeDepth = 12;
            const corridorWidth = 8;
            const sueloOffset = corridorWidth / 2;
            // Hacer el área central más pequeña para que se vea mejor la separación
            const areaCentralSize = HALL_SIZE - 2 * (storeDepth + sueloOffset + 4); // Agregar 4 unidades más de margen
            
            // Crear suelo de madera solo para el área central
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(areaCentralSize, areaCentralSize), woodFloorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(HALL_SIZE / 2, yOffset, HALL_SIZE / 2);
            floor.receiveShadow = true;
            scene.add(floor);
            collisionObjects.push(new THREE.Box3().setFromObject(floor));

            // --- Tiendas ---
            const storeWidth = 8; // Reducido para que las tiendas sean más estrechas
            const storeSpacing = 1.5; // Espaciado ajustado para un balance entre densidad y espacio
            const numStoresPerSide = Math.floor(HALL_SIZE / (storeWidth + storeSpacing));
            const totalStoresWidth = numStoresPerSide * storeWidth + (numStoresPerSide - 1) * storeSpacing;
            const initialOffset = (HALL_SIZE - totalStoresWidth) / 2;
            let linkIndex = startLinkIndex;

            // Función para verificar si una posición está en una esquina
            const isCornerPosition = (index, side) => {
                // Saltar solo la primera y la última tienda de cada lado
                return index === 0 || index === numStoresPerSide - 1;
            };

            // Crear tiendas en sentido horario: Norte -> Este -> Sur -> Oeste
            const createClockwiseStores = () => {
                // Norte (de izquierda a derecha)
            for (let i = 0; i < numStoresPerSide; i++) {
                    if (isCornerPosition(i, 'north')) continue;
                const x = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                const currentLinkIndex = linkIndex % storeLinks.length;
                createStore(
                    new THREE.Vector3(x, yOffset + HALL_HEIGHT / 2, storeDepth / 2), 
                    new THREE.Vector2(storeWidth, HALL_HEIGHT), 
                    0, // Rotación para mirar hacia el centro (sur)
                    currentLinkIndex, 
                    storeDepth, 
                    wallMaterial,
                    yOffset,
                    getNextShopNumber()
                );
                linkIndex++;
            }

                // Este (de arriba hacia abajo)
            for (let i = 0; i < numStoresPerSide; i++) {
                    if (isCornerPosition(i, 'east')) continue;
                    const z = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                const currentLinkIndex = linkIndex % storeLinks.length;
                createStore(
                        new THREE.Vector3(HALL_SIZE - storeDepth / 2, yOffset + HALL_HEIGHT / 2, z), 
                    new THREE.Vector2(storeWidth, HALL_HEIGHT), 
                        -Math.PI / 2, // Rotación para mirar hacia el centro (oeste)
                    currentLinkIndex, 
                    storeDepth, 
                    wallMaterial,
                        yOffset,
                        getNextShopNumber()
                );
                linkIndex++;
            }

                // Sur (de derecha a izquierda)
                for (let i = numStoresPerSide - 1; i >= 0; i--) {
                    if (isCornerPosition(i, 'south')) continue;
                    const x = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                const currentLinkIndex = linkIndex % storeLinks.length;
                createStore(
                        new THREE.Vector3(x, yOffset + HALL_HEIGHT / 2, HALL_SIZE - storeDepth / 2), 
                    new THREE.Vector2(storeWidth, HALL_HEIGHT), 
                        Math.PI, // Rotación para mirar hacia el centro (norte)
                    currentLinkIndex, 
                    storeDepth, 
                    wallMaterial,
                        yOffset,
                        getNextShopNumber()
                );
                linkIndex++;
            }

                // Oeste (de abajo hacia arriba)
                for (let i = numStoresPerSide - 1; i >= 0; i--) {
                    if (isCornerPosition(i, 'west')) continue;
                const z = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                const currentLinkIndex = linkIndex % storeLinks.length;
                createStore(
                        new THREE.Vector3(storeDepth / 2, yOffset + HALL_HEIGHT / 2, z), 
                    new THREE.Vector2(storeWidth, HALL_HEIGHT), 
                        Math.PI / 2, // Rotación para mirar hacia el centro (este)
                    currentLinkIndex, 
                    storeDepth, 
                    wallMaterial,
                        yOffset,
                        getNextShopNumber()
                );
                linkIndex++;
                }
            };

            // Crear tiendas en sentido horario
            createClockwiseStores();

            // --- Crear muros separadores entre tiendas ---
            // Norte
            for (let i = 0; i < numStoresPerSide - 1; i++) {
                const x = initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2;
                const separatorWall = new THREE.Mesh(
                    new THREE.BoxGeometry(storeSpacing, HALL_HEIGHT + 1, 0.2), 
                    separatorMaterial
                );
                separatorWall.position.set(x, yOffset + (HALL_HEIGHT + 1) / 2, storeDepth);
                scene.add(separatorWall);
                collisionObjects.push(new THREE.Box3().setFromObject(separatorWall));
            }

            // Sur
            for (let i = 0; i < numStoresPerSide - 1; i++) {
                const x = initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2;
                const separatorWall = new THREE.Mesh(
                    new THREE.BoxGeometry(storeSpacing, HALL_HEIGHT + 1, 0.2), 
                    separatorMaterial
                );
                separatorWall.position.set(x, yOffset + (HALL_HEIGHT + 1) / 2, HALL_SIZE - storeDepth);
                scene.add(separatorWall);
                collisionObjects.push(new THREE.Box3().setFromObject(separatorWall));
            }

            // Oeste
            for (let i = 0; i < numStoresPerSide - 1; i++) {
                const z = initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2;
                const separatorWall = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, HALL_HEIGHT + 1, storeSpacing), 
                    separatorMaterial
                );
                separatorWall.position.set(storeDepth, yOffset + (HALL_HEIGHT + 1) / 2, z);
                scene.add(separatorWall);
                collisionObjects.push(new THREE.Box3().setFromObject(separatorWall));
            }

            // Este
            for (let i = 0; i < numStoresPerSide - 1; i++) {
                const z = initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2;
                const separatorWall = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, HALL_HEIGHT + 1, storeSpacing), 
                    separatorMaterial
                );
                separatorWall.position.set(HALL_SIZE - storeDepth, yOffset + (HALL_HEIGHT + 1) / 2, z);
                scene.add(separatorWall);
                collisionObjects.push(new THREE.Box3().setFromObject(separatorWall));
            }

            // --- Crear pasillos en la planta baja ---
            // Usar las variables ya declaradas arriba
            const sueloLong = HALL_SIZE - 2 * (storeDepth + sueloOffset);
            const norteZ = storeDepth + sueloOffset;
            const surZ = HALL_SIZE - storeDepth - sueloOffset;
            const oesteX = storeDepth + sueloOffset;
            const esteX = HALL_SIZE - storeDepth - sueloOffset;
            
            // Material para el suelo del pasillo de la planta baja (rojo oscuro como el segundo piso)
            const pasilloMaterialPlantaBaja = new THREE.MeshStandardMaterial({ 
                color: 0x4B0000, // Color rojo oscuro igual al del segundo piso
                roughness: 0.8
            });
            
            // Función para crear suelo de pasillo de la planta baja
            const createPasilloSueloPlantaBaja = (geometry, position) => {
                const suelo = new THREE.Mesh(geometry, pasilloMaterialPlantaBaja);
                suelo.position.copy(position);
                suelo.receiveShadow = true;
                return suelo;
            };
            
            // Norte - pasillo rojo oscuro
            const nortePasillo = createPasilloSueloPlantaBaja(
                new THREE.BoxGeometry(sueloLong, 0.2, corridorWidth),
                new THREE.Vector3(HALL_SIZE / 2, yOffset - 0.1, norteZ)
            );
            scene.add(nortePasillo);
            collisionObjects.push(new THREE.Box3().setFromObject(nortePasillo));
            
            // Sur - pasillo rojo oscuro
            const surPasillo = createPasilloSueloPlantaBaja(
                new THREE.BoxGeometry(sueloLong, 0.2, corridorWidth),
                new THREE.Vector3(HALL_SIZE / 2, yOffset - 0.1, surZ)
            );
            scene.add(surPasillo);
            collisionObjects.push(new THREE.Box3().setFromObject(surPasillo));
            
            // Oeste - pasillo rojo oscuro
            const oestePasillo = createPasilloSueloPlantaBaja(
                new THREE.BoxGeometry(corridorWidth, 0.2, sueloLong),
                new THREE.Vector3(oesteX, yOffset - 0.1, HALL_SIZE / 2)
            );
            scene.add(oestePasillo);
            collisionObjects.push(new THREE.Box3().setFromObject(oestePasillo));
            
            // Este - pasillo rojo oscuro
            const estePasillo = createPasilloSueloPlantaBaja(
                new THREE.BoxGeometry(corridorWidth, 0.2, sueloLong),
                new THREE.Vector3(esteX, yOffset - 0.1, HALL_SIZE / 2)
            );
            scene.add(estePasillo);
            collisionObjects.push(new THREE.Box3().setFromObject(estePasillo));
            
            // Esquinas - pasillo rojo oscuro
            const createCornerPlantaBaja = (posX, posZ) => {
                const corner = createPasilloSueloPlantaBaja(
                    new THREE.BoxGeometry(corridorWidth, 0.2, corridorWidth),
                    new THREE.Vector3(posX, yOffset - 0.1, posZ)
                );
                scene.add(corner);
                collisionObjects.push(new THREE.Box3().setFromObject(corner));
            };
            createCornerPlantaBaja(oesteX, norteZ); // NO
            createCornerPlantaBaja(esteX, norteZ); // NE
            createCornerPlantaBaja(oesteX, surZ); // SO
            createCornerPlantaBaja(esteX, surZ); // SE

            return linkIndex;
        }

        function createUpperFloorLevel(yOffset, floorMaterial, wallMaterial, separatorMaterial, startLinkIndex) {
            const storeDepth = 12;
            const storeWidth = 8;
            const storeSpacing = 1.5;
            const corridorWidth = 8; // Aumentado para eliminar huecos en el piso
            const numStoresPerSide = Math.floor(HALL_SIZE / (storeWidth + storeSpacing));
            const totalStoresWidth = numStoresPerSide * storeWidth + (numStoresPerSide - 1) * storeSpacing;
            const initialOffset = (HALL_SIZE - totalStoresWidth) / 2;
            let linkIndex = startLinkIndex;

            // Función para verificar si una posición está en una esquina
            const isCornerPosition = (index, side) => {
                // Saltar solo la primera y la última tienda de cada lado
                return index === 0 || index === numStoresPerSide - 1;
            };

            // --- Crear pasillos con suelo ---
            // Crear materiales para cada cara
            const pasilloMaterialVinotinto = new THREE.MeshStandardMaterial({ 
                color: 0x4B0000, // Color vinotinto más oscuro
                roughness: 0.8
            });
            
            const pasilloMaterialBlanco = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF, // Color blanco
                roughness: 0.8
            });
            
            // Material original para el techo del pasillo
            const techoMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF, // Color blanco
                roughness: 0.8 
            });
            
            // El suelo empieza justo al frente de las tiendas para eliminar huecos
            const sueloOffset = corridorWidth / 2; // mitad del ancho del corredor para que empiece al frente de las tiendas
            const sueloLong = HALL_SIZE - 2 * (storeDepth + sueloOffset);
            const norteZ = storeDepth + sueloOffset;
            const surZ = HALL_SIZE - storeDepth - sueloOffset;
            const oesteX = storeDepth + sueloOffset;
            const esteX = HALL_SIZE - storeDepth - sueloOffset;
            
            // Función para crear suelo de pasillo con dos colores
            const createPasilloSuelo = (geometry, position, materialVinotinto, materialBlanco) => {
                const grupo = new THREE.Group();
                
                // Cara superior (vinotinto) - ligeramente más alta
                const caraSuperior = new THREE.Mesh(geometry, materialVinotinto);
                caraSuperior.position.set(0, 0.001, 0); // Ligeramente más alta
                grupo.add(caraSuperior);
                
                // Cara inferior (blanca) - ligeramente más baja
                const caraInferior = new THREE.Mesh(geometry, materialBlanco);
                caraInferior.position.set(0, -0.001, 0); // Ligeramente más baja
                caraInferior.rotation.x = Math.PI; // Rotar 180 grados para que mire hacia abajo
                grupo.add(caraInferior);
                
                grupo.position.copy(position);
                return grupo;
            };
            
            // Norte - vinotinto arriba, blanco abajo
            const norte = createPasilloSuelo(
                new THREE.BoxGeometry(sueloLong, 0.2, corridorWidth),
                new THREE.Vector3(HALL_SIZE / 2, yOffset - 0.1, norteZ),
                pasilloMaterialVinotinto,
                pasilloMaterialBlanco
            );
            scene.add(norte);
            collisionObjects.push(new THREE.Box3().setFromObject(norte));
            
            // Sur - vinotinto arriba, blanco abajo
            const sur = createPasilloSuelo(
                new THREE.BoxGeometry(sueloLong, 0.2, corridorWidth),
                new THREE.Vector3(HALL_SIZE / 2, yOffset - 0.1, surZ),
                pasilloMaterialVinotinto,
                pasilloMaterialBlanco
            );
            scene.add(sur);
            collisionObjects.push(new THREE.Box3().setFromObject(sur));
            
            // Oeste - vinotinto arriba, blanco abajo
            const oeste = createPasilloSuelo(
                new THREE.BoxGeometry(corridorWidth, 0.2, sueloLong),
                new THREE.Vector3(oesteX, yOffset - 0.1, HALL_SIZE / 2),
                pasilloMaterialVinotinto,
                pasilloMaterialBlanco
            );
            scene.add(oeste);
            collisionObjects.push(new THREE.Box3().setFromObject(oeste));
            
            // Este - vinotinto arriba, blanco abajo
            const este = createPasilloSuelo(
                new THREE.BoxGeometry(corridorWidth, 0.2, sueloLong),
                new THREE.Vector3(esteX, yOffset - 0.1, HALL_SIZE / 2),
                pasilloMaterialVinotinto,
                pasilloMaterialBlanco
            );
            scene.add(este);
            collisionObjects.push(new THREE.Box3().setFromObject(este));
            
            // Esquinas - vinotinto arriba, blanco abajo
            const createCorner = (posX, posZ) => {
                const corner = createPasilloSuelo(
                    new THREE.BoxGeometry(corridorWidth, 0.2, corridorWidth),
                    new THREE.Vector3(posX, yOffset - 0.1, posZ),
                    pasilloMaterialVinotinto,
                    pasilloMaterialBlanco
                );
                scene.add(corner);
                collisionObjects.push(new THREE.Box3().setFromObject(corner));
            };
            createCorner(oesteX, norteZ); // NO
            createCorner(esteX, norteZ); // NE
            createCorner(oesteX, surZ); // SO
            createCorner(esteX, surZ); // SE

            // --- Crear techos de pasillos (solo para el segundo piso) ---
            const currentFloor = Math.floor(yOffset / (HALL_HEIGHT + 1));
            if (currentFloor === 1) { // Segundo piso (piso 1, ya que empezamos desde 0)
                const ceilingHeight = 0.2;
                const extendedHeight = HALL_HEIGHT + 1;
                const ceilingY = yOffset + (extendedHeight / 2 + 2.5); // Mucho más alto que el techo de las tiendas
                const extendedCorridorWidth = corridorWidth + 4; // Reducir el sobresaliente del techo
                
                // Norte - techo gris original
                const techoNorte = new THREE.Mesh(new THREE.BoxGeometry(sueloLong, ceilingHeight, extendedCorridorWidth), techoMaterial);
                techoNorte.position.set(HALL_SIZE / 2, ceilingY, norteZ + 2); // Reducir sobresaliente hacia el centro
                // techoNorte.receiveShadow = true;
                // techoNorte.castShadow = true;
                scene.add(techoNorte);
                
                // Sur - techo gris original
                const techoSur = new THREE.Mesh(new THREE.BoxGeometry(sueloLong, ceilingHeight, extendedCorridorWidth), techoMaterial);
                techoSur.position.set(HALL_SIZE / 2, ceilingY, surZ - 2); // Reducir sobresaliente hacia el centro
                // techoSur.receiveShadow = true;
                // techoSur.castShadow = true;
                scene.add(techoSur);
                
                // Oeste - techo gris original
                const techoOeste = new THREE.Mesh(new THREE.BoxGeometry(extendedCorridorWidth, ceilingHeight, sueloLong), techoMaterial);
                techoOeste.position.set(oesteX + 2, ceilingY, HALL_SIZE / 2); // Reducir sobresaliente hacia el centro
                // techoOeste.receiveShadow = true;
                // techoOeste.castShadow = true;
                scene.add(techoOeste);
                
                // Este - techo gris original
                const techoEste = new THREE.Mesh(new THREE.BoxGeometry(extendedCorridorWidth, ceilingHeight, sueloLong), techoMaterial);
                techoEste.position.set(esteX - 2, ceilingY, HALL_SIZE / 2); // Reducir sobresaliente hacia el centro
                // techoEste.receiveShadow = true;
                // techoEste.castShadow = true;
                scene.add(techoEste);
                
                // Esquinas del techo - gris original
                const createCeilingCorner = (posX, posZ) => {
                    const techoCorner = new THREE.Mesh(new THREE.BoxGeometry(extendedCorridorWidth, ceilingHeight, extendedCorridorWidth), techoMaterial);
                    techoCorner.position.set(posX, ceilingY, posZ);
                    // techoCorner.receiveShadow = true;
                    // techoCorner.castShadow = true;
                    scene.add(techoCorner);
                };
                createCeilingCorner(oesteX + 2, norteZ + 2); // NO
                createCeilingCorner(esteX - 2, norteZ + 2); // NE
                createCeilingCorner(oesteX + 2, surZ - 2); // SO
                createCeilingCorner(esteX - 2, surZ - 2); // SE
            }

            // --- Crear techo trapezoidal sobre las tiendas del último piso ---
            // ELIMINADO: Techos trapezoidales para mejorar rendimiento
            // Ya no se necesitan porque solo tenemos 2 pisos
            /*
            if (currentFloor === 3) { // Solo para el último piso (piso 3)
                const trapezoidMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xA0522D, 
                    roughness: 0.8,
                    metalness: 0.1,
                    side: THREE.DoubleSide
                });
                
                // Crear techo trapezoidal para cada lado
                const trapezoidHeight = 6; // Más alto y más grande
                const baseWidth = storeWidth + 2; // Un poco más ancho que la tienda
                
                // Norte - techo trapezoidal
                for (let i = 0; i < numStoresPerSide; i++) {
                    const x = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                    const trapezoidGeometry = new THREE.ConeGeometry(baseWidth / 2, trapezoidHeight, 4);
                    const trapezoid = new THREE.Mesh(trapezoidGeometry, trapezoidMaterial);
                    trapezoid.position.set(x, yOffset + (HALL_HEIGHT + 1) / 2 + 3.5 + trapezoidHeight / 2, storeDepth / 2);
                    trapezoid.rotation.y = Math.PI / 4; // Rotar 45 grados
                    trapezoid.castShadow = true;
                    trapezoid.receiveShadow = true;
                    scene.add(trapezoid);
                }
                
                // Sur - techo trapezoidal
                for (let i = 0; i < numStoresPerSide; i++) {
                    const x = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                    const trapezoidGeometry = new THREE.ConeGeometry(baseWidth / 2, trapezoidHeight, 4);
                    const trapezoid = new THREE.Mesh(trapezoidGeometry, trapezoidMaterial);
                    trapezoid.position.set(x, yOffset + (HALL_HEIGHT + 1) / 2 + 3.5 + trapezoidHeight / 2, HALL_SIZE - storeDepth / 2);
                    trapezoid.rotation.y = Math.PI / 4; // Rotar 45 grados
                    trapezoid.castShadow = true;
                    trapezoid.receiveShadow = true;
                    scene.add(trapezoid);
                }
                
                // Oeste - techo trapezoidal
                for (let i = 0; i < numStoresPerSide; i++) {
                    const z = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                    const trapezoidGeometry = new THREE.ConeGeometry(baseWidth / 2, trapezoidHeight, 4);
                    const trapezoid = new THREE.Mesh(trapezoidGeometry, trapezoidMaterial);
                    trapezoid.position.set(storeDepth / 2, yOffset + (HALL_HEIGHT + 1) / 2 + 3.5 + trapezoidHeight / 2, z);
                    trapezoid.rotation.y = Math.PI / 4; // Rotar 45 grados
                    trapezoid.castShadow = true;
                    trapezoid.receiveShadow = true;
                    scene.add(trapezoid);
                }
                
                // Este - techo trapezoidal
                for (let i = 0; i < numStoresPerSide; i++) {
                    const z = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                    const trapezoidGeometry = new THREE.ConeGeometry(baseWidth / 2, trapezoidHeight, 4);
                    const trapezoid = new THREE.Mesh(trapezoidGeometry, trapezoidMaterial);
                    trapezoid.position.set(HALL_SIZE - storeDepth / 2, yOffset + (HALL_HEIGHT + 1) / 2 + 3.5 + trapezoidHeight / 2, z);
                    trapezoid.rotation.y = Math.PI / 4; // Rotar 45 grados
                    trapezoid.castShadow = true;
                    trapezoid.receiveShadow = true;
                    scene.add(trapezoid);
                }
            }
            */

            // --- Crear barandas al borde exterior de los corredores ---
            const railingHeight = 0.8;
            const railMat = new THREE.MeshStandardMaterial({ color: 0x000000, metalness: 0.5, roughness: 0.5 }); // Color negro
            const cornerGap = 2; // Espacio en las esquinas para no bloquear el paso
            const barandaLong = (sueloLong + corridorWidth - cornerGap) / 2; // Longitud de cada tramo
            const railThickness = 0.3; // Grosor de las barandas para hacerlas sólidas
            
            // Norte - dos tramos separados
            const railN1 = new THREE.Mesh(new THREE.BoxGeometry(barandaLong, railingHeight, railThickness), railMat);
            railN1.position.set(storeDepth + corridorWidth + barandaLong / 2, yOffset + railingHeight / 2 - 0.1, storeDepth + corridorWidth);
            scene.add(railN1);
            const railN2 = new THREE.Mesh(new THREE.BoxGeometry(barandaLong, railingHeight, railThickness), railMat);
            railN2.position.set(HALL_SIZE - storeDepth - corridorWidth - barandaLong / 2, yOffset + railingHeight / 2 - 0.1, storeDepth + corridorWidth);
            scene.add(railN2);
            
            // Sur - dos tramos separados
            const railS1 = new THREE.Mesh(new THREE.BoxGeometry(barandaLong, railingHeight, railThickness), railMat);
            railS1.position.set(storeDepth + corridorWidth + barandaLong / 2, yOffset + railingHeight / 2 - 0.1, HALL_SIZE - storeDepth - corridorWidth);
            scene.add(railS1);
            const railS2 = new THREE.Mesh(new THREE.BoxGeometry(barandaLong, railingHeight, railThickness), railMat);
            railS2.position.set(HALL_SIZE - storeDepth - corridorWidth - barandaLong / 2, yOffset + railingHeight / 2 - 0.1, HALL_SIZE - storeDepth - corridorWidth);
            scene.add(railS2);
            
            // Oeste - dos tramos separados
            const railO1 = new THREE.Mesh(new THREE.BoxGeometry(railThickness, railingHeight, barandaLong), railMat);
            railO1.position.set(storeDepth + corridorWidth, yOffset + railingHeight / 2 - 0.1, storeDepth + corridorWidth + barandaLong / 2);
            scene.add(railO1);
            const railO2 = new THREE.Mesh(new THREE.BoxGeometry(railThickness, railingHeight, barandaLong), railMat);
            railO2.position.set(storeDepth + corridorWidth, yOffset + railingHeight / 2 - 0.1, HALL_SIZE - storeDepth - corridorWidth - barandaLong / 2);
            scene.add(railO2);
            
            // Este - dos tramos separados
            const railE1 = new THREE.Mesh(new THREE.BoxGeometry(railThickness, railingHeight, barandaLong), railMat);
            railE1.position.set(HALL_SIZE - storeDepth - corridorWidth, yOffset + railingHeight / 2 - 0.1, storeDepth + corridorWidth + barandaLong / 2);
            scene.add(railE1);
            const railE2 = new THREE.Mesh(new THREE.BoxGeometry(railThickness, railingHeight, barandaLong), railMat);
            railE2.position.set(HALL_SIZE - storeDepth - corridorWidth, yOffset + railingHeight / 2 - 0.1, HALL_SIZE - storeDepth - corridorWidth - barandaLong / 2);
            scene.add(railE2);

            // --- Actualizar colisiones de las barandas después de agregarlas a la escena ---
            [railN1, railN2, railS1, railS2, railO1, railO2, railE1, railE2].forEach(rail => {
                rail.updateMatrixWorld(true);
                const railBox = new THREE.Box3().setFromObject(rail);
                // Expandir la caja de colisión para hacer las barandas más efectivas
                railBox.expandByScalar(0.2);
                collisionObjects.push(railBox);
            });

            // Crear tiendas en sentido horario: Norte -> Este -> Sur -> Oeste
            const createClockwiseStores = () => {
                // Norte (de izquierda a derecha)
            for (let i = 0; i < numStoresPerSide; i++) {
                    if (isCornerPosition(i, 'north')) continue;
                const x = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                const currentLinkIndex = linkIndex % storeLinks.length;
                createStore(
                    new THREE.Vector3(x, yOffset + HALL_HEIGHT / 2, storeDepth / 2), 
                    new THREE.Vector2(storeWidth, HALL_HEIGHT), 
                    0, // Mirando hacia el centro
                    currentLinkIndex, 
                    storeDepth, 
                    wallMaterial,
                        yOffset,
                        getNextShopNumber()
                );
                linkIndex++;
            }

                // Este (de arriba hacia abajo)
            for (let i = 0; i < numStoresPerSide; i++) {
                    if (isCornerPosition(i, 'east')) continue;
                    const z = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                const currentLinkIndex = linkIndex % storeLinks.length;
                createStore(
                        new THREE.Vector3(HALL_SIZE - storeDepth / 2, yOffset + HALL_HEIGHT / 2, z), 
                    new THREE.Vector2(storeWidth, HALL_HEIGHT), 
                        -Math.PI / 2, // Mirando hacia el centro
                    currentLinkIndex, 
                    storeDepth, 
                    wallMaterial,
                        yOffset,
                        getNextShopNumber()
                );
                linkIndex++;
            }

                // Sur (de derecha a izquierda)
                for (let i = numStoresPerSide - 1; i >= 0; i--) {
                    if (isCornerPosition(i, 'south')) continue;
                    const x = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                const currentLinkIndex = linkIndex % storeLinks.length;
                createStore(
                        new THREE.Vector3(x, yOffset + HALL_HEIGHT / 2, HALL_SIZE - storeDepth / 2), 
                    new THREE.Vector2(storeWidth, HALL_HEIGHT), 
                        Math.PI, // Mirando hacia el centro
                    currentLinkIndex, 
                    storeDepth, 
                    wallMaterial,
                        yOffset,
                        getNextShopNumber()
                );
                linkIndex++;
            }

                // Oeste (de abajo hacia arriba)
                for (let i = numStoresPerSide - 1; i >= 0; i--) {
                    if (isCornerPosition(i, 'west')) continue;
                const z = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                const currentLinkIndex = linkIndex % storeLinks.length;
                createStore(
                        new THREE.Vector3(storeDepth / 2, yOffset + HALL_HEIGHT / 2, z), 
                    new THREE.Vector2(storeWidth, HALL_HEIGHT), 
                        Math.PI / 2, // Mirando hacia el centro
                    currentLinkIndex, 
                    storeDepth, 
                    wallMaterial,
                        yOffset,
                        getNextShopNumber()
                );
                linkIndex++;
                }
            };

            // Crear tiendas en sentido horario
            createClockwiseStores();

            // --- Crear muros separadores entre tiendas ---
            // Norte
            for (let i = 0; i < numStoresPerSide - 1; i++) {
                const x = initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2;
                const separatorWall = new THREE.Mesh(
                    new THREE.BoxGeometry(storeSpacing, HALL_HEIGHT + 1, 0.2), 
                    separatorMaterial
                );
                separatorWall.position.set(x, yOffset + (HALL_HEIGHT + 1) / 2, storeDepth);
                scene.add(separatorWall);
                collisionObjects.push(new THREE.Box3().setFromObject(separatorWall));
            }

            // Sur
            for (let i = 0; i < numStoresPerSide - 1; i++) {
                const x = initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2;
                const separatorWall = new THREE.Mesh(
                    new THREE.BoxGeometry(storeSpacing, HALL_HEIGHT + 1, 0.2), 
                    separatorMaterial
                );
                separatorWall.position.set(x, yOffset + (HALL_HEIGHT + 1) / 2, HALL_SIZE - storeDepth);
                scene.add(separatorWall);
                collisionObjects.push(new THREE.Box3().setFromObject(separatorWall));
            }

            // Oeste
            for (let i = 0; i < numStoresPerSide - 1; i++) {
                const z = initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2;
                const separatorWall = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, HALL_HEIGHT + 1, storeSpacing), 
                    separatorMaterial
                );
                separatorWall.position.set(storeDepth, yOffset + (HALL_HEIGHT + 1) / 2, z);
                scene.add(separatorWall);
                collisionObjects.push(new THREE.Box3().setFromObject(separatorWall));
            }

            // Este
            for (let i = 0; i < numStoresPerSide - 1; i++) {
                const z = initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2;
                const separatorWall = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, HALL_HEIGHT + 1, storeSpacing), 
                    separatorMaterial
                );
                separatorWall.position.set(HALL_SIZE - storeDepth, yOffset + (HALL_HEIGHT + 1) / 2, z);
                scene.add(separatorWall);
                collisionObjects.push(new THREE.Box3().setFromObject(separatorWall));
            }

            return linkIndex;
        }

        function createStore(position, size, rotationY, linkIdx, depth, wallMaterial, floorY, shopNumber) {
            const storeGroup = new THREE.Group();
            storeGroup.position.copy(position);
            storeGroup.rotation.y = rotationY;
            const wallThickness = 0.2;

            // Determinar el piso actual una sola vez
            const currentFloor = Math.floor(floorY / (HALL_HEIGHT + 1));

            // --- Crear material de pared con el color de la pancarta ---
            const url = storeLinks[linkIdx];
            const domain = new URL(url).hostname.replace('www.', '').split('.')[0];
            const storeColor = new THREE.Color().setHSL((linkIdx * 47) % 360 / 360, 0.6, 0.5); // Mismo color que la pancarta
            const storeWallMaterial = new THREE.MeshStandardMaterial({ 
                color: storeColor,
                roughness: 0.9
            });

            // --- Suelo de la tienda con dos colores ---
            // Crear materiales para cada cara
            const storeFloorMaterialNegro = new THREE.MeshStandardMaterial({ 
                color: 0x000000, // Color negro
                roughness: 0.8
            });
            
            const storeFloorMaterialBlanco = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF, // Color blanco
                roughness: 0.8
            });
            
            // Función para crear suelo de tienda con dos colores
            const createStoreFloor = (geometry, position) => {
                const grupo = new THREE.Group();
                
                // Cara superior (negra) - ligeramente más alta
                const caraSuperior = new THREE.Mesh(geometry, storeFloorMaterialNegro);
                caraSuperior.position.set(0, 0.001, 0); // Ligeramente más alta
                grupo.add(caraSuperior);
                
                // Cara inferior (blanca) - ligeramente más baja
                const caraInferior = new THREE.Mesh(geometry, storeFloorMaterialBlanco);
                caraInferior.position.set(0, -0.001, 0); // Ligeramente más baja
                caraInferior.rotation.x = Math.PI; // Rotar 180 grados para que mire hacia abajo
                grupo.add(caraInferior);
                
                grupo.position.copy(position);
                grupo.rotation.x = -Math.PI / 2;
                return grupo;
            };
            
            // Crear suelo de tienda con negro arriba y blanco abajo
            const storeFloor = createStoreFloor(new THREE.PlaneGeometry(size.x, depth), new THREE.Vector3(0, 0, 0));
            
            // Ajustar la posición del suelo según el piso
            if (currentFloor === 1) {
                // Para el segundo piso, subir ligeramente el suelo
                const floorOffset = -0.05 - HALL_HEIGHT / 2; // Reducido de -0.1 a -0.05
                storeFloor.position.set(0, floorOffset, 0);
            } else {
                // Para la planta baja, mantener la posición original
                storeFloor.position.set(0, -size.y / 2 + 0.05, 0);
            }
            
            // storeFloor.receiveShadow = true;
            // storeFloor.castShadow = false; // Desactivar sombras para mejor rendimiento
            storeGroup.add(storeFloor);

            // --- Paredes (extendidas hasta el siguiente piso) ---
            const extendedHeight = HALL_HEIGHT + 1; // Extender hasta el siguiente piso
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(size.x, extendedHeight, wallThickness), storeWallMaterial);
            backWall.position.z = -depth / 2;
            backWall.position.y = (extendedHeight - size.y) / 2; // Centrar en la nueva altura
            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(depth, extendedHeight, wallThickness), storeWallMaterial);
            leftWall.position.set(-size.x / 2, (extendedHeight - size.y) / 2, 0);
            leftWall.rotation.y = Math.PI / 2;
            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(depth, extendedHeight, wallThickness), storeWallMaterial);
            rightWall.position.set(size.x / 2, (extendedHeight - size.y) / 2, 0);
            rightWall.rotation.y = -Math.PI / 2;
            [backWall, leftWall, rightWall].forEach(wall => {
                // wall.castShadow = false; // Desactivar sombras para mejor rendimiento
                // wall.receiveShadow = true;
                storeGroup.add(wall);
            });

            // --- Techo (para el segundo piso) ---
            if (currentFloor === 1) { // Segundo piso (piso 1, ya que empezamos desde 0)
                const ceilingMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF, // Color blanco
                    roughness: 0.8,
                    side: THREE.DoubleSide
                });
                const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(size.x, depth), ceilingMaterial);
                ceiling.rotation.x = Math.PI / 2;
                ceiling.position.set(0, extendedHeight / 2 + 0.5, 0); // Posicionar más alto que las paredes extendidas
                // ceiling.receiveShadow = true;
                // ceiling.castShadow = false; // Desactivar sombras para mejor rendimiento
                storeGroup.add(ceiling);
            }
            
            // --- Cartel principal ---
            const mainSign = createImagePlane(url, domain, size.x * 0.9, size.y * 0.8, linkIdx, true);
            mainSign.position.z = -depth / 2 + wallThickness + 0.01;
            mainSign.position.y = (extendedHeight - size.y) / 2; // Ajustar posición vertical
            storeGroup.add(mainSign);

            // --- Número de tienda ---
            const shopNumberSign = createShopNumberSign(shopNumber, size.x * 0.25, size.y * 0.25);
            shopNumberSign.position.z = -depth / 2 + wallThickness + 0.02;
            shopNumberSign.position.y = (extendedHeight - size.y) / 2 + size.y * 0.4; // Posicionar más abajo
            shopNumberSign.position.x = 0; // Centrar horizontalmente
            storeGroup.add(shopNumberSign);

            // --- Carteles laterales (restaurar ambos carteles) ---
            const sideSignTexts = [ `Ofertas en ${domain}`, `Visítanos ahora`, `Clic para ganar`, `Novedades aquí`];
            const leftSign = createRotatingSign(url, sideSignTexts, 2.5, size.y * 0.6, linkIdx);
            leftSign.position.set(-size.x / 2 + wallThickness + 0.01, (extendedHeight - size.y) / 2, -2);
            leftSign.rotation.y = Math.PI / 2;

            const rightSign = createRotatingSign(url, sideSignTexts.slice(2).concat(sideSignTexts.slice(0,2)), 2.5, size.y * 0.6, linkIdx + 1);
            rightSign.position.set(size.x / 2 - wallThickness - 0.01, (extendedHeight - size.y) / 2, -2);
            rightSign.rotation.y = -Math.PI / 2;
            
            storeGroup.add(leftSign, rightSign);

            // --- Letreros verticales completos para los pasillos ---
            const createVerticalSign = (text, width, height, colorIdx) => {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const canvasW = 256; // Restaurar tamaño original
                const canvasH = 512; // Más alto para texto vertical
                canvas.width = canvasW;
                canvas.height = canvasH;
                
                // Fondo con el mismo color que el cartel principal
                context.fillStyle = `hsl(${colorIdx * 47 % 360}, 60%, 50%)`;
                context.fillRect(0, 0, canvasW, canvasH);
                context.strokeStyle = '#FFFFFF';
                context.lineWidth = 4; // Restaurar grosor original
                context.strokeRect(2, 2, canvasW - 4, canvasH - 4);
                
                // Texto vertical en blanco
                context.fillStyle = '#FFFFFF';
                context.font = `bold ${canvasW * 0.25}px Arial`; // Restaurar tamaño de fuente original
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                
                // Dividir el texto en caracteres y dibujarlos verticalmente de arriba hacia abajo
                const chars = text.split('');
                const charHeight = canvasH * 0.12; // Más espacio entre letras
                const totalHeight = chars.length * charHeight;
                const startY = canvasH / 2 - totalHeight / 2;
                const centerX = canvasW / 2;
                
                chars.forEach((char, index) => {
                    context.fillText(char, centerX, startY + index * charHeight);
                });
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshStandardMaterial({ 
                    map: texture,
                    transparent: true,
                    alphaTest: 0.1
                });
                
                const plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), material);
                return plane;
            };

            // Crear letreros verticales en los bordes de los pasillos (restaurar ambos)
            const verticalSignWidth = 0.8; // Restaurar tamaño original
            const verticalSignHeight = extendedHeight; // Restaurar altura original
            
            // Letrero en el extremo izquierdo del muro (hacia el pasillo)
            const leftVerticalSign = createVerticalSign(domain.toUpperCase(), verticalSignWidth, verticalSignHeight, linkIdx);
            leftVerticalSign.position.set(-size.x / 2 + wallThickness + 0.02, (extendedHeight - size.y) / 2, depth / 2 - 1);
            leftVerticalSign.rotation.y = Math.PI / 2;
            storeGroup.add(leftVerticalSign);
            
            // Número de tienda en el extremo izquierdo del muro
            const leftNumberSign = createShopNumberSign(shopNumber, 0.8, 0.8);
            leftNumberSign.position.set(-size.x / 2 + wallThickness + 0.02, (extendedHeight - size.y) / 2 + 1.5, depth / 2 - 0.2);
            leftNumberSign.rotation.y = Math.PI / 2;
            storeGroup.add(leftNumberSign);
            
            // Letrero en el extremo derecho del muro (hacia el pasillo)
            const rightVerticalSign = createVerticalSign(domain.toUpperCase(), verticalSignWidth, verticalSignHeight, linkIdx);
            rightVerticalSign.position.set(size.x / 2 - wallThickness - 0.02, (extendedHeight - size.y) / 2, depth / 2 - 1);
            rightVerticalSign.rotation.y = -Math.PI / 2;
            storeGroup.add(rightVerticalSign);
            
            // Número de tienda en el extremo derecho del muro
            const rightNumberSign = createShopNumberSign(shopNumber, 0.8, 0.8);
            rightNumberSign.position.set(size.x / 2 - wallThickness - 0.02, (extendedHeight - size.y) / 2 + 1.5, depth / 2 - 0.2);
            rightNumberSign.rotation.y = -Math.PI / 2;
            storeGroup.add(rightNumberSign);

            scene.add(storeGroup);

            // --- Actualizar colisiones ---
            storeGroup.updateMatrixWorld(true);
            [backWall, leftWall, rightWall].forEach(wall => {
                collisionObjects.push(new THREE.Box3().setFromObject(wall));
            });
        }

        function createCentralCubeScreens(x, y, z, size, links, colorOffset, interval) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            const planes = [];

            const cubeGeom = new THREE.BoxGeometry(size, size * 0.6, size);
            const cubeMat = new THREE.MeshStandardMaterial({ color: 0x222, metalness: 0.3, roughness: 0.7 });
            const cube = new THREE.Mesh(cubeGeom, cubeMat);
            cube.position.y = size * 0.3;
            group.add(cube);
            
            for (let i = 0; i < 4; i++) {
                if (i >= links.length) continue;
                const angle = i * Math.PI / 2;
                const url = links[i];
                const domain = new URL(url).hostname.replace('www.', '').split('.')[0];
                const plane = createImagePlane(url, domain, size, size * 0.6, colorOffset + i, true);
                plane.position.set(Math.sin(angle) * (size / 2 + 0.01), size * 0.3, Math.cos(angle) * (size / 2 + 0.01));
                plane.rotation.y = angle;
                group.add(plane);
                planes.push(plane);
            }
            scene.add(group);
            group.updateMatrixWorld(true);
            collisionObjects.push(new THREE.Box3().setFromObject(cube));

            let offset = 0;
            setInterval(() => {
                planes.forEach((plane, i) => {
                    const linkIdx = (offset + i) % links.length;
                    const url = links[linkIdx];
                    const domain = new URL(url).hostname.replace('www.', '').split('.')[0];
                    plane.userData.URL = url;
                    updateImagePlane(plane, url, domain, colorOffset + linkIdx, true);
                });
                offset = (offset + 1) % links.length;
            }, interval);
        }

        function createImagePlane(url, text, width, height, colorIdx, solid) {
            const plane = new THREE.Mesh(
                new THREE.PlaneGeometry(width, height),
                new THREE.MeshStandardMaterial({ roughness: 0.7, metalness: 0.2, transparent: !solid })
            );
            plane.userData.URL = url;
            updateImagePlane(plane, url, text, colorIdx, solid);
            clickableObjects.push(plane);
            return plane;
        }

        // Cache para texturas de logos
        const logoTextureCache = new Map();
        
        function getLogoTexture(domain) {
            const logoFileName = domainToLogoMap[domain];
            if (!logoFileName) {
                return null;
            }
            
            // Verificar si ya está en cache
            if (logoTextureCache.has(domain)) {
                return logoTextureCache.get(domain);
            }
            
            try {
                const textureLoader = new THREE.TextureLoader();
                const texture = textureLoader.load(
                    `assets/images/${logoFileName}`,
                    // onLoad callback
                    function(loadedTexture) {
                        console.log(`Logo cargado exitosamente: ${logoFileName}`);
                    },
                    // onProgress callback
                    function(xhr) {
                        // Silenciar progreso para evitar spam
                    },
                    // onError callback
                    function(error) {
                        console.error(`Error cargando logo ${logoFileName}:`, error);
                        // Remover del cache si falla
                        logoTextureCache.delete(domain);
                    }
                );
                
                // Guardar en cache
                logoTextureCache.set(domain, texture);
                return texture;
            } catch (error) {
                console.error(`Error creando textura para ${domain}:`, error);
                return null;
            }
        }

        function createShopNumberSign(number, width, height) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const canvasW = 256;
            const canvasH = 256;
            canvas.width = canvasW;
            canvas.height = canvasH;
            
            // Fondo circular negro
            context.fillStyle = '#000000';
            context.beginPath();
            context.arc(canvasW / 2, canvasH / 2, canvasW / 2 - 10, 0, 2 * Math.PI);
            context.fill();
            
            // Borde blanco
            context.strokeStyle = '#FFFFFF';
            context.lineWidth = 8;
            context.stroke();
            
            // Número en blanco
            context.fillStyle = '#FFFFFF';
            context.font = `bold ${canvasH * 0.6}px Arial`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(number.toString(), canvasW / 2, canvasH / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshStandardMaterial({ 
                map: texture,
                transparent: true,
                alphaTest: 0.1
            });
            
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), material);
            return plane;
        }

        function updateImagePlane(plane, url, text, colorIdx) {
            try {
                let domain = new URL(url).hostname.replace('www.', '');
                // Extraer el dominio principal (sin subdominios)
                const domainParts = domain.split('.');
                if (domainParts.length > 2) {
                    domain = domainParts[1];
                } else {
                    domain = domainParts[0];
                }
                
                const logoTexture = getLogoTexture(domain);
                
                if (plane.material.map) {
                    plane.material.map.dispose();
                }
                
                if (logoTexture) {
                    plane.material.map = logoTexture;
                } else {
                    // Fallback a la textura generada si no hay logo
                    const texture = getCachedTexture(text, colorIdx, plane.geometry.parameters.width, plane.geometry.parameters.height);
            plane.material.map = texture;
                }
                
            plane.material.needsUpdate = true;
            } catch (error) {
                console.error('Error en updateImagePlane:', error);
                // Fallback seguro
                if (plane.material.map) {
                    plane.material.map.dispose();
                }
                const texture = getCachedTexture(text, colorIdx, plane.geometry.parameters.width, plane.geometry.parameters.height);
                plane.material.map = texture;
                plane.material.needsUpdate = true;
            }
        }

        function createRotatingSign(url, texts, width, height, colorIdx) {
            const plane = createImagePlane(url, texts[0], width, height, colorIdx, false);
            plane.material.transparent = true;
            let textIndex = 0;
            setInterval(() => {
                textIndex = (textIndex + 1) % texts.length;
                updateRotatingSign(plane.material, texts[textIndex]);
            }, 2500);
            return plane;
        }

        function updateRotatingSign(material, text) {
            // Create a new canvas if material.map doesn't exist or if it's not a canvas
            let canvas = material.map ? material.map.image : null;
            if (!canvas || !canvas.getContext) {
                canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 128;
            }
            
            const context = canvas.getContext('2d');
            const canvasW = canvas.width;
            const canvasH = canvas.height;
            
            context.fillStyle = '#fff';
            context.fillRect(0, 0, canvasW, canvasH);
            context.strokeStyle = '#000';
            context.lineWidth = 8;
            context.strokeRect(4, 4, canvasW-8, canvasH-8);

            let fontSize = canvasH * 0.3;
            context.font = `bold ${fontSize}px Arial`;
            context.fillStyle = '#000';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            while(context.measureText(text).width > canvasW - 20 && fontSize > 10) {
                fontSize -= 2;
                context.font = `bold ${fontSize}px Arial`;
            }
            context.fillText(text, canvasW/2, canvasH/2);
            
            // Create or update the texture
            if (!material.map) {
                material.map = new THREE.CanvasTexture(canvas);
            } else {
                material.map.needsUpdate = true;
            }
        }
        
        function createDigitalClockCube(x, y, z, size) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            const planes = [];

            const cubeGeom = new THREE.BoxGeometry(size, size * 0.6, size);
            const cubeMat = new THREE.MeshStandardMaterial({ color: 0x111, metalness: 0.3, roughness: 0.7 });
            const cube = new THREE.Mesh(cubeGeom, cubeMat);
            cube.position.y = size * 0.3;
            group.add(cube);

            for (let i = 0; i < 4; i++) {
                const angle = i * Math.PI / 2;
                const plane = createClockPlane(size, size * 0.6);
                plane.position.set(Math.sin(angle) * (size / 2 + 0.01), size * 0.3, Math.cos(angle) * (size / 2 + 0.01));
                plane.rotation.y = angle;
                group.add(plane);
                planes.push(plane);
            }
            scene.add(group);
            group.updateMatrixWorld(true);
            collisionObjects.push(new THREE.Box3().setFromObject(cube));

            setInterval(() => {
                planes.forEach(plane => updateClockPlane(plane.material));
            }, 1000);
        }

        function createClockPlane(width, height) {
            const material = new THREE.MeshStandardMaterial({ roughness: 0.7, metalness: 0.2 });
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), material);
            updateClockPlane(material);
            return plane;
        }

        function updateClockPlane(material) {
            const canvas = material.map ? material.map.image : document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 800;
            canvas.height = 400;
            
            context.fillStyle = '#111';
            context.fillRect(0, 0, 800, 400);
            
            const now = new Date();
            const timeStr = now.toLocaleTimeString('es-ES', { hour12: false });
            context.font = 'bold 160px monospace';
            context.fillStyle = '#0ff';
            context.shadowColor = '#0ff';
            context.shadowBlur = 32;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(timeStr, 400, 200);

            if (!material.map) {
                material.map = new THREE.CanvasTexture(canvas);
            } else {
                material.map.needsUpdate = true;
            }
        }

        // --- Manejadores de Eventos ---
        function setupEventListeners() {
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousedown', onMouseDown);
        }
        
        function setupUIButtons() {
            console.log('Configurando botones de UI...');
            
            // Verificar que el botón se encontró correctamente
            if (changeAliasBtn) {
                console.log('Botón de personalización encontrado');
                changeAliasBtn.onclick = () => {
                    console.log('Botón de personalización clickeado');
                    // Mostrar el panel de personalización completo
                    openCustomizationPanel();
                };
            } else {
                console.error('No se encontró el botón de personalización');
            }
            
            if (saveCustomizationBtn) {
                console.log('Botón de guardar personalización encontrado');
                saveCustomizationBtn.onclick = saveCustomization;
            } else {
                console.error('No se encontró el botón de guardar personalización');
            }
            
            if (resetCustomizationBtn) {
                console.log('Botón de resetear personalización encontrado');
                resetCustomizationBtn.onclick = resetCustomization;
            } else {
                console.error('No se encontró el botón de resetear personalización');
            }
        }

        function onKeyDown(event) {
            // Si el chat está abierto, no procesar controles del juego
            if (chatOpen) {
                return;
            }
            
            const key = event.code.replace('Key', '');
            if (key in keys) keys[key] = true;
            if (event.code === 'ArrowUp') keys.W = true;
            if (event.code === 'ArrowDown') keys.S = true;
            if (event.code === 'ArrowLeft') keys.A = true;
            if (event.code === 'ArrowRight') keys.D = true;
            
            if (event.code === 'KeyW' && !keyW) { // W para subir de piso (solo una vez)
                if (currentFloor < MAX_FLOOR) currentFloor++;
                keyW = true;
            }
            if (event.code === 'KeyS' && !keyS) { // S para bajar de piso (solo una vez)
                if (currentFloor > MIN_FLOOR) currentFloor--;
                keyS = true;
            }
            if (event.code === 'KeyA') { // A para moverse hacia la izquierda
                keyA = true;
            }
            if (event.code === 'KeyD') { // D para moverse hacia la derecha
                keyD = true;
            }
        }

        function onKeyUp(event) {
            const key = event.code.replace('Key', '');
            if (key in keys) keys[key] = false;
            if (event.code === 'ArrowUp') keys.W = false;
            if (event.code === 'ArrowDown') keys.S = false;
            if (event.code === 'ArrowLeft') keys.A = false;
            if (event.code === 'ArrowRight') keys.D = false;
            if (event.code === 'KeyA') keyA = false;
            if (event.code === 'KeyD') keyD = false;
            if (event.code === 'KeyW') keyW = false;
            if (event.code === 'KeyS') keyS = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onMouseDown(event) {
            // CRÍTICO: Verificar si el clic es en un elemento de UI - NO procesar en ese caso
            const target = event.target;
            const isUIElement = target.closest('#ui-container') || 
                               target.closest('#chat-panel') || 
                               target.closest('#simple-panel') ||
                               target.closest('#ui-overlay') ||
                               target.closest('button') ||
                               target.closest('input') ||
                               target.closest('select');
            
            if (isUIElement) {
                return; // NO procesar clics en elementos de UI
            }
            
            // Si el overlay está activo, no procesar ningún clic del juego
            const overlay = document.getElementById('ui-overlay');
            if (overlay && overlay.style.display === 'block' && overlay.style.pointerEvents === 'auto') {
                return;
            }
            // Si el chat está abierto, no procesar controles del juego
            if (chatOpen) {
                return;
            }
            // Si el panel de personalización está abierto, no procesar clics del juego
            const simplePanel = document.getElementById('simple-panel');
            if (simplePanel && simplePanel.style.display === 'block') {
                return;
            }
            
            if (event.button !== 0) return; // Solo clic izquierdo
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(clickableObjects);
            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                
                // Verificar si es un clic en el nombre del avatar para personalización
                if (clickedObject.userData && clickedObject.userData.type === 'customization') {
                    openCustomizationPanel();
                    return;
                }
                
                // Verificar si es un clic en una tienda - CON VERIFICACIÓN DE PROXIMIDAD
                if (clickedObject.userData && clickedObject.userData.URL) {
                    // Calcular distancia entre el usuario y la tienda
                    const storePosition = clickedObject.position;
                    const userPosition = camera.position;
                    const distance = userPosition.distanceTo(storePosition);
                    
                    // Solo permitir clic si está a menos de 8 unidades de distancia
                    const maxClickDistance = 8;
                    if (distance <= maxClickDistance) {
                        window.open(clickedObject.userData.URL, '_blank');
                    } else {
                        // Mostrar mensaje de que está muy lejos
                        console.log(`Estás muy lejos de la tienda. Distancia: ${distance.toFixed(1)} unidades`);
                        // Opcional: mostrar notificación visual
                        showProximityMessage(`Acércate más a la tienda para hacer clic (${distance.toFixed(1)}m)`);
                    }
                }
            }
        }

        function updateMovement() {
            // Si el chat está abierto, no actualizar movimiento
            if (chatOpen) {
                return;
            }
            
            // --- Rotación con flechas izquierda/derecha ---
            if (keys.ArrowLeft) targetRotationY -= ROTATE_SPEED;
            if (keys.ArrowRight) targetRotationY += ROTATE_SPEED;

            // --- Movimiento hacia adelante/atrás con flechas ---
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();
            
            const velocity = new THREE.Vector3();
            
            // Movimiento hacia adelante/atrás con flechas arriba/abajo
            if (keys.ArrowUp) velocity.add(direction);
            if (keys.ArrowDown) velocity.sub(direction);
            
            // Movimiento lateral con A y D (teclas)
            const rightDirection = new THREE.Vector3();
            rightDirection.setFromMatrixColumn(camera.matrix, 0);
            rightDirection.y = 0;
            rightDirection.normalize();
            
            if (keyA) velocity.sub(rightDirection); // Moverse hacia la izquierda
            if (keyD) velocity.add(rightDirection); // Moverse hacia la derecha
            
            if (velocity.length() > 0) {
                velocity.normalize().multiplyScalar(MOVE_SPEED);
                const newPosition = targetPosition.clone().add(velocity);
                
                // --- Colisiones optimizadas ---
                const playerBox = new THREE.Box3().setFromCenterAndSize(newPosition, new THREE.Vector3(1.0, CAMERA_HEIGHT, 1.0));
                let collision = false;
                
                // Optimización: solo verificar colisiones cercanas
                const nearbyCollisions = collisionObjects.filter(wallBox => {
                    const distance = wallBox.getCenter(new THREE.Vector3()).distanceTo(newPosition);
                    return distance < 20; // Solo verificar objetos dentro de 20 unidades
                });
                
                for (const wallBox of nearbyCollisions) {
                    if (playerBox.intersectsBox(wallBox)) {
                        collision = true;
                        break;
                    }
                }
                
                if (!collision) {
                    targetPosition.copy(newPosition);
                }
            }

            // --- Cambio de Piso ---
            const floorStep = HALL_HEIGHT + 1;
            const targetY = currentFloor * floorStep + CAMERA_HEIGHT;
            targetPosition.y = targetY;

            // --- Interpolación para suavidad ---
            camera.position.lerp(targetPosition, 0.2);
            camera.rotation.y = lerpAngle(camera.rotation.y, targetRotationY, 0.2);
        }

        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            // Control de FPS
            const deltaTime = currentTime - lastTime;
            if (deltaTime < frameInterval) {
                return;
            }
            
            lastTime = currentTime - (deltaTime % frameInterval);
            frameCount++;
            
            // Actualizar el color del cielo cada minuto (60000 ms)
            if (currentTime - lastSkyUpdate > 60000) {
                scene.background = getSkyColor();
                lastSkyUpdate = currentTime;
            }
            
            updateMovement();
            updateAvatarPositions(); // Actualizar posiciones de avatares
            
            // Enviar posición del usuario cada 100ms (10 veces por segundo)
            if (frameCount % 6 === 0) { // 60 FPS / 6 = 10 veces por segundo
                sendUserPosition();
            }
            
            renderer.render(scene, camera);
        }
        
        // Función para limpiar recursos
        function cleanup() {
            // Limpiar cache de texturas
            logoTextureCache.forEach(texture => {
                if (texture && texture.dispose) {
                    texture.dispose();
                }
            });
            logoTextureCache.clear();
            
            // Limpiar cache de materiales
            materialCache.forEach(material => {
                if (material && material.dispose) {
                    material.dispose();
                }
            });
            materialCache.clear();
            
            // Limpiar cache de texturas generadas
            textureCache.forEach(texture => {
                if (texture && texture.dispose) {
                    texture.dispose();
                }
            });
            textureCache.clear();
        }
        
        // Limpiar al cerrar la página
        window.addEventListener('beforeunload', cleanup);

        function lerpAngle(a, b, t) {
            let diff = b - a;
            while (diff < -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;
            return a + diff * t;
        }

        // --- Chat UI Logic ---
        const chatToggleBtn = document.getElementById('chat-toggle-btn');
        const chatPanel = document.getElementById('chat-panel');
        const chatCloseBtn = document.getElementById('chat-close-btn');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');
        const emojiToggle = document.getElementById('emoji-toggle');
        const emojiPanel = document.getElementById('emoji-panel');
        const usersList = document.getElementById('users-list');
        const changeAliasBtn = document.getElementById('change-alias-btn');
        let userAlias = localStorage.getItem('userAlias') || '';
        let chatOpen = false;
        let connectedUsers = [];
        
        chatToggleBtn.onclick = () => {
            const simplePanel = document.getElementById('simple-panel');
            if (simplePanel && simplePanel.style.display === 'block') {
                closeSimplePanel();
            }
            chatPanel.style.display = 'flex';
            chatOpen = true;
            chatInput.focus();
            // El overlay NO debe mostrarse al abrir el chat
        };
        chatCloseBtn.onclick = () => {
            chatPanel.style.display = 'none';
            chatOpen = false;
            // El overlay NO debe ocultarse al cerrar el chat
        };

        // --- Emojis ---
        const emojis = ['😊', '😂', '❤️', '👍', '🎉', '🔥', '😎', '🤔', '😢', '😡', '👋', '💪', '🎯', '⭐', '💯', '🚀', '💎', '🎮', '🍕', '☕', '🌮', '🍺', '🎵', '🎬', '⚽', '🏀', '🎾', '🏈', '⚡', '🌈', '🌙', '☀️'];
        function createEmojiPanel() {
            emojiPanel.innerHTML = '';
            emojis.forEach(emoji => {
                const btn = document.createElement('button');
                btn.className = 'emoji-btn';
                btn.textContent = emoji;
                btn.onclick = () => {
                    chatInput.value += emoji;
                    chatInput.focus();
                    emojiPanel.style.display = 'none';
                };
                emojiPanel.appendChild(btn);
            });
        }
        emojiToggle.onclick = () => {
            if (emojiPanel.style.display === 'none' || !emojiPanel.style.display) {
                emojiPanel.style.display = 'flex';
                createEmojiPanel();
            } else {
                emojiPanel.style.display = 'none';
            }
        };

        document.addEventListener('click', (e) => {
            if (!emojiPanel.contains(e.target) && !emojiToggle.contains(e.target)) {
                emojiPanel.style.display = 'none';
            }
        });

        // --- Firebase Chat Logic ---
        function handleSendMessage() {
            const message = chatInput.value.trim();
            if (message.length > 0 && userAlias) {
                if (privateRecipient) {
                    sendPrivateMessage(privateRecipient, message);
                } else {
                    sendMessage(message);
                }
                chatInput.value = '';
            }
        }
        chatSendBtn.onclick = handleSendMessage;
        chatInput.addEventListener('keydown', e => {
            if (e.key === 'Enter') {
                handleSendMessage();
            }
        });

        // Alias setup and connect to chat
        if (!userAlias) {
            userAlias = 'Usuario_' + Math.floor(Math.random() * 10000);
            localStorage.setItem('userAlias', userAlias);
        }
        if (userAlias) {
            changeAliasBtn.style.display = 'flex';
        }
        connectToChat(userAlias); // Provided by firebase-config.js

        // --- Funciones de personalización de avatar ---
        const saveCustomizationBtn = document.getElementById('save-customization-btn');
        const resetCustomizationBtn = document.getElementById('reset-customization-btn');
        const shirtColorsGrid = document.getElementById('shirt-colors');
        const pantsColorsGrid = document.getElementById('pants-colors');
        const shoesColorsGrid = document.getElementById('shoes-colors');
        


        function openCustomizationPanel() {
            console.log('Abriendo panel simple de personalización');
            
            // Cerrar chat si está abierto
            if (chatOpen) {
                chatPanel.style.display = 'none';
                chatOpen = false;
            }
            
            const simplePanel = document.getElementById('simple-panel');
            if (simplePanel) {
                // Actualizar el alias actual
                const currentAliasElement = document.getElementById('current-alias');
                if (currentAliasElement) {
                    currentAliasElement.textContent = userAlias || 'Sin alias';
                }
                
                // Poblar el input con el alias actual
                const aliasInput = document.getElementById('simple-alias-input');
                if (aliasInput) {
                    aliasInput.value = userAlias || '';
                    // Agregar event listener para actualizar vista previa en tiempo real
                    aliasInput.addEventListener('input', function() {
                        updateAvatarPreview();
                    });
                }
                
                // Mostrar el panel
                simplePanel.style.display = 'block';
                customizationPanelOpen = true;
                
                // Inicializar vista previa del avatar
                updateAvatarPreview();
                
                console.log('✅ Panel simple mostrado');
                            // Mostrar overlay y bloquear clics
            const overlay = document.getElementById('ui-overlay');
            if (overlay) {
                overlay.style.display = 'block';
                overlay.style.pointerEvents = 'auto';
                overlay.style.zIndex = '20000';
            }
            // Asegurar que el panel esté por encima
            simplePanel.style.zIndex = '21000';
            simplePanel.style.pointerEvents = 'auto';
            } else {
                console.log('❌ Panel simple no encontrado');
            }
        }
        

        
        function changeShirtColor(color) {
            console.log('Cambiando color de camisa a:', color);
            shirtColor = color;
            currentCustomization.shirtColor = color;
            updateAvatarPreview();
            updateColorButtonSelection('shirt', color);
        }
        
        function changePantsColor(color) {
            console.log('Cambiando color de pantalón a:', color);
            pantsColor = color;
            
            // Actualizar el avatar en tiempo real usando el sistema correcto
            const avatar = userAvatars.get(userAlias);
            if (avatar && avatar.pantsMaterial) {
                avatar.pantsMaterial.color.setHex(color);
                avatar.pantsMaterial.needsUpdate = true;
            }
            
            // Actualizar vista previa
            updateAvatarPreview();
            
            // Feedback visual en los botones
            updateColorButtonSelection('pants', color);
        }
        
        function changeShoesColor(color) {
            console.log('Cambiando color de zapatos a:', color);
            shoesColor = color;
            
            // Actualizar el avatar en tiempo real usando el sistema correcto
            const avatar = userAvatars.get(userAlias);
            if (avatar && avatar.shoeMaterial) {
                avatar.shoeMaterial.color.setHex(color);
                avatar.shoeMaterial.needsUpdate = true;
            }
            
            // Actualizar vista previa
            updateAvatarPreview();
            
            // Feedback visual en los botones
            updateColorButtonSelection('shoes', color);
        }
        
        function updateColorButtonSelection(type, selectedColor) {
            // Remover selección anterior
            document.querySelectorAll('.color-option').forEach(btn => {
                btn.style.borderColor = 'transparent';
                btn.style.transform = 'scale(1)';
            });
            
            // Marcar el botón seleccionado
            const selectedBtn = document.querySelector(`[data-color="${selectedColor}"]`);
            if (selectedBtn) {
                selectedBtn.style.borderColor = '#FFD700';
                selectedBtn.style.transform = 'scale(1.1)';
                selectedBtn.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.5)';
            }
        }
        
        function updateAvatarPreview() {
            const previewDiv = document.getElementById('avatar-preview');
            const aliasInput = document.getElementById('simple-alias-input');
            // Eliminar referencia a preview-alias
            if (previewDiv) {
                // Actualizar el alias en la vista previa
                const currentAlias = aliasInput ? aliasInput.value.trim() : userAlias;
                // Crear una vista previa visual del avatar más detallada
                const shirtColorHex = shirtColor.toString(16).padStart(6, '0');
                const pantsColorHex = pantsColor.toString(16).padStart(6, '0');
                const shoesColorHex = shoesColor.toString(16).padStart(6, '0');
                previewDiv.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 0; position: relative; width: 90px; height: 180px;">
                        <!-- Cabeza cuadrada -->
                        <div style="width: 40px; height: 40px; background: #FFE4C4; border: 2px solid #333; position: relative; margin-bottom: 0;">
                            <!-- Ojos -->
                            <div style="position: absolute; top: 12px; left: 10px; width: 6px; height: 6px; background: #222; border-radius: 1px;"></div>
                            <div style="position: absolute; top: 12px; right: 10px; width: 6px; height: 6px; background: #222; border-radius: 1px;"></div>
                            <!-- Boca -->
                            <div style="position: absolute; bottom: 10px; left: 12px; width: 16px; height: 4px; background: #222; border-radius: 1px;"></div>
                        </div>
                        <!-- Torso y brazos -->
                        <div style="display: flex; flex-direction: row; align-items: flex-start; height: 50px;">
                            <!-- Brazo izquierdo -->
                            <div style="width: 16px; height: 50px; background: #${shirtColorHex}; border: 2px solid #333; margin-right: 0;"></div>
                            <!-- Torso -->
                            <div style="width: 28px; height: 50px; background: #${shirtColorHex}; border: 2px solid #333; margin: 0 0;"></div>
                            <!-- Brazo derecho -->
                            <div style="width: 16px; height: 50px; background: #${shirtColorHex}; border: 2px solid #333; margin-left: 0;"></div>
                        </div>
                        <!-- Piernas -->
                        <div style="display: flex; flex-direction: row; align-items: flex-start; height: 50px; margin-top: 0;">
                            <!-- Pierna izquierda -->
                            <div style="width: 16px; height: 50px; background: #${pantsColorHex}; border: 2px solid #333; margin-right: 4px;"></div>
                            <!-- Pierna derecha -->
                            <div style="width: 16px; height: 50px; background: #${pantsColorHex}; border: 2px solid #333; margin-left: 4px;"></div>
                        </div>
                        <!-- Zapatos -->
                        <div style="display: flex; flex-direction: row; align-items: flex-start; height: 12px; margin-top: -2px;">
                            <!-- Pie izquierdo -->
                            <div style="width: 16px; height: 12px; background: #${shoesColorHex}; border: 2px solid #333; margin-right: 4px;"></div>
                            <!-- Pie derecho -->
                            <div style="width: 16px; height: 12px; background: #${shoesColorHex}; border: 2px solid #333; margin-left: 4px;"></div>
                        </div>
                        <!-- Nombre del avatar -->
                        <div style="color: #FFD700; font-size: 12px; font-weight: bold; text-align: center; margin-top: 8px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); width: 100%;">${currentAlias || 'Sin nombre'}</div>
                    </div>
                `;
            }
        }
        
        function resetSimpleCustomization() {
            console.log('Restableciendo personalización');
            
            // Restablecer colores por defecto
            shirtColor = 0xFF6B6B;
            pantsColor = 0x2C3E50;
            shoesColor = 0x8B4513;
            
            // Restablecer alias
            userAlias = '';
            const aliasInput = document.getElementById('simple-alias-input');
            if (aliasInput) {
                aliasInput.value = '';
            }
            
            // Actualizar avatar en tiempo real usando el sistema correcto
            const avatar = userAvatars.get(userAlias);
            if (avatar) {
                if (avatar.bodyMaterial) avatar.bodyMaterial.color.setHex(shirtColor);
                if (avatar.pantsMaterial) avatar.pantsMaterial.color.setHex(pantsColor);
                if (avatar.shoeMaterial) avatar.shoeMaterial.color.setHex(shoesColor);
                
                // Forzar actualización de materiales
                if (avatar.bodyMaterial) avatar.bodyMaterial.needsUpdate = true;
                if (avatar.pantsMaterial) avatar.pantsMaterial.needsUpdate = true;
                if (avatar.shoeMaterial) avatar.shoeMaterial.needsUpdate = true;
            }
            
            // Actualizar vista previa
            updateAvatarPreview();
            
            // Limpiar selección de botones
            document.querySelectorAll('.color-option').forEach(btn => {
                btn.style.borderColor = 'transparent';
                btn.style.transform = 'scale(1)';
                btn.style.boxShadow = 'none';
            });
            
            console.log('✅ Personalización restablecida');
        }
        
        function saveSimpleCustomization() {
            console.log('Guardando personalización');
            
            const aliasInput = document.getElementById('simple-alias-input');
            const newAlias = aliasInput ? aliasInput.value.trim() : '';
            
            // Validar alias
            if (newAlias.length > 20) {
                alert('El nombre no puede tener más de 20 caracteres');
                return;
            }
            
            // Guardar alias
            userAlias = newAlias;
            
            // Guardar en localStorage
            const customizationData = {
                alias: userAlias,
                shirtColor: shirtColor,
                pantsColor: pantsColor,
                shoesColor: shoesColor
            };
            
            localStorage.setItem('avatarCustomization', JSON.stringify(customizationData));
            
            // Actualizar nombre en el avatar
            updateAvatarName();
            
            // Enviar alias al servidor si está conectado
            if (isConnected) {
                sendAlias();
            }
            
            // Cerrar panel
            closeSimplePanel();
            
            console.log('✅ Personalización guardada:', customizationData);
        }
        
        function closeSimplePanel() {
            const panel = document.getElementById('simple-panel');
            if (panel) {
                panel.style.display = 'none';
                customizationPanelOpen = false;
                // Ocultar overlay y permitir clics
                const overlay = document.getElementById('ui-overlay');
                if (overlay) {
                    overlay.style.display = 'none';
                    overlay.style.pointerEvents = 'none';
                }
                panel.style.zIndex = '21000';
                panel.style.pointerEvents = 'auto';
                console.log('Panel simple cerrado');
            }
        }
        
        // Event listeners para actualización en tiempo real
        document.addEventListener('DOMContentLoaded', function() {
            const aliasInput = document.getElementById('simple-alias-input');
            if (aliasInput) {
                aliasInput.addEventListener('input', function() {
                    updateAvatarPreview();
                });
            }
        });

        function closeWorkingPanel() {
            const panel = document.getElementById('working-customization-panel');
            if (panel) {
                panel.remove();
            }
            customizationPanelOpen = false;
        }
        
        function changeShirtColor(color) {
            currentCustomization.shirtColor = color;
            applyCustomizationToAvatar();
            console.log('Color de camisa cambiado a:', color);
        }
        
        function saveSimpleCustomization() {
            const aliasInput = document.getElementById('simple-alias-input');
            const newAlias = aliasInput.value.trim();
            
            if (newAlias.length > 0) {
                userAlias = newAlias;
                localStorage.setItem('userAlias', userAlias);
                
                if (isConnected) {
                    sendAlias();
                }
                
                console.log('Alias guardado:', newAlias);
            }
            
            localStorage.setItem('avatarCustomization', JSON.stringify(currentCustomization));
            closeSimplePanel();
            alert('¡Personalización guardada!');
        }
        
        function createWorkingColorGrids() {
            // Crear opciones de color para camisas (primeros 18 colores)
            const shirtGrid = document.getElementById('working-shirt-colors');
            for (let i = 0; i < 18; i++) {
                const colorOption = document.createElement('div');
                colorOption.style.cssText = `
                    width: 40px;
                    height: 40px;
                    border: 3px solid transparent;
                    border-radius: 8px;
                    cursor: pointer;
                    background-color: #${customizationColors[i].toString(16).padStart(6, '0')};
                `;
                colorOption.onclick = () => selectWorkingColor(customizationColors[i], 'shirt');
                if (customizationColors[i] === currentCustomization.shirtColor) {
                    colorOption.style.borderColor = '#FFD700';
                }
                shirtGrid.appendChild(colorOption);
            }
            

        }
        

        

        

        


        function closeCustomizationPanel() {
            customizationPanel.style.display = 'none';
            customizationPanelOpen = false;
        }

        function createColorGrids() {
            // Limpiar grids existentes
            const shirtColorsGrid = document.getElementById('shirt-colors');
            const pantsColorsGrid = document.getElementById('pants-colors');
            const shoesColorsGrid = document.getElementById('shoes-colors');

            shirtColorsGrid.innerHTML = '';
            pantsColorsGrid.innerHTML = '';
            shoesColorsGrid.innerHTML = '';

            // Definir los colores disponibles para cada tipo
            // Colores para camisas (colores vibrantes y variados)
            const shirtColors = [
                { color: 0xFF6B6B, name: 'Rosado' },
                { color: 0x4ECDC4, name: 'Turquesa' },
                { color: 0x45B7D1, name: 'Azul Marino' },
                { color: 0x96CEB4, name: 'Verde Claro' },
                { color: 0xFFEAA7, name: 'Amarillo' },
                { color: 0xDDA0DD, name: 'Lila' },
                { color: 0x98D8C8, name: 'Verde Agua' },
                { color: 0xF7DC6F, name: 'Amarillo Dorado' },
                { color: 0xBB8FCE, name: 'Morado' },
                { color: 0x85C1E9, name: 'Azul Cielo' },
                { color: 0xF8C471, name: 'Naranja' },
                { color: 0x82E0AA, name: 'Verde Hoja' }
            ];

            // Colores para pantalones (colores más sobrios y neutros)
            const pantsColors = [
                { color: 0x2C3E50, name: 'Gris Oscuro' },
                { color: 0x3498DB, name: 'Azul' },
                { color: 0xE74C3C, name: 'Rojo' },
                { color: 0x9B59B6, name: 'Violeta' },
                { color: 0x34495E, name: 'Azul Oscuro' },
                { color: 0x2ECC71, name: 'Verde' },
                { color: 0x16A085, name: 'Verde Agua' },
                { color: 0x2980B9, name: 'Azul Marino' },
                { color: 0x8E44AD, name: 'Morado' }
            ];

            // Colores para zapatos (colores oscuros y neutros)
            const shoesColors = [
                { color: 0x8B4513, name: 'Marrón' },
                { color: 0x6E2C00, name: 'Marrón Oscuro' },
                { color: 0x1A5276, name: 'Azul Marino' },
                { color: 0x154360, name: 'Azul Oscuro' }
            ];

            // Crear opciones de color para cada tipo
            const createOption = (colorObj, type) => {
                const option = document.createElement('div');
                option.className = 'color-option';
                option.style.setProperty('--color', '#' + colorObj.color.toString(16).padStart(6, '0'));
                option.dataset.color = colorObj.color;
                option.dataset.type = type;
                
                // Agregar título al pasar el mouse
                option.title = colorObj.name;
                
                // Agregar evento click
                option.onclick = () => selectColor(colorObj.color, type);
                
                return option;
            };

            // Crear botones para cada tipo
            shirtColors.forEach(color => shirtColorsGrid.appendChild(createOption(color, 'shirt')));
            pantsColors.forEach(color => pantsColorsGrid.appendChild(createOption(color, 'pants')));
            shoesColors.forEach(color => shoesColorsGrid.appendChild(createOption(color, 'shoes')));

            // Actualizar selecciones iniciales
            updateSelectedColors();
        }

        // Inicializar los grids de colores al cargar
        document.addEventListener('DOMContentLoaded', createColorGrids);



        function selectColor(color, type) {
            // Remover selección previa del mismo tipo
            const allSelected = document.querySelectorAll(`.color-option.selected[data-type="${type}"]`);
            allSelected.forEach(btn => btn.classList.remove('selected'));
            
            // Seleccionar nueva opción
            const selectedOption = document.querySelector(`[data-color="${color}"][data-type="${type}"]`);
            if (selectedOption) {
                selectedOption.classList.add('selected');
            }
            
            // Actualizar color actual
            switch (type) {
                case 'shirt':
                    currentCustomization.shirtColor = color;
                    break;
                case 'pants':
                    currentCustomization.pantsColor = color;
                    break;
                case 'shoes':
                    currentCustomization.shoesColor = color;
                    break;
            }
            
            // Actualizar selecciones visuales
            updateSelectedColors();
            
            // Aplicar cambios inmediatamente al avatar
            applyCustomizationToAvatar();
        }

        function updateSelectedColors() {
            // Actualizar selecciones visuales
            const shirtOption = document.querySelector(`[data-color="${currentCustomization.shirtColor}"][data-type="shirt"]`);
            const pantsOption = document.querySelector(`[data-color="${currentCustomization.pantsColor}"][data-type="pants"]`);
            const shoesOption = document.querySelector(`[data-color="${currentCustomization.shoesColor}"][data-type="shoes"]`);
            
            if (shirtOption) shirtOption.classList.add('selected');
            if (pantsOption) pantsOption.classList.add('selected');
            if (shoesOption) shoesOption.classList.add('selected');
        }

        function applyCustomizationToAvatar() {
            // Actualizar las variables globales
            shirtColor = currentCustomization.shirtColor;
            pantsColor = currentCustomization.pantsColor;
            shoesColor = currentCustomization.shoesColor;
            
            // Actualizar la vista previa existente
            updateAvatarPreview();
            
            // Actualizar los colores en el localStorage
            const customizationData = {
                shirtColor: currentCustomization.shirtColor,
                pantsColor: currentCustomization.pantsColor,
                shoesColor: currentCustomization.shoesColor
            };
            localStorage.setItem('avatarCustomization', JSON.stringify(customizationData));
        }

        function saveCustomization() {
            // Obtener el nuevo alias del input
            const aliasInput = document.getElementById('customization-alias-input');
            const newAlias = aliasInput.value.trim();
            
            // Validar el alias
            if (newAlias.length === 0) {
                addMessageToChat('Sistema', 'El alias no puede estar vacío', 'system');
                return;
            }
            
            if (newAlias.length > 18) {
                addMessageToChat('Sistema', 'El alias no puede tener más de 18 caracteres', 'system');
                return;
            }
            
            // Actualizar el alias si ha cambiado
            if (newAlias !== userAlias) {
                userAlias = newAlias;
                localStorage.setItem('userAlias', userAlias);
                
                // Enviar nuevo alias al servidor
                if (isConnected) {
                    sendAlias();
                }
            }
            
            // Guardar personalización en localStorage
            localStorage.setItem('avatarCustomization', JSON.stringify(currentCustomization));
            closeCustomizationPanel();
            
            // Mostrar mensaje de confirmación
            addMessageToChat('Sistema', 'Personalización guardada exitosamente', 'system');
        }

        function resetCustomization() {
            // Restablecer a colores por defecto
            currentCustomization = {
                shirtColor: 0x4ECDC4,
                pantsColor: 0x2C3E50,
                shoesColor: 0x8B4513
            };
            
            // Aplicar cambios
            applyCustomizationToAvatar();
            updateSelectedColors();
        }

        function loadCustomization() {
            const saved = localStorage.getItem('avatarCustomization');
            if (saved) {
                try {
                    currentCustomization = JSON.parse(saved);
                    applyCustomizationToAvatar();
                } catch (error) {
                    console.error('Error cargando personalización:', error);
                }
            }
        }



        // Cerrar panel al hacer clic fuera - VERSIÓN MEJORADA
        document.addEventListener('click', (e) => {
            // Verificar si el clic es en un botón de UI - NO cerrar en ese caso
            const isUIButton = e.target.closest('#chat-toggle-btn') || 
                              e.target.closest('#change-alias-btn') || 
                              e.target.closest('#chat-panel') || 
                              e.target.closest('#simple-panel') ||
                              e.target.closest('#ui-overlay');
            
            if (isUIButton) {
                return; // No hacer nada si el clic es en un elemento de UI
            }
            
            // Cerrar chat si está abierto y se hace clic fuera
            if (chatOpen && !chatPanel.contains(e.target) && !chatToggleBtn.contains(e.target)) {
                chatPanel.style.display = 'none';
                chatOpen = false;
                // Ocultar overlay
                const overlay = document.getElementById('ui-overlay');
                if (overlay) {
                    overlay.style.display = 'none';
                    overlay.style.pointerEvents = 'none';
                }
            }
            
            if (customizationPanelOpen && !customizationPanel.contains(e.target)) {
                closeCustomizationPanel();
            }
            
            // Cerrar panel de trabajo al hacer clic fuera
            const workingPanel = document.getElementById('working-customization-panel');
            if (workingPanel && !workingPanel.contains(e.target)) {
                closeWorkingPanel();
            }
        });

        // Agregar event listener al overlay para bloquear clics - VERSIÓN MEJORADA
        const overlay = document.getElementById('ui-overlay');
        if (overlay) {
            overlay.addEventListener('click', (e) => {
                // Solo bloquear clics si el overlay está activo y el clic no es en un botón de UI
                const isUIButton = e.target.closest('#chat-toggle-btn') || 
                                  e.target.closest('#change-alias-btn') || 
                                  e.target.closest('#chat-panel') || 
                                  e.target.closest('#simple-panel');
                
                if (!isUIButton && overlay.style.display === 'block' && overlay.style.pointerEvents === 'auto') {
                e.stopPropagation();
                e.preventDefault();
                return false;
                }
            });
        }

        // Cargar personalización al iniciar
        loadCustomization();

        function sendUserPosition() {
            if (userAlias) {
                // TODO: Enviar posición a Firebase
                // firebase.database().ref('positions').child(userAlias).set({ ... })
            }
        }

        function updateAvatarPosition(alias, position, floor, rotation = 0) {
            if (!position || typeof position.x !== 'number' || typeof position.y !== 'number' || typeof position.z !== 'number') {
                console.warn('Posición inválida para alias:', alias, position);
                return;
            }
            if (typeof floor !== 'number') {
                console.warn('Floor inválido para alias:', alias, floor);
                return;
            }
            if (typeof rotation !== 'number') {
                console.warn('Rotación inválida para alias:', alias, rotation);
                return;
            }
            // No crear avatar para el usuario propio
            if (alias === userAlias) {
                return;
            }
            let avatar = userAvatars.get(alias);
            if (!avatar) {
                createUserAvatar(alias, position, floor);
                avatar = userAvatars.get(alias);
            }
            if (avatar) {
                const floorStep = HALL_HEIGHT + 1;
                const targetY = floor * floorStep + 0.6; // Punto intermedio entre 0.2 y 1.0
                avatar.targetPosition.set(position.x, targetY, position.z);
                avatar.currentFloor = floor;
                avatar.group.position.y = targetY;
                let normalizedRotation = rotation;
                while (normalizedRotation > Math.PI) normalizedRotation -= 2 * Math.PI;
                while (normalizedRotation < -Math.PI) normalizedRotation += 2 * Math.PI;
                avatar.targetRotation = normalizedRotation;
                const rotationDegrees = (normalizedRotation * 180 / Math.PI).toFixed(1);
                // Opcional: console.log(`Avatar ${alias} rotación actualizada a: ${rotationDegrees}° (${normalizedRotation.toFixed(3)} rad)`);
            }
        }

        // Asegurar que el DOM esté completamente cargado antes de inicializar
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        // Configurar overlay al cargar la página - VERSIÓN MEJORADA
        document.addEventListener('DOMContentLoaded', () => {
            const overlay = document.getElementById('ui-overlay');
            if (overlay) {
                overlay.style.pointerEvents = 'auto';
                overlay.addEventListener('click', (e) => {
                    // Solo bloquear clics si el overlay está activo y el clic no es en un botón de UI
                    const isUIButton = e.target.closest('#chat-toggle-btn') || 
                                      e.target.closest('#change-alias-btn') || 
                                      e.target.closest('#chat-panel') || 
                                      e.target.closest('#simple-panel');
                    
                    if (!isUIButton && overlay.style.display === 'block' && overlay.style.pointerEvents === 'auto') {
                    e.stopPropagation();
                    e.preventDefault();
                    return false;
                    }
                });
            }
        });

        
       

        // Mostrar prompt de alias si no existe
        if (!userAlias) {
            userAlias = prompt('Ingresa tu alias:');
            if (userAlias) {
                localStorage.setItem('userAlias', userAlias);
            } else {
                userAlias = 'Usuario_' + Math.floor(Math.random() * 10000);
                localStorage.setItem('userAlias', userAlias);
            }
        }

        // Conectar al chat de Firebase
        connectToChat(userAlias);

        

        // Enviar posición del usuario periódicamente (ejemplo cada 500ms)
        setInterval(() => {
            if (
                typeof camera !== 'undefined' &&
                camera.position &&
                typeof camera.position.x !== 'undefined' &&
                typeof camera.position.y !== 'undefined' &&
                typeof camera.position.z !== 'undefined'
            ) {
                const position = {
                    x: camera.position.x,
                    y: camera.position.y,
                    z: camera.position.z
                };
                const floor = typeof currentFloor !== 'undefined' ? currentFloor : 0;
                // Invertir la rotación para que los avatares miren igual que la cámara
                const rotation = typeof camera.rotation !== 'undefined' ? -camera.rotation.y : 0;
                sendPosition(position, floor, rotation);
            } else {
                console.warn('Cámara o posición no definida:', camera);
            }
        }, 500);

        // Función mejorada para mostrar mensajes en el chat
        function addMessageToChat(alias, message, type = 'user', timestamp = null) {
            const chatMessages = document.getElementById('chat-messages');
            if (!chatMessages) return;
            let timeStr = '';
            if (timestamp) {
                const date = new Date(timestamp);
                timeStr = `<span style="color:#aaa; font-size:11px; margin-left:8px;">${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>`;
            }
            const isOwn = (alias === userAlias || type === 'own');
            const msgDiv = document.createElement('div');
            msgDiv.className = isOwn ? 'chat-message own' : 'chat-message';
            msgDiv.style.margin = '6px 0';
            msgDiv.style.textAlign = isOwn ? 'right' : 'left';
            msgDiv.innerHTML = `
                <span style="color:${isOwn ? '#FFD700' : '#4ECDC4'}; font-weight:bold;">${alias}:</span>
                <span style="color:#fff;">${message}</span>
                ${timeStr}
            `;
            chatMessages.appendChild(msgDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Listener de mensajes de Firebase
        messagesRef.off('child_added'); // <-- Evita listeners duplicados
        messagesRef.on('child_added', (snapshot) => {
            const msg = snapshot.val();
            addMessageToChat(msg.alias, msg.message, msg.alias === userAlias ? 'own' : 'user', msg.timestamp);
        });

        // Listener de posiciones de avatares en Firebase
        positionsRef.on('value', (snapshot) => {
            const positions = snapshot.val() || {};
            Object.keys(positions).forEach(alias => {
                    const userData = positions[alias];
                if (
                    alias !== userAlias &&
                    userData &&
                    userData.position && typeof userData.position.x === 'number' &&
                    typeof userData.position.y === 'number' &&
                    typeof userData.position.z === 'number' &&
                    typeof userData.floor === 'number' &&
                    typeof userData.rotation === 'number'
                ) {
                    updateAvatarPosition(alias, userData.position, userData.floor, userData.rotation);
                }
            });
            // Eliminar avatares de usuarios que ya no están
            Object.keys(userAvatars).forEach(alias => {
                if (!positions[alias] && alias !== userAlias) {
                    removeUserAvatar(alias);
                }
            });
        });

        // --- Función para crear un avatar de usuario ---
        function createUserAvatar(alias, position = {x:0, y:0, z:0}, floor = 0) {
            if (userAvatars.has(alias)) return;
            const avatarGroup = new THREE.Group();
            avatarGroup.position.set(position.x, position.y, position.z);
            // Geometría visible para el avatar (cubo simple)
            const geometry = new THREE.BoxGeometry(1, 2, 1);
            const material = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = false;
            avatarGroup.add(mesh);
            scene.add(avatarGroup);
            userAvatars.set(alias, {
                group: avatarGroup,
                targetPosition: new THREE.Vector3(position.x, position.y, position.z),
                targetRotation: 0,
                currentFloor: floor
            });
        }
        // --- Función para actualizar todas las posiciones de avatares ---
        function updateAvatarPositions() {
            userAvatars.forEach((avatar, alias) => {
                // Interpolación suave hacia la posición objetivo
                avatar.group.position.lerp(avatar.targetPosition, 0.2);
                // Interpolación suave de rotación
                avatar.group.rotation.y += (avatar.targetRotation - avatar.group.rotation.y) * 0.2;
                // Animación de movimiento estilo Roblox
                animateRobloxAvatar(avatar, alias);
            });
        }

        function openSimplePanel() {
            const panel = document.getElementById('simple-panel');
            if (panel) {
                panel.style.display = 'block';
                customizationPanelOpen = true;
                // Inicializar vista previa del avatar
                updateAvatarPreview();
                // Inicializar los grids de colores
                createColorGrids();
                // Actualizar selecciones de colores
                updateSelectedColors();
            }
        }

        // Inicialización robusta de colores de avatar
        if (typeof shirtColor === 'undefined' || shirtColor === null) shirtColor = 0x4ECDC4;
        if (typeof pantsColor === 'undefined' || pantsColor === null) pantsColor = 0x2C3E50;
        if (typeof shoesColor === 'undefined' || shoesColor === null) shoesColor = 0x8B4513;

        let privateRecipient = null;
        
        // UI: Al hacer clic en un usuario, activar modo privado
        usersList.addEventListener('click', function(e) {
            const userItem = e.target.closest('.user-item');
            if (userItem && !userItem.classList.contains('own')) {
                privateRecipient = userItem.textContent.replace(' (Tú)', '').trim();
                chatInput.placeholder = `Mensaje privado a: ${privateRecipient}`;
                chatInput.focus();
                document.getElementById('private-mode-indicator')?.remove();
                const indicator = document.createElement('div');
                indicator.id = 'private-mode-indicator';
                indicator.textContent = `Modo privado con: ${privateRecipient}`;
                indicator.style = 'background:#FFD700;color:#222;padding:4px 10px;border-radius:6px;margin-bottom:4px;font-weight:bold;text-align:center;';
                chatInput.parentElement.insertBefore(indicator, chatInput);
                // Botón para salir del modo privado
                const exitBtn = document.createElement('button');
                exitBtn.textContent = 'Volver a chat público';
                exitBtn.style = 'margin-left:10px;padding:2px 8px;border-radius:4px;border:none;background:#800000;color:#fff;cursor:pointer;font-size:12px;';
                exitBtn.onclick = function() {
                    privateRecipient = null;
                    chatInput.placeholder = 'Escribe un mensaje...';
                    indicator.remove();
                };
                indicator.appendChild(exitBtn);
            }
        });
        
        // Diferenciar mensajes privados en el chat
        function addMessageToChat(alias, message, type = 'user', timestamp = null, isPrivate = false, recipient = null) {
            const chatMessages = document.getElementById('chat-messages');
            if (!chatMessages) return;
            let timeStr = '';
            if (timestamp) {
                const date = new Date(timestamp);
                timeStr = `<span style="color:#aaa; font-size:11px; margin-left:8px;">${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>`;
            }
            const isOwn = (alias === userAlias || type === 'own');
            const msgDiv = document.createElement('div');
            msgDiv.className = isOwn ? 'chat-message own' : 'chat-message';
            msgDiv.style.margin = '6px 0';
            msgDiv.style.textAlign = isOwn ? 'right' : 'left';
            if (isPrivate) {
                msgDiv.style.background = 'rgba(255,215,0,0.12)';
                msgDiv.style.border = '1px solid #FFD700';
                msgDiv.innerHTML = `<span style="color:${isOwn ? '#FFD700' : '#4ECDC4'}; font-weight:bold;">${alias} (privado):</span> <span style="color:#fff;">${message}</span> ${timeStr}`;
            } else {
                msgDiv.innerHTML = `<span style="color:${isOwn ? '#FFD700' : '#4ECDC4'}; font-weight:bold;">${alias}:</span> <span style="color:#fff;">${message}</span> ${timeStr}`;
            }
            chatMessages.appendChild(msgDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Eliminar definición duplicada de addMessageToChat y el listener de mensajes públicos en index.html
        // Dejar solo la versión de addMessageToChat que soporta mensajes privados y exponerla en window
        window.addMessageToChat = addMessageToChat;

        // --- Enviar posición del usuario periódicamente SOLO si está conectado y sin duplicados ---
        let positionInterval = null;
        function startPositionUpdates() {
            if (positionInterval) clearInterval(positionInterval);
            positionInterval = setInterval(() => {
                if (
                    typeof camera !== 'undefined' &&
                    camera.position &&
                    typeof camera.position.x !== 'undefined' &&
                    typeof camera.position.y !== 'undefined' &&
                    typeof camera.position.z !== 'undefined'
                ) {
                    const position = {
                        x: camera.position.x,
                        y: camera.position.y,
                        z: camera.position.z
                    };
                    const floor = typeof currentFloor !== 'undefined' ? currentFloor : 0;
                    const rotation = typeof camera.rotation !== 'undefined' ? -camera.rotation.y : 0;
                    sendPosition(position, floor, rotation);
                }
            }, 500);
        }
        function stopPositionUpdates() {
            if (positionInterval) clearInterval(positionInterval);
            positionInterval = null;
        }
        // Iniciar al conectar
        document.addEventListener('DOMContentLoaded', () => {
            connectToChat(userAlias);
            startPositionUpdates();
        });
        // Limpiar al cerrar la página
        window.addEventListener('beforeunload', () => {
            stopPositionUpdates();
            disconnectFromChat();
        });

        // --- Función reutilizable para crear un avatar estilo Roblox ---
        function createRobloxAvatar(options) {
            const group = new THREE.Group();
            // Opciones y colores
            const shirtColor = options.shirtColor || 0x4ECDC4;
            const pantsColor = options.pantsColor || 0x2C3E50;
            const shoesColor = options.shoesColor || 0x8B4513;
            const skinColor = 0xFFE4C4;
            // Cabeza
            const headGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const headMaterial = new THREE.MeshStandardMaterial({ color: skinColor });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 1.7, 0);
            group.add(head);
            // Torso
            const bodyGeometry = new THREE.BoxGeometry(1, 1.2, 0.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: shirtColor });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0.9, 0);
            group.add(body);
            // Brazos
            const armGeometry = new THREE.BoxGeometry(0.35, 1, 0.35);
            const armMaterial = new THREE.MeshStandardMaterial({ color: shirtColor });
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.7, 1.1, 0);
            group.add(leftArm);
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.7, 1.1, 0);
            group.add(rightArm);
            // Piernas
            const legGeometry = new THREE.BoxGeometry(0.38, 1, 0.38);
            const legMaterial = new THREE.MeshStandardMaterial({ color: pantsColor });
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.25, 0.0, 0);
            group.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.25, 0.0, 0);
            group.add(rightLeg);
            // Zapatos
            const shoeGeometry = new THREE.BoxGeometry(0.38, 0.18, 0.38);
            const shoeMaterial = new THREE.MeshStandardMaterial({ color: shoesColor });
            const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            leftShoe.position.set(-0.25, -0.5, 0);
            group.add(leftShoe);
            const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            rightShoe.position.set(0.25, -0.5, 0);
            group.add(rightShoe);
            // Materiales para personalización en tiempo real
            group.bodyMaterial = bodyMaterial;
            group.pantsMaterial = legMaterial;
            group.shoeMaterial = shoeMaterial;
            return group;
        }

        // --- Función para crear un avatar de usuario (propio o de otros) ---
        function createUserAvatar(alias, position = {x:0, y:0, z:0}, floor = 0, custom = {}) {
            if (userAvatars.has(alias)) return;
            // Obtener colores personalizados si existen
            const shirtColor = custom.shirtColor || 0x4ECDC4;
            const pantsColor = custom.pantsColor || 0x2C3E50;
            const shoesColor = custom.shoesColor || 0x8B4513;
            const avatarGroup = createRobloxAvatar({ shirtColor, pantsColor, shoesColor });
            
            // Calcular la posición Y correcta para el piso
            const floorStep = HALL_HEIGHT + 1;
            const correctY = floor * floorStep + 0.6; // Punto intermedio entre 0.2 y 1.0
            
            avatarGroup.position.set(position.x, correctY, position.z);
            scene.add(avatarGroup);
            userAvatars.set(alias, {
                group: avatarGroup,
                targetPosition: new THREE.Vector3(position.x, correctY, position.z),
                targetRotation: 0,
                currentFloor: floor,
                bodyMaterial: avatarGroup.bodyMaterial,
                pantsMaterial: avatarGroup.pantsMaterial,
                shoeMaterial: avatarGroup.shoeMaterial
            });
        }

        // --- Animación de movimiento estilo Roblox ---
        function animateRobloxAvatar(avatar, alias) {
            if (!avatar || alias === userAlias) return; // No animar el propio (lo ve en primera persona)
            // Calcular velocidad de movimiento
            const velocity = avatar.group.position.distanceTo(avatar.targetPosition);
            // Si se está moviendo, animar
            if (velocity > 0.01) {
                const time = performance.now() * 0.002 + avatar.group.position.x * 0.1;
                const swing = Math.sin(time * 8) * 0.4;
                // Brazos
                if (avatar.group.children[2]) avatar.group.children[2].rotation.x = swing; // leftArm
                if (avatar.group.children[3]) avatar.group.children[3].rotation.x = -swing; // rightArm
                // Piernas
                if (avatar.group.children[4]) avatar.group.children[4].rotation.x = -swing; // leftLeg
                if (avatar.group.children[5]) avatar.group.children[5].rotation.x = swing; // rightLeg
            } else {
                // Si está quieto, mantener la rotación actual
                if (avatar.group.children[2]) avatar.group.children[2].rotation.x = avatar.group.children[2].rotation.x;
                if (avatar.group.children[3]) avatar.group.children[3].rotation.x = avatar.group.children[3].rotation.x;
                if (avatar.group.children[4]) avatar.group.children[4].rotation.x = avatar.group.children[4].rotation.x;
                if (avatar.group.children[5]) avatar.group.children[5].rotation.x = avatar.group.children[5].rotation.x;
            }
        }

        // Función para controlar los eventos del canvas según el estado de la UI
        function updateCanvasPointerEvents() {
            const canvas = renderer.domElement;
            const chatOpen = document.getElementById('chat-panel').style.display === 'flex';
            const panelOpen = document.getElementById('simple-panel').style.display === 'block';
            
            if (chatOpen || panelOpen) {
                canvas.style.pointerEvents = 'none';
            } else {
                canvas.style.pointerEvents = 'auto';
            }
        }

        // Función para mostrar mensajes de proximidad
        function showProximityMessage(message) {
            // Crear o actualizar el elemento de mensaje
            let messageElement = document.getElementById('proximity-message');
            if (!messageElement) {
                messageElement = document.createElement('div');
                messageElement.id = 'proximity-message';
                messageElement.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: #FFD700;
                    padding: 15px 25px;
                    border-radius: 8px;
                    font-size: 16px;
                    font-weight: bold;
                    z-index: 25000;
                    pointer-events: none;
                    transition: opacity 0.3s;
                `;
                document.body.appendChild(messageElement);
            }
            
            messageElement.textContent = message;
            messageElement.style.opacity = '1';
            
            // Ocultar el mensaje después de 3 segundos
            setTimeout(() => {
                messageElement.style.opacity = '0';
            }, 3000);
        }
    </script>
</body>
</html>