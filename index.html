<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paseo Virtual por Centro Comercial</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            mix-blend-mode: difference;
            z-index: 10;
            pointer-events: none;
        }
        #chat-toggle-btn {
            position: fixed;
            top: 16px;
            left: 16px;
            width: 36px;
            height: 36px;
            background: #222;
            color: #fff;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            z-index: 22000;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            font-size: 20px;
            transition: background 0.2s;
        }
        #chat-toggle-btn:hover {
            background: #444;
        }
        #chat-panel {
            position: fixed;
            top: 60px;
            left: 16px;
            width: 480px;
            max-width: 90vw;
            height: 600px;
            background: rgba(30,30,30,0.85);
            border-radius: 12px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.4);
            z-index: 31000;
            display: none;
            flex-direction: column;
            overflow: hidden;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }
        #chat-header {
            background: rgba(24,24,24,0.9);
            color: #fff;
            padding: 12px 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        #chat-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        #chat-main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        #users-sidebar {
            width: 140px;
            background: rgba(34,34,34,0.9);
            border-left: 1px solid #333;
            padding: 8px;
            overflow-y: auto;
        }
        #users-title {
            color: #aaa;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
        }
        .user-item {
            color: #fff;
            font-size: 12px;
            padding: 4px 6px;
            margin-bottom: 2px;
            border-radius: 4px;
            background: #333;
            border-left: 3px solid transparent;
        }
        #emoji-panel {
            position: absolute;
            bottom: 70px;
            left: 10px;
            right: 10px;
            background: rgba(51,51,51,0.95);
            border-radius: 8px;
            padding: 10px;
            display: none;
            flex-wrap: wrap;
            gap: 4px;
            max-height: 140px;
            overflow-y: auto;
            backdrop-filter: blur(5px);
        }
        .emoji-btn {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: background 0.2s;
        }
        .emoji-btn:hover {
            background: #555;
        }
        #emoji-toggle {
            background: none;
            border: none;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            padding: 4px;
            margin-right: 4px;
        }
        #chat-close-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
        }
        #chat-messages {
            flex: 1;
            padding: 12px;
            overflow-y: auto;
            color: #eee;
            font-size: 15px;
        }
        #chat-input-area {
            display: flex;
            border-top: 1px solid #333;
            background: rgba(34,34,34,0.9);
            padding: 10px;
        }
        #chat-input {
            flex: 1;
            border: none;
            background: #333;
            color: #fff;
            border-radius: 6px;
            padding: 8px;
            font-size: 15px;
        }
        #chat-send-btn {
            background: #4B0000;
            color: #fff;
            border: none;
            border-radius: 6px;
            margin-left: 8px;
            padding: 8px 14px;
            font-size: 15px;
            cursor: pointer;
            transition: background 0.2s;
        }
        #chat-send-btn:hover {
            background: #800000;
        }
        #alias-prompt {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1002;
        }
        #alias-prompt input {
            padding: 10px;
            font-size: 16px;
            border-radius: 6px;
            border: none;
            margin-bottom: 12px;
        }
        #alias-prompt button {
            padding: 8px 18px;
            font-size: 15px;
            border-radius: 6px;
            border: none;
            background: #4B0000;
            color: #fff;
            cursor: pointer;
        }
        #change-alias-btn {
            position: fixed;
            top: 16px;
            left: 60px;
            width: 36px;
            height: 36px;
            background: #333;
            color: #fff;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            z-index: 22000;
            display: none;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            font-size: 16px;
            transition: background 0.2s;
        }
        #change-alias-btn:hover {
            background: #555;
        }
        
        #room-toggle-btn {
            position: fixed;
            top: 16px;
            left: 104px;
            width: 36px;
            height: 36px;
            background: #222;
            color: #fff;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            z-index: 22000;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            font-size: 16px;
            transition: background 0.2s;
        }
        #room-toggle-btn:hover {
            background: #444;
        }
        
        /* Estilos para el panel de personalización simple */
        #simple-panel.customization-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 1100px;
            max-width: 99vw;
            height: 700px;
            background: linear-gradient(135deg, rgba(20,20,20,0.98), rgba(30,30,30,0.98));
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            z-index: 31000; /* Siempre por encima del overlay */
            display: none;
            flex-direction: column;
            overflow: hidden;
            backdrop-filter: blur(20px);
            border: 2px solid #4B0000;
            pointer-events: auto;
        }
        
        #simple-panel .panel-header {
            background: linear-gradient(135deg, #4B0000, #800000);
            color: #fff;
            padding: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 2px solid #FFD700;
        }
        
        #simple-panel .panel-header > div {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        #simple-panel .panel-header > div span:first-child {
            font-size: 28px;
        }
        
        #simple-panel .panel-header > div span:last-child {
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        #simple-panel .panel-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            color: #eee;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            min-height: 0;
            min-width: 0;
        }
        
        #simple-panel .options-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        #simple-panel .preview-column {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        #simple-panel .option-section {
            padding: 8px;
            background: linear-gradient(135deg, rgba(40,40,40,0.8), rgba(50,50,50,0.8));
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            margin-bottom: 4px;
        }
        
        #simple-panel .section-title {
            margin: 0 0 8px 0;
            color: #FFD700;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        #simple-panel .section-title span:first-child {
            font-size: 16px;
        }
        
        #simple-panel .color-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
        }
        
        #simple-panel .preview-section {
            padding: 10px;
            background: linear-gradient(135deg, rgba(40,40,40,0.8), rgba(50,50,50,0.8));
            border-radius: 6px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            text-align: center;
        }
        
        #simple-panel .avatar-preview {
            width: 150px;
            height: 200px;
            margin: 0 auto;
            position: relative;
            background: linear-gradient(135deg, rgba(20,20,20,0.5), rgba(30,30,30,0.5));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #333;
        }
        
        #simple-panel .panel-footer {
            padding: 8px 10px;
            background: linear-gradient(135deg, rgba(34,34,34,0.95), rgba(44,44,44,0.95));
            border-top: 1px solid #333;
            display: flex;
            gap: 6px;
            justify-content: flex-end;
        }
        
        /* Estilos adicionales para elementos específicos */
        #simple-panel .close-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            padding: 6px;
            border-radius: 6px;
            transition: all 0.3s;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #simple-panel .section-icon {
            font-size: 16px;
        }

        #simple-panel #simple-alias-input {
            width: 100%;
            padding: 12px;
            font-size: 14px;
            border-radius: 6px;
            border: 2px solid #333;
            background: rgba(20,20,20,0.8);
            color: #fff;
            box-sizing: border-box;
            transition: all 0.3s;
            outline: none;
        }

        #simple-panel #simple-alias-input:focus {
            border-color: #FFD700;
        }

        #customization-actions {
            padding: 16px 20px;
            background: rgba(34,34,34,0.9);
            border-top: 1px solid #333;
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            width: 100%;
            min-height: 60px;
            box-sizing: border-box;
        }
        
        .customization-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        #save-customization-btn {
            background: linear-gradient(135deg, #4B0000, #800000);
            color: #fff;
        }
        
        #save-customization-btn:hover {
            background: linear-gradient(135deg, #800000, #B22222);
            transform: translateY(-1px);
        }
        
        #reset-customization-btn {
            background: #333;
            color: #ccc;
        }
        
        #reset-customization-btn:hover {
            background: #555;
            color: #fff;
        }
        
        /* Estilos para los botones de color */
        .color-option {
            width: 30px;
            height: 30px;
            border: 2px solid #333;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--color, #333);
        }
        .skin-options-grid {
            display: flex;
            gap: 12px;
            margin-bottom: 14px;
        }
        .skin-option {
            background: #222;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 4px;
            cursor: pointer;
            transition: border-color 0.2s, transform 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.10);
            width: 54px;
            height: 54px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .skin-option.selected {
            border-color: #FFD700;
            box-shadow: 0 0 0 3px #FFD70088;
            transform: scale(1.08);
        }
        .skin-option img {
            width: 40px;
            height: 40px;
            object-fit: contain;
            border-radius: 4px;
        }
        .color-option[data-color] {
            border: 2px solid #333;
        }
        .color-option:hover {
            border-color: #FFD700;
        }
        
        /* Animaciones para el panel */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        #simple-panel {
            animation: slideIn 0.3s ease-out;
        }
        
        /* Estilos para el input de alias */
        #simple-alias-input:focus {
            border-color: #FFD700 !important;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3) !important;
        }
        
        /* Estilos para los botones del footer */
        #simple-panel button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4) !important;
        }
        
        #simple-panel button:active {
            transform: translateY(0);
        }
        
        /* Controles móviles */
        #mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 10000;
            display: none;
            pointer-events: auto;
        }
        
        #mobile-controls .movement-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        /* Controles de rotación móviles (separados a la derecha) */
        #mobile-rotation-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            display: none;
            pointer-events: auto;
        }
        
        #mobile-rotation-controls .rotation-controls {
            display: flex;
            flex-direction: row;
            gap: 12px;
        }
        
        .mobile-btn {
            width: 70px;
            height: 70px;
            border: none;
            border-radius: 12px;
            background: rgba(75, 0, 0, 0.8);
            color: white;
            font-size: 28px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
            border: 3px solid rgba(255, 215, 0, 0.3);
        }
        
        .mobile-btn:hover {
            background: rgba(128, 0, 0, 0.9);
            transform: scale(1.05);
        }
        
        .mobile-btn:active {
            background: rgba(255, 215, 0, 0.8);
            transform: scale(0.95);
        }
        
        /* Botones triangulares */
        .mobile-btn.forward {
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
        }
        
        .mobile-btn.backward {
            clip-path: polygon(0% 0%, 100% 0%, 50% 100%);
        }
        
        .mobile-btn.left {
            clip-path: polygon(0% 50%, 100% 0%, 100% 100%);
        }
        
        .mobile-btn.right {
            clip-path: polygon(0% 0%, 0% 100%, 100% 50%);
        }
        
        /* Mostrar controles solo en móviles */
        @media (max-width: 768px) {
            #mobile-controls {
                display: block;
            }
            #mobile-rotation-controls {
                display: block;
            }
            .mobile-btn {
                width: 90px;
                height: 90px;
                font-size: 36px;
            }
        }
        .chat-message {
            padding: 6px 10px;
            border-radius: 8px;
            margin-bottom: 4px;
            background: rgba(40,40,40,0.7);
            display: inline-block;
            max-width: 90%;
            word-break: break-word;
        }
        .chat-message.own {
            background: linear-gradient(90deg, #FFD70033, #FFD70011);
        }
        /* Overlay para bloquear clics al fondo cuando el panel de personalización está abierto */
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.5);
            z-index: 20000; /* Debe estar debajo del panel de personalización */
            pointer-events: none; /* Solo se activa cuando el panel está abierto */
            display: none; /* Solo se muestra cuando el panel está abierto */
        }
        @media (max-width: 768px) {
            #chat-content {
                flex-direction: row;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                /* Permitir scroll horizontal solo en móviles */
            }
            #chat-main, #users-sidebar {
                min-width: 320px;
            }
            
            /* Responsive para paneles de habitación en móvil */
            #room-navigation-panel {
                width: 95vw !important;
                height: auto !important;
                max-height: 80vh !important;
                top: 50% !important;
                left: 50% !important;
                transform: translate(-50%, -50%) !important;
                border-radius: 16px !important;
            }
            
            #furniture-edit-panel {
                width: 95vw !important;
                height: auto !important;
                max-height: 80vh !important;
                top: 50% !important;
                right: auto !important;
                left: 50% !important;
                transform: translate(-50%, -50%) !important;
                border-radius: 16px !important;
            }
            
            /* Ajustar contenido interno para móvil */
            #room-navigation-panel > div:last-child {
                padding: 16px !important;
                max-height: 60vh !important;
                overflow-y: auto !important;
            }
            
            #furniture-edit-panel > div:last-child {
                padding: 16px !important;
                max-height: 60vh !important;
                overflow-y: auto !important;
            }
            
            /* Botones más pequeños en móvil */
            #room-navigation-panel button,
            #furniture-edit-panel button {
                padding: 12px !important;
                font-size: 16px !important;
                margin-bottom: 8px !important;
            }
            
            /* Texto más pequeño en móvil */
            #room-navigation-panel h3,
            #furniture-edit-panel h3 {
                font-size: 18px !important;
            }
            
            #room-navigation-panel p,
            #furniture-edit-panel p {
                font-size: 14px !important;
            }
            
            /* Lista de muebles más compacta en móvil */
            #furniture-list {
                max-height: 200px !important;
            }
            
            #furniture-list > div {
                padding: 8px !important;
                margin: 4px 0 !important;
                font-size: 14px !important;
            }
        }
    </style>
</head>
<body>
    <!-- Contenedor de UI completamente separado del canvas -->
    <div id="ui-container" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 30000;">
        <div id="ui-overlay"></div>
    <div id="crosshair"></div>
        <button id="chat-toggle-btn" title="Abrir chat" style="pointer-events: auto;">💬</button>
        <button id="change-alias-btn" title="Personalizar avatar" style="pointer-events: auto;">👤</button>
        <button id="room-toggle-btn" title="Mi habitación" style="pointer-events: auto;">🏠</button>
    </div>
    
    <!-- Panel de navegación de habitaciones -->
    <div id="room-navigation-panel" style="position: fixed; top: 60px; left: 16px; width: 450px; height: 600px; background: rgba(30,30,30,0.95); border-radius: 12px; box-shadow: 0 4px 24px rgba(0,0,0,0.4); z-index: 31000; display: none; flex-direction: column; overflow: hidden; backdrop-filter: blur(10px); pointer-events: auto;">
    
    <!-- Botón para regresar al mall desde la habitación -->
    <button id="return-to-mall-btn" title="Regresar al centro comercial" style="position: fixed; top: 16px; right: 16px; width: 36px; height: 36px; background: #4B0000; color: #fff; border: none; border-radius: 50%; cursor: pointer; z-index: 22000; display: none; align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(0,0,0,0.2); font-size: 16px; transition: background 0.2s; pointer-events: auto;">🏢</button>
    
    <!-- Panel de edición de muebles -->
    <div id="furniture-edit-panel" style="position: fixed; top: 60px; right: 16px; width: 380px; height: 500px; background: rgba(30,30,30,0.95); border-radius: 12px; box-shadow: 0 4px 24px rgba(0,0,0,0.4); z-index: 31000; display: none; flex-direction: column; overflow: hidden; backdrop-filter: blur(10px); pointer-events: auto;">
        <div style="background: rgba(24,24,24,0.9); color: #fff; padding: 12px 16px; font-weight: bold; display: flex; align-items: center; justify-content: space-between;">
            <span>🪑 Editar Muebles</span>
                            <button class="close-btn" style="background: none; border: none; color: #fff; font-size: 18px; cursor: pointer;">✖</button>
        </div>
        <div style="padding: 16px; color: #eee;">
            <div style="margin-bottom: 16px;">
                <h3 style="margin: 0 0 8px 0; color: #27AE60;">Modo de Edición</h3>
                <p style="margin: 0; font-size: 14px; color: #ccc;">Haz clic en un mueble para seleccionarlo y luego usa las teclas para moverlo.</p>
            </div>
            <div id="furniture-list" style="max-height: 300px; overflow-y: auto; margin-bottom: 16px;">
                <!-- Lista de muebles se generará dinámicamente -->
            </div>
            <div style="border-top: 1px solid #333; padding-top: 16px;">
                <h4 style="margin: 0 0 12px 0; color: #F39C12; font-size: 18px;">Controles:</h4>
                <p style="margin: 0 0 6px 0; font-size: 14px;">• WASD/Flechas: Mover mueble seleccionado</p>
                <p style="margin: 0 0 6px 0; font-size: 14px;">• R: Rotar mueble</p>
                <p style="margin: 0 0 6px 0; font-size: 14px;">• ESC: Deseleccionar</p>
                <p style="margin: 0; font-size: 14px;">• Enter: Guardar posición</p>
            </div>
        </div>
    </div>
        <div style="background: rgba(24,24,24,0.9); color: #fff; padding: 12px 16px; font-weight: bold; display: flex; align-items: center; justify-content: space-between;">
            <span>🏠 Mi Habitación</span>
                            <button class="close-btn" style="background: none; border: none; color: #fff; font-size: 18px; cursor: pointer;">✖</button>
        </div>
        <div style="padding: 20px; color: #eee;">
            <div style="margin-bottom: 24px;">
                <h3 style="margin: 0 0 12px 0; color: #FFD700; font-size: 20px;">Bienvenido a tu espacio personal</h3>
                <p style="margin: 0; font-size: 16px; color: #ccc; line-height: 1.5;">Aquí puedes personalizar tu habitación y relajarte en tu espacio privado.</p>
            </div>
            <button id="enter-room-btn" style="width: 100%; padding: 16px; background: linear-gradient(135deg, #4B0000, #800000); color: #fff; border: none; border-radius: 10px; font-size: 18px; font-weight: bold; cursor: pointer; transition: all 0.3s; margin-bottom: 12px;">🚪 Entrar a mi habitación</button>
            <button id="toggle-furniture-btn" style="width: 100%; padding: 16px; background: linear-gradient(135deg, #27AE60, #2ECC71); color: #fff; border: none; border-radius: 10px; font-size: 18px; font-weight: bold; cursor: pointer; transition: all 0.3s; margin-bottom: 12px;">🪑 Mover muebles</button>
            <button id="customize-room-btn" style="width: 100%; padding: 16px; background: linear-gradient(135deg, #333, #555); color: #fff; border: none; border-radius: 10px; font-size: 18px; font-weight: bold; cursor: pointer; transition: all 0.3s;">🎨 Personalizar habitación</button>
        </div>
    </div>
    
    <!-- Contenedor para ventanas de chats privados -->
    <div id="private-chats-container" style="position:fixed; bottom:20px; right:20px; z-index:40000; pointer-events:none;"></div>
    
    <!-- Controles móviles -->
    <div id="mobile-controls">
        <div class="movement-controls">
            <button class="mobile-btn forward" id="mobile-forward" title="Mover adelante">▲</button>
            <button class="mobile-btn backward" id="mobile-backward" title="Mover atrás">▼</button>
        </div>
    </div>
    
    <!-- Controles de rotación móviles (separados a la derecha) -->
    <div id="mobile-rotation-controls">
        <div class="rotation-controls">
            <button class="mobile-btn left" id="mobile-left" title="Rotar izquierda">◀</button>
            <button class="mobile-btn right" id="mobile-right" title="Rotar derecha">▶</button>
        </div>
    </div>
        <!-- Panel de personalización completamente rediseñado -->
    <div id="simple-panel" class="customization-panel">
        <!-- Header elegante -->
        <div class="panel-header">
            <div>
                <span>👤</span>
                <span>Personalizar Avatar</span>
            </div>
                            <button class="close-btn">✖</button>
        </div>
        
        <!-- Contenido principal -->
        <div class="panel-content">
            <div class="options-column" style="width:100%;align-items:center;justify-content:center;">
                <div class="option-section" style="display: flex; flex-direction: column; align-items: center; gap: 24px; margin-top: 24px;">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <button id="skin-prev-btn" class="skin-arrow-btn" title="Anterior" style="font-size: 28px; background: none; border: none; color: #FFD700; cursor: pointer;">◀</button>
                        <div id="skin-preview-container" style="display: flex; flex-direction: column; align-items: center;">
                            <img id="skin-preview-img" src="assets/kenney 3d characters/Skins/humanMaleA.png" alt="Skin Preview" style="width: 64px; height: 64px; object-fit: contain; border-radius: 10px; border: 2px solid #FFD700; background: #222; box-shadow: 0 2px 8px rgba(0,0,0,0.2); margin-bottom: 8px;" />
                            <div id="skin-preview-label" style="color: #FFD700; font-size: 14px; font-weight: bold; text-align: center; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">Humano Masculino</div>
                </div>
                        <button id="skin-next-btn" class="skin-arrow-btn" title="Siguiente" style="font-size: 28px; background: none; border: none; color: #FFD700; cursor: pointer;">▶</button>
                    </div>
                </div>
                <div class="option-section" style="margin-top: 32px; width: 100%;">
                    <h3 class="section-title" style="margin-bottom: 8px; text-align:center;">
                        <span class="section-icon">📝</span>
                        Nombre del Avatar
                    </h3>
                    <input type="text" id="simple-alias-input" placeholder="Escribe tu nombre..." maxlength="20" style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #FFD700; background: #232323; color: #FFD700; font-size: 16px; font-weight: bold; text-align: center;">
                    </div>
                </div>
                    </div>
        <div class="panel-footer">
            <button id="reset-customization-btn" style="padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; background: linear-gradient(135deg, #555, #777); color: #fff; transition: all 0.3s; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">🔄 Restablecer</button>
            <button id="save-customization-btn" style="padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; background: linear-gradient(135deg, #4B0000, #800000); color: #fff; transition: all 0.3s; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">💾 Guardar</button>
        </div>
    </div>
    <div id="chat-panel">
        <div id="chat-header">
            Chat
            <button id="chat-close-btn" title="Cerrar">✖</button>
        </div>
        <div id="chat-content">
            <div id="chat-main">
                <div id="chat-messages"></div>
                <div id="chat-input-area">
                    <button id="emoji-toggle" title="Emojis">😊</button>
                    <input id="chat-input" type="text" placeholder="Escribe un mensaje..." autocomplete="off" />
                    <button id="chat-send-btn">Enviar</button>
                </div>
                <div id="emoji-panel"></div>
            </div>
            <div id="users-sidebar">
                <div id="users-title">Usuarios</div>
                <div id="users-list"></div>
            </div>
        </div>
    </div>
    
    <!-- Panel de personalización de avatar -->
    <!-- Eliminado: <div id="customization-panel">...</div> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.4/umd/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.min.js"></script>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="/firebase-config.js"></script>
    <script>
        // URLs de las tiendas proporcionadas por el usuario (duplicadas para llenar todos los pisos)
        const originalStoreLinks = [
            "https://www.ipweb.pro/en/?Davincho88", "https://ipgold.biz/?r=meramente42@gmail.com", "https://surfe.be/ext/2837287",
            "https://sproutgigs.com/?a=0675642e", "https://r.adbtc.top/2847448", "https://www.coinpayu.com/?r=everest101",
            "https://surfio.site/i/794", "https://serfclick.net/i/277142", "https://faucetcrypto.com/r/1373767",
            "https://earnbitmoon.club/?ref=1075373", "https://viefaucet.com?r=6383ddeaec6d7776fc69e555", "https://simplebits.io/ref/OLkiv6stfLj_",
            "https://tap-coin.de/refer/user/4365", "https://btcadspace.com/ref/p4ch3c0", "https://trustdice.win/faucet/?ref=u_mapachox101",
            "http://cointiply.com/r/4yDJAp", "https://autofaucet.dutchycorp.space/?r=sakreto", "https://freebitco.in/?r=49843181",
            "https://faucetpay.io/?r=2136351", "https://r.honeygain.me/MERAM588A9", "https://pawns.app/?r=585883",
            "https://teaserfast.ru/u/mapachox", "https://addon.money/p/343495", "https://everve.net/ref/961754/",
            "https://swashapp.io/download?referral_code=3opl7k4ztf53", "https://addslice.com/?crew=JHVJ6", "https://earnapp.com/i/4zbftm2",
            "https://node.optimai.network/register?ref=F471454F", "https://dashboard.teneo.pro/auth/signup?referralCode=ERPr2", "https://app.nodepay.ai/register?ref=kOYHwfDuFNSSZg2",
            "https://www.jumptask.io/r/budapygirazu", "https://payeer.com/?partner=23994523", "https://rollercoin.com/?r=m9dnpgsp",
            "https://bux.money/u/239006", "https://www.swagbucks.com/p/register?rb=119244201&rp=1", "https://app.getgrass.io/register?referralCode=SwWRadefuICY8DI",
            "https://freecash.com/r/116249823271721789104", "https://r.honeygain.me/AIRRIFADB7", "https://www.binance.com/referral/earn-together/refertoearn2000usdc/claim?hl=en&ref=GRO_14352_ZBFKF",
            "https://www.paidwork.com/?r=meramente42", "https://www.bybit.com/invite?ref=VWN6NL", "https://app-earnings-link.com/givvyMusic/hoty216dfkvisgv",
            "https://swcapp.com/i/davehz", "https://app-earnings-link.com/givvyStream/a6dd8fsmn6t6qhfjjw5", "https://app-earnings-link.com/givvyScratchCardNew/euz9t4x3bmk6"
        ];

        // Mapeo de dominios a nombres de archivo de logos
        const domainToLogoMap = {
            'ipweb': 'ipweb-logo.png',
            'ipgold': 'ipgold-logo.png',
            'surfe': 'surfe-logo.png',
            'sproutgigs': 'sproutgigs-logo.png',
            'adbtc': 'adbtc-logo.png',
            'coinpayu': 'coinpayu-logo.png',
            'surfio': 'surfio-logo.png',
            'serfclick': 'serfclick-logo.png',
            'faucetcrypto': 'faucetcrypto-logo.png',
            'earnbitmoon': 'earnbitmoon-logo.png',
            'viefaucet': 'viefaucet-logo.png',
            'simplebits': 'simplebits-logo.png',
            'tap-coin': 'tapcoin-logo.png',
            'btcadspace': 'btcadspace-logo.png',
            'trustdice': 'trustdice-logo.png',
            'cointiply': 'cointiply-logo.png',
            'autofaucet': 'autofaucet-logo.png',
            'freebitco': 'freebitcoin-logo.png',
            'faucetpay': 'faucetpay-logo.png',
            'honeygain': 'honeygain-logo.png',
            'pawns': 'pawns-logo.png',
            'teaserfast': 'teaserfast-logo.png',
            'addon': 'addonmoney-logo.png',
            'everve': 'everve-logo.png',
            'swashapp': 'swash-logo.png',
            'addslice': 'addslice-logo.png',
            'earnapp': 'earnapp-logo.png',
            'optimai': 'optimai-logo.png',
            'teneo': 'teneo-logo.png',
            'nodepay': 'nodepay-logo.png',
            'jumptask': 'jumptask-logo.png',
            'payeer': 'payeer-logo.png',
            'rollercoin': 'rollercoin-logo.png',
            'bux': 'buxmoney-logo.png',
            'swagbucks': 'swagbucks-logo.png',
            'grass': 'grass-logo.png',
            'getgrass': 'grass-logo.png', // Agregar alias para app.getgrass.io
            'freecash': 'freecash-logo.png',
            'binance': 'binance-logo.png',
            'paidwork': 'paidwork-logo.png',
            'bybit': 'bybit-logo.png',
            'givvyMusic': 'givvymusic-logo.png',
            'givvyStream': 'givvystream-logo.png',
            'givvyScratchCardNew': 'givvystream-logo.png', // Usar givvystream como fallback
            'swcapp': 'swcapp-logo.png',
            'app-earnings-link': 'givvystream-logo.png' // Agregar alias para app-earnings-link.com
        };

        // Duplicar los enlaces 5 veces para asegurar que hay suficientes para todos los pisos
        const storeLinks = [];
        for (let i = 0; i < 5; i++) {
            storeLinks.push(...originalStoreLinks);
        }

        // --- Constantes y Configuración Global ---
        const HALL_SIZE = 90; // Aumentado 1.5 veces (60 * 1.5 = 90)
        const HALL_HEIGHT = 4;
        const MOVE_SPEED = 0.8;
        const ROTATE_SPEED = 0.1;
        const CAMERA_HEIGHT = 1.6;
        const MAX_FLOOR = 1; // Cambiado de 4 a 1 (solo 2 pisos: planta baja + 1 piso superior)
        const MIN_FLOOR = 0;
        // --- Dimensiones globales de la habitación personal ---
        const roomWidth = 12, roomHeight = 3.5, roomDepth = 12;

        // --- SISTEMA DE ESTADO CENTRALIZADO ---
        
        // Estado del juego
        const gameState = {
            // Escena actual
            currentScene: 'mall', // 'mall' o 'personal-room'
            
            // Posición y movimiento del jugador
            player: {
                position: { x: 0, y: 0, z: 0 },
                targetPosition: { x: 0, y: 0, z: 0 },
                rotation: 0,
                targetRotation: 0,
                floor: 0,
                isMoving: false
            },
            
            // Sistema de tiendas
            shopCounter: 1,
            
            // Estado de muebles
            furniture: {
                editMode: false,
                selected: null,
                objects: []
            }
        };
        
        // Estado de la UI
        const uiState = {
            // Paneles activos
            activePanel: null, // 'chat', 'customization', 'room', 'furniture'
            overlayVisible: false,
            
            // Estados específicos de paneles
            customization: {
                panelOpen: false,
                colors: [
                    0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFFEAA7, 0xDDA0DD,
                    0x98D8C8, 0xF7DC6F, 0xBB8FCE, 0x85C1E9, 0xF8C471, 0x82E0AA,
                    0xF1948A, 0xD7BDE2, 0xF9E79F, 0xABEBC6, 0xFAD7A0, 0xAED6F1,
                    0x2C3E50, 0x34495E, 0x8B4513, 0x654321, 0x2F4F4F, 0x696969,
                    0x556B2F, 0x8B0000, 0x4B0082, 0x191970, 0x006400, 0x8B4513,
                    0x654321, 0x2F4F4F, 0x696969, 0x556B2F, 0x8B0000, 0x4B0082,
                    0x8B4513, 0x654321, 0x000000, 0x2F4F4F, 0x696969, 0x8B0000,
                    0x4B0082, 0x191970, 0x006400, 0x8B4513, 0x654321, 0x2F4F4F,
                    0x696969, 0x556B2F, 0x8B0000, 0x4B0082, 0x191970, 0x006400
                ]
            },
            
            room: {
                navigationPanelOpen: false
            },
            
            furniture: {
                editPanelOpen: false
            }
        };
        
        // Estado de entrada del usuario
        const inputState = {
            // Teclado
            keyboard: {
                W: false, S: false, A: false, D: false,
                ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false
            },
            
            // Controles móviles
            mobile: {
                forward: false,
                backward: false,
                left: false,
                right: false
            }
        };
        
        // Estado de personalización del avatar
        const avatarState = {
            // Objeto de personalización actual (sistema unificado)
            currentCustomization: {
                shirtColor: 0x4ECDC4,
                pantsColor: 0x2C3E50,
                shoesColor: 0x8B4513,
                skin: 'humanMaleA'
            },
            
            // Colores predefinidos para selección
            predefinedColors: [
                { shirt: 0x4ECDC4, pants: 0x2C3E50, shoes: 0x8B4513 },
                { shirt: 0xE74C3C, pants: 0x34495E, shoes: 0x2C3E50 },
                { shirt: 0x3498DB, pants: 0x2980B9, shoes: 0x1F618D },
                { shirt: 0xF39C12, pants: 0xE67E22, shoes: 0xD35400 },
                { shirt: 0x9B59B6, pants: 0x8E44AD, shoes: 0x6C3483 }
            ],
            
            // Colores disponibles para personalización
            customizationColors: [
            // Colores vibrantes para camisas
            0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFFEAA7, 0xDDA0DD,
            0x98D8C8, 0xF7DC6F, 0xBB8FCE, 0x85C1E9, 0xF8C471, 0x82E0AA,
            0xF1948A, 0xD7BDE2, 0xF9E79F, 0xABEBC6, 0xFAD7A0, 0xAED6F1,
            // Colores más oscuros para pantalones
            0x2C3E50, 0x34495E, 0x8B4513, 0x654321, 0x2F4F4F, 0x696969,
            0x556B2F, 0x8B0000, 0x4B0082, 0x191970, 0x006400, 0x8B4513,
            0x654321, 0x2F4F4F, 0x696969, 0x556B2F, 0x8B0000, 0x4B0082,
            // Colores para zapatos
            0x8B4513, 0x654321, 0x000000, 0x2F4F4F, 0x696969, 0x8B0000,
            0x4B0082, 0x191970, 0x006400, 0x8B4513, 0x654321, 0x2F4F4F,
            0x696969, 0x556B2F, 0x8B0000, 0x4B0082, 0x191970, 0x006400
            ]
        };
        
        // Hacer avatarState accesible globalmente para Firebase
        window.avatarState = avatarState;
        
        // Estado del sistema de renderizado
        const renderState = {
            scene: null,
            camera: null,
            renderer: null,
            personalRoom: {
                scene: null,
                camera: null,
                renderer: null,
                targetPosition: { x: 0, y: 0, z: 0 },
                targetRotation: 0
            }
        };
        
        // Estado del sistema de animación
        const animationState = {
            clock: new THREE.Clock(),
            lastTime: 0,
            frameCount: 0,
            fps: 60,
            targetFPS: 60,
            frameInterval: 1000 / 60
        };
        
        // Estado del sistema de timing
        const timingState = {
            lastSkyUpdate: 0,
            lastPositionUpdate: 0,
            lastRotatingSignUpdate: 0,
            lastClockUpdate: 0,
            
            intervals: {
                SKY: 60000,        // 1 minuto
                POSITION: 500,     // 500ms
                ROTATING_SIGN: 2500, // 2.5 segundos
                CLOCK: 1000        // 1 segundo
            }
        };
        
        // Colecciones del juego
        const gameCollections = {
            userAvatars: new Map(), // Mapa de alias -> avatar
            clickableObjects: [],
            collisionObjects: [],
            rotatingSigns: [],
            digitalClocks: [],
            rotatingSignTextIndexes: {}
        };
        
        // Sistema de raycasting
        const raycastSystem = {
            raycaster: new THREE.Raycaster(),
            mouse: new THREE.Vector2()
        };
        
        // Sistema de cache
        const cacheSystem = {
            materialCache: new Map(),
            textureCache: new Map(),
            logoTextureCache: new Map()
        };
        
        // Sistema de timing centralizado
        const timingSystem = {
            shouldUpdate: (lastUpdate, interval) => {
                return Date.now() - lastUpdate >= interval;
            },
            updateLastTime: (type) => {
                switch(type) {
                    case 'SKY': timingState.lastSkyUpdate = Date.now(); break;
                    case 'POSITION': timingState.lastPositionUpdate = Date.now(); break;
                    case 'ROTATING_SIGN': timingState.lastRotatingSignUpdate = Date.now(); break;
                    case 'CLOCK': timingState.lastClockUpdate = Date.now(); break;
                }
            }
        };

        // Función para obtener el siguiente número de tienda
        const getNextShopNumber = () => {
            return gameState.shopCounter++;
        };

        function getCachedMaterial(color, roughness = 0.8, metalness = 0.2) {
            const key = `${color}-${roughness}-${metalness}`;
            if (!cacheSystem.materialCache.has(key)) {
                cacheSystem.materialCache.set(key, new THREE.MeshStandardMaterial({ 
                    color, 
                    roughness, 
                    metalness 
                }));
            }
            return cacheSystem.materialCache.get(key);
        }

        function getCachedTexture(text, colorIdx, width, height) {
            const key = `${text}-${colorIdx}-${width}-${height}`;
            if (!cacheSystem.textureCache.has(key)) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const canvasW = Math.min(512, width * 64); // Reducir tamaño del canvas
                const canvasH = Math.min(512, height * 64);
                canvas.width = canvasW;
                canvas.height = canvasH;
                
                context.fillStyle = `hsl(${colorIdx * 47 % 360}, 60%, 50%)`;
                context.fillRect(0, 0, canvasW, canvasH);
                
                context.font = `bold ${canvasH * 0.3}px Arial`;
                context.fillStyle = 'white';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text.charAt(0).toUpperCase() + text.slice(1), canvasW / 2, canvasH / 2);

                const texture = new THREE.CanvasTexture(canvas);
                cacheSystem.textureCache.set(key, texture);
            }
            return cacheSystem.textureCache.get(key);
        }

        // --- Función para obtener el color del cielo según la hora ---
        function getSkyColor() {
            const now = new Date();
            const hour = now.getHours();
            
            // Transiciones suaves entre colores según la hora
            if (hour >= 6 && hour < 12) {
                // Mañana: azul claro
                return new THREE.Color(0x87CEEB); // Sky blue
            } else if (hour >= 12 && hour < 18) {
                // Tarde: azul más intenso
                return new THREE.Color(0x4682B4); // Steel blue
            } else if (hour >= 18 && hour < 20) {
                // Atardecer: naranja/rosa
                return new THREE.Color(0xFF7F50); // Coral
            } else if (hour >= 20 && hour < 22) {
                // Anochecer: azul oscuro
                return new THREE.Color(0x191970); // Midnight blue
            } else {
                // Noche: negro
                return new THREE.Color(0x000000); // Black
            }
        }

        function init() {
            // --- Configuración de la Escena, Cámara y Renderer ---
            setupScene();
            setupLighting();
            createMall();

            // --- Event Listeners ---
            setupEventListeners();
            
            // --- Configurar event listeners centralizados ---
            setupEventListeners();

            // --- Iniciar Animación ---
            animate();
        }

        function setupScene() {
            scene = new THREE.Scene();
            scene.background = getSkyColor(); // Color dinámico del cielo
            scene.fog = new THREE.Fog(0x1a1a1a, 15, 105); // Ajustado para el nuevo tamaño

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(25, CAMERA_HEIGHT, 25); // Posición más cerca del centro
            camera.lookAt(HALL_SIZE / 2, CAMERA_HEIGHT, HALL_SIZE / 2);

            targetPosition = camera.position.clone();
            targetRotationY = camera.rotation.y;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limitar pixel ratio
            renderer.shadowMap.enabled = false; // Desactivar sombras completamente
            renderer.domElement.style.zIndex = '1'; // Asegurar que el canvas esté por debajo de la UI
            document.body.appendChild(renderer.domElement);
        }

        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // Aumentar intensidad para compensar falta de sombras
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); // Reducir intensidad
            directionalLight.position.set(30, 45, 15); // Ajustado para el nuevo tamaño
            directionalLight.castShadow = false; // Desactivar sombras
            scene.add(directionalLight);
        }

        function createMall() {
            // --- Materiales ---
            const floorMaterial = getCachedMaterial(0x444444, 0.8, 0.2);
            const wallMaterial = getCachedMaterial(0x6B8E23, 0.9); // Verde oliva
            const separatorMaterial = getCachedMaterial(0xFFFFFF, 0.9); // Blanco para muros separadores

            // --- Creación del Centro Comercial ---
            let linkIndex = 0;
            
            // Planta baja con tiendas
            linkIndex = createFloorLevel(0, floorMaterial, wallMaterial, separatorMaterial, linkIndex);
            
            // Solo un piso superior con tiendas y pasillos (piso 1)
            const floorY = 1 * (HALL_HEIGHT + 1);
            linkIndex = createUpperFloorLevel(floorY, floorMaterial, wallMaterial, separatorMaterial, linkIndex);

            // --- Estructura Central completa ---
            const centralStructureY = 0;
            const cubeSize = 6;
            createCentralCubeScreens(HALL_SIZE / 2, centralStructureY, HALL_SIZE / 2, cubeSize, storeLinks.slice(0, 4), 0, 2500);
            createCentralCubeScreens(HALL_SIZE / 2, centralStructureY + cubeSize * 0.8, HALL_SIZE / 2, cubeSize, storeLinks.slice(4, 8), 100, 2000);
            createCentralCubeScreens(HALL_SIZE / 2, centralStructureY + cubeSize * 1.6, HALL_SIZE / 2, cubeSize, storeLinks.slice(8, 12), 200, 1800);
            const clockCubeY = centralStructureY + cubeSize * 2.4;
            createDigitalClockCube(HALL_SIZE / 2, clockCubeY, HALL_SIZE / 2, cubeSize);

            // Cúpula
            const pyramidHeight = cubeSize * 1.5;
            const pyramidGeometry = new THREE.ConeGeometry(cubeSize / Math.SQRT2 * 1.2, pyramidHeight, 4);
            const pyramidMaterial = getCachedMaterial(0xA0522D, 0.8, 0.1); // Sienna
            const pyramid = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
            pyramid.position.set(HALL_SIZE / 2, clockCubeY + cubeSize * 0.8 + pyramidHeight / 2, HALL_SIZE / 2);
            pyramid.rotation.y = Math.PI / 4;
            // pyramid.castShadow = false; // Desactivar sombras para mejor rendimiento
            // pyramid.receiveShadow = true;
            scene.add(pyramid);

            // Crear área de descanso completa (restaurar 8 mesas)
            const gardenRadius = 8;
            const tableCount = 8; // Restaurar 8 mesas
            
            for (let i = 0; i < tableCount; i++) {
                const angle = (i / tableCount) * Math.PI * 2;
                const radius = gardenRadius + Math.random() * 2 - 1; // Variación en el radio
                
                // Crear mesa
                const tableTopGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.1, 8);
                const tableTopMaterial = getCachedMaterial(new THREE.Color().setHSL(0.1, 0.3, 0.7));
                const tableTop = new THREE.Mesh(tableTopGeometry, tableTopMaterial);
                
                // Patas de la mesa
                const tableLegGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.7, 6);
                const tableLegMaterial = getCachedMaterial(new THREE.Color().setHSL(0.05, 0.2, 0.5));
                
                // Posicionar mesa
                const tableX = HALL_SIZE / 2 + Math.cos(angle) * radius;
                const tableZ = HALL_SIZE / 2 + Math.sin(angle) * radius;
                
                tableTop.position.set(tableX, 0.85, tableZ);
                // tableTop.castShadow = false; // Desactivar sombras para mejor rendimiento
                // tableTop.receiveShadow = true;
                scene.add(tableTop);
                
                // Agregar 4 patas a la mesa
                for (let j = 0; j < 4; j++) {
                    const legAngle = (j / 4) * Math.PI * 2;
                    const legRadius = 0.6;
                    const leg = new THREE.Mesh(tableLegGeometry, tableLegMaterial);
                    leg.position.set(
                        tableX + Math.cos(legAngle) * legRadius,
                        0.35,
                        tableZ + Math.sin(legAngle) * legRadius
                    );
                    // leg.castShadow = false; // Desactivar sombras para mejor rendimiento
                    // leg.receiveShadow = true;
                    scene.add(leg);
                }
                
                // Crear parasol sobre la mesa
                const parasolPoleGeometry = new THREE.CylinderGeometry(0.03, 0.03, 2.5, 6);
                const parasolPoleMaterial = getCachedMaterial(new THREE.Color().setHSL(0.05, 0.2, 0.5));
                const parasolPole = new THREE.Mesh(parasolPoleGeometry, parasolPoleMaterial);
                parasolPole.position.set(tableX, 2.1, tableZ);
                // parasolPole.castShadow = false; // Desactivar sombras para mejor rendimiento
                // parasolPole.receiveShadow = true;
                scene.add(parasolPole);
                
                // Tela del parasol
                const parasolGeometry = new THREE.ConeGeometry(1.2, 0.3, 8);
                const parasolMaterial = getCachedMaterial(0x000080); // Azul oscuro
                const parasol = new THREE.Mesh(parasolGeometry, parasolMaterial);
                parasol.position.set(tableX, 3.25, tableZ);
                parasol.rotation.x = 0; // Quitar la rotación para que apunte hacia arriba (invertido)
                // parasol.castShadow = false; // Desactivar sombras para mejor rendimiento
                // parasol.receiveShadow = true;
                scene.add(parasol);
                
                // Crear sillas completas (restaurar 4 sillas por mesa)
                const chairCount = 4; // Restaurar 4 sillas
                for (let k = 0; k < chairCount; k++) {
                    // Posicionar sillas en los 4 puntos cardinales alrededor de la mesa
                    const chairAngle = (k / chairCount) * Math.PI * 2; // 0°, 90°, 180°, 270°
                    const chairRadius = 1.8; // Distancia fija desde la mesa
                    
                    // Asiento de la silla
                    const seatGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.4);
                    const seatMaterial = getCachedMaterial(new THREE.Color().setHSL(0.08, 0.4, 0.6));
                    const seat = new THREE.Mesh(seatGeometry, seatMaterial);
                    
                    const chairX = tableX + Math.cos(chairAngle) * chairRadius;
                    const chairZ = tableZ + Math.sin(chairAngle) * chairRadius;
                    
                    seat.position.set(chairX, 0.45, chairZ);
                    // seat.castShadow = false; // Desactivar sombras para mejor rendimiento
                    // seat.receiveShadow = true;
                    scene.add(seat);
                    

                    
                    // Patas de la silla
                    for (let l = 0; l < 4; l++) {
                        const chairLegGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.45, 6);
                        const chairLegMaterial = getCachedMaterial(new THREE.Color().setHSL(0.05, 0.2, 0.5));
                        const chairLeg = new THREE.Mesh(chairLegGeometry, chairLegMaterial);
                        
                        const legOffsetX = (l % 2 === 0 ? -1 : 1) * 0.15;
                        const legOffsetZ = (l < 2 ? -1 : 1) * 0.15;
                        
                        chairLeg.position.set(chairX + legOffsetX, 0.225, chairZ + legOffsetZ);
                        // chairLeg.castShadow = false; // Desactivar sombras para mejor rendimiento
                        // chairLeg.receiveShadow = true;
                        scene.add(chairLeg);
                    }
                }
            }
        }

        // --- Función refactorizada para crear filas de tiendas ---
        function createStoreRow(axis, position, count, storeWidth, storeSpacing, initialOffset, yOffset, wallMaterial, startLinkIndex, isCornerPosition) {
            let linkIndex = startLinkIndex;
            const stores = [];
            
            // Configuración según el eje
            const config = {
                'north': {
                    position: (i) => new THREE.Vector3(initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2, yOffset + HALL_HEIGHT / 2, position),
                    rotation: 0,
                    direction: 1, // izquierda a derecha
                    skipCorners: true
                },
                'south': {
                    position: (i) => new THREE.Vector3(initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2, yOffset + HALL_HEIGHT / 2, position),
                    rotation: Math.PI,
                    direction: -1, // derecha a izquierda
                    skipCorners: true
                },
                'east': {
                    position: (i) => new THREE.Vector3(position, yOffset + HALL_HEIGHT / 2, initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2),
                    rotation: -Math.PI / 2,
                    direction: 1, // arriba hacia abajo
                    skipCorners: true
                },
                'west': {
                    position: (i) => new THREE.Vector3(position, yOffset + HALL_HEIGHT / 2, initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2),
                    rotation: Math.PI / 2,
                    direction: -1, // abajo hacia arriba
                    skipCorners: true
                }
            };
            
            const axisConfig = config[axis];
            if (!axisConfig) return { linkIndex, stores };
            
            const start = axisConfig.direction > 0 ? 0 : count - 1;
            const end = axisConfig.direction > 0 ? count : -1;
            const step = axisConfig.direction;
            
            for (let i = start; i !== end; i += step) {
                if (axisConfig.skipCorners && isCornerPosition(i, axis)) continue;
                
                const storePos = axisConfig.position(i);
                const currentLinkIndex = linkIndex % storeLinks.length;
                
                const store = createStore(
                    storePos,
                    new THREE.Vector2(storeWidth, HALL_HEIGHT),
                    axisConfig.rotation,
                    currentLinkIndex,
                    12, // storeDepth
                    wallMaterial,
                    yOffset,
                    getNextShopNumber()
                );
                
                stores.push(store);
                linkIndex++;
            }
            
            return { linkIndex, stores };
        }

        // --- Función refactorizada para crear muros separadores ---
        function createSeparatorWalls(axis, position, count, storeWidth, storeSpacing, initialOffset, yOffset, separatorMaterial) {
            const walls = [];
            
            // Configuración según el eje
            const config = {
                'north': {
                    geometry: () => new THREE.BoxGeometry(storeSpacing, HALL_HEIGHT + 1, 0.2),
                    position: (i) => new THREE.Vector3(initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2, yOffset + (HALL_HEIGHT + 1) / 2, position)
                },
                'south': {
                    geometry: () => new THREE.BoxGeometry(storeSpacing, HALL_HEIGHT + 1, 0.2),
                    position: (i) => new THREE.Vector3(initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2, yOffset + (HALL_HEIGHT + 1) / 2, position)
                },
                'east': {
                    geometry: () => new THREE.BoxGeometry(0.2, HALL_HEIGHT + 1, storeSpacing),
                    position: (i) => new THREE.Vector3(position, yOffset + (HALL_HEIGHT + 1) / 2, initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2)
                },
                'west': {
                    geometry: () => new THREE.BoxGeometry(0.2, HALL_HEIGHT + 1, storeSpacing),
                    position: (i) => new THREE.Vector3(position, yOffset + (HALL_HEIGHT + 1) / 2, initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2)
                }
            };
            
            const axisConfig = config[axis];
            if (!axisConfig) return walls;
            
            for (let i = 0; i < count - 1; i++) {
                const wall = new THREE.Mesh(axisConfig.geometry(), separatorMaterial);
                wall.position.copy(axisConfig.position(i));
                scene.add(wall);
                gameCollections.collisionObjects.push(new THREE.Box3().setFromObject(wall));
                walls.push(wall);
            }
            
            return walls;
        }

        function createFloorLevel(yOffset, floorMaterial, wallMaterial, separatorMaterial, startLinkIndex) {
            // --- Suelo con textura de madera realista ---
            // Crear textura de madera usando canvas
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Configuración de la textura de madera
            const boardWidth = 64; // Ancho de cada tabla de madera
            const boardHeight = 512; // Altura de cada tabla
            const numBoards = 8; // Número de tablas de madera
            
            // Color único de madera
            const woodColor = '#8B4513'; // Saddle Brown - tono uniforme
            
            // Crear patrón de tablas de madera organizadas
            for (let i = 0; i < numBoards; i++) {
                const x = i * boardWidth;
                
                // Color base de la tabla (mismo para todas)
                ctx.fillStyle = woodColor;
                ctx.fillRect(x, 0, boardWidth, boardHeight);
                
                // Agregar vetas de madera organizadas
                ctx.strokeStyle = '#654321'; // Color más oscuro para las vetas
                ctx.lineWidth = 1;
                
                // Vetas horizontales organizadas (espaciado uniforme)
                for (let v = 0; v < 20; v++) {
                    const y = v * 25 + 12; // Espaciado uniforme sin variación aleatoria
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + boardWidth, y);
                    ctx.stroke();
                }
                
                // Vetas verticales organizadas (espaciado uniforme)
                ctx.strokeStyle = '#5D4037';
                ctx.lineWidth = 0.5;
                for (let v = 0; v < 5; v++) {
                    const vx = x + v * 15 + 8; // Espaciado uniforme sin variación aleatoria
                    ctx.beginPath();
                    ctx.moveTo(vx, 0);
                    ctx.lineTo(vx, boardHeight);
                    ctx.stroke();
                }
                
                // Agregar variación sutil de color para realismo (mismo tono)
                ctx.fillStyle = 'rgba(139, 69, 19, 0.1)';
                ctx.fillRect(x, 0, boardWidth, boardHeight);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 2); // Repetir la textura para cubrir el área
            
            const woodFloorMaterial = new THREE.MeshStandardMaterial({ 
                map: texture,
                roughness: 0.7, 
                metalness: 0.0,
                bumpMap: texture,
                bumpScale: 0.1
            });
            
            // Calcular el tamaño del área central (sin tiendas ni corredores)
            const storeDepth = 12;
            const corridorWidth = 8;
            const sueloOffset = corridorWidth / 2;
            // Hacer el área central más pequeña para que se vea mejor la separación
            const areaCentralSize = HALL_SIZE - 2 * (storeDepth + sueloOffset + 4); // Agregar 4 unidades más de margen
            
            // Crear suelo de madera solo para el área central
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(areaCentralSize, areaCentralSize), woodFloorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(HALL_SIZE / 2, yOffset, HALL_SIZE / 2);
            floor.receiveShadow = true;
            scene.add(floor);
            gameCollections.collisionObjects.push(new THREE.Box3().setFromObject(floor));

            // --- Tiendas ---
            const storeWidth = 8; // Reducido para que las tiendas sean más estrechas
            const storeSpacing = 1.5; // Espaciado ajustado para un balance entre densidad y espacio
            const numStoresPerSide = Math.floor(HALL_SIZE / (storeWidth + storeSpacing));
            const totalStoresWidth = numStoresPerSide * storeWidth + (numStoresPerSide - 1) * storeSpacing;
            const initialOffset = (HALL_SIZE - totalStoresWidth) / 2;
            let linkIndex = startLinkIndex;

            // Función para verificar si una posición está en una esquina
            const isCornerPosition = (index, side) => {
                // Saltar solo la primera y la última tienda de cada lado
                return index === 0 || index === numStoresPerSide - 1;
            };

            // Crear tiendas usando la función refactorizada
            const storePositions = {
                north: storeDepth / 2,
                south: HALL_SIZE - storeDepth / 2,
                east: HALL_SIZE - storeDepth / 2,
                west: storeDepth / 2
            };
            
            // Crear tiendas en sentido horario: Norte -> Este -> Sur -> Oeste
            let currentLinkIndex = linkIndex;
            
            // Norte
            const northResult = createStoreRow('north', storePositions.north, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, wallMaterial, currentLinkIndex, isCornerPosition);
            currentLinkIndex = northResult.linkIndex;
            
            // Este
            const eastResult = createStoreRow('east', storePositions.east, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, wallMaterial, currentLinkIndex, isCornerPosition);
            currentLinkIndex = eastResult.linkIndex;

            // Sur
            const southResult = createStoreRow('south', storePositions.south, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, wallMaterial, currentLinkIndex, isCornerPosition);
            currentLinkIndex = southResult.linkIndex;

            // Oeste
            const westResult = createStoreRow('west', storePositions.west, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, wallMaterial, currentLinkIndex, isCornerPosition);
            currentLinkIndex = westResult.linkIndex;
            
            linkIndex = currentLinkIndex;

            // --- Crear muros separadores entre tiendas usando la función refactorizada ---
            createSeparatorWalls('north', storeDepth, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, separatorMaterial);
            createSeparatorWalls('south', HALL_SIZE - storeDepth, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, separatorMaterial);
            createSeparatorWalls('west', storeDepth, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, separatorMaterial);
            createSeparatorWalls('east', HALL_SIZE - storeDepth, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, separatorMaterial);

            // --- Crear pasillos en la planta baja ---
            // Usar las variables ya declaradas arriba
            const sueloLong = HALL_SIZE - 2 * (storeDepth + sueloOffset);
            const norteZ = storeDepth + sueloOffset;
            const surZ = HALL_SIZE - storeDepth - sueloOffset;
            const oesteX = storeDepth + sueloOffset;
            const esteX = HALL_SIZE - storeDepth - sueloOffset;
            
            // Material para el suelo del pasillo de la planta baja (rojo oscuro como el segundo piso)
            const pasilloMaterialPlantaBaja = new THREE.MeshStandardMaterial({ 
                color: 0x4B0000, // Color rojo oscuro igual al del segundo piso
                roughness: 0.8
            });
            
            // Función para crear suelo de pasillo de la planta baja
            const createPasilloSueloPlantaBaja = (geometry, position) => {
                const suelo = new THREE.Mesh(geometry, pasilloMaterialPlantaBaja);
                suelo.position.copy(position);
                suelo.receiveShadow = true;
                return suelo;
            };
            
            // Norte - pasillo rojo oscuro
            const nortePasillo = createPasilloSueloPlantaBaja(
                new THREE.BoxGeometry(sueloLong, 0.2, corridorWidth),
                new THREE.Vector3(HALL_SIZE / 2, yOffset - 0.1, norteZ)
            );
            scene.add(nortePasillo);
            gameCollections.collisionObjects.push(new THREE.Box3().setFromObject(nortePasillo));
            
            // Sur - pasillo rojo oscuro
            const surPasillo = createPasilloSueloPlantaBaja(
                new THREE.BoxGeometry(sueloLong, 0.2, corridorWidth),
                new THREE.Vector3(HALL_SIZE / 2, yOffset - 0.1, surZ)
            );
            scene.add(surPasillo);
            gameCollections.collisionObjects.push(new THREE.Box3().setFromObject(surPasillo));
            
            // Oeste - pasillo rojo oscuro
            const oestePasillo = createPasilloSueloPlantaBaja(
                new THREE.BoxGeometry(corridorWidth, 0.2, sueloLong),
                new THREE.Vector3(oesteX, yOffset - 0.1, HALL_SIZE / 2)
            );
            scene.add(oestePasillo);
            gameCollections.collisionObjects.push(new THREE.Box3().setFromObject(oestePasillo));
            
            // Este - pasillo rojo oscuro
            const estePasillo = createPasilloSueloPlantaBaja(
                new THREE.BoxGeometry(corridorWidth, 0.2, sueloLong),
                new THREE.Vector3(esteX, yOffset - 0.1, HALL_SIZE / 2)
            );
            scene.add(estePasillo);
            gameCollections.collisionObjects.push(new THREE.Box3().setFromObject(estePasillo));
            
            // Esquinas - pasillo rojo oscuro
            const createCornerPlantaBaja = (posX, posZ) => {
                const corner = createPasilloSueloPlantaBaja(
                    new THREE.BoxGeometry(corridorWidth, 0.2, corridorWidth),
                    new THREE.Vector3(posX, yOffset - 0.1, posZ)
                );
                scene.add(corner);
                gameCollections.collisionObjects.push(new THREE.Box3().setFromObject(corner));
            };
            createCornerPlantaBaja(oesteX, norteZ); // NO
            createCornerPlantaBaja(esteX, norteZ); // NE
            createCornerPlantaBaja(oesteX, surZ); // SO
            createCornerPlantaBaja(esteX, surZ); // SE

            return linkIndex;
        }

        function createUpperFloorLevel(yOffset, floorMaterial, wallMaterial, separatorMaterial, startLinkIndex) {
            const storeDepth = 12;
            const storeWidth = 8;
            const storeSpacing = 1.5;
            const corridorWidth = 8; // Aumentado para eliminar huecos en el piso
            const numStoresPerSide = Math.floor(HALL_SIZE / (storeWidth + storeSpacing));
            const totalStoresWidth = numStoresPerSide * storeWidth + (numStoresPerSide - 1) * storeSpacing;
            const initialOffset = (HALL_SIZE - totalStoresWidth) / 2;
            let linkIndex = startLinkIndex;

            // Función para verificar si una posición está en una esquina
            const isCornerPosition = (index, side) => {
                // Saltar solo la primera y la última tienda de cada lado
                return index === 0 || index === numStoresPerSide - 1;
            };

            // --- Crear pasillos con suelo ---
            // Crear materiales para cada cara
            const pasilloMaterialVinotinto = new THREE.MeshStandardMaterial({ 
                color: 0x4B0000, // Color vinotinto más oscuro
                roughness: 0.8
            });
            
            const pasilloMaterialBlanco = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF, // Color blanco
                roughness: 0.8
            });
            
            // Material original para el techo del pasillo
            const techoMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF, // Color blanco
                roughness: 0.8 
            });
            
            // El suelo empieza justo al frente de las tiendas para eliminar huecos
            const sueloOffset = corridorWidth / 2; // mitad del ancho del corredor para que empiece al frente de las tiendas
            const sueloLong = HALL_SIZE - 2 * (storeDepth + sueloOffset);
            const norteZ = storeDepth + sueloOffset;
            const surZ = HALL_SIZE - storeDepth - sueloOffset;
            const oesteX = storeDepth + sueloOffset;
            const esteX = HALL_SIZE - storeDepth - sueloOffset;
            
            // Función para crear suelo de pasillo con dos colores
            const createPasilloSuelo = (geometry, position, materialVinotinto, materialBlanco) => {
                const grupo = new THREE.Group();
                
                // Cara superior (vinotinto) - ligeramente más alta
                const caraSuperior = new THREE.Mesh(geometry, materialVinotinto);
                caraSuperior.position.set(0, 0.001, 0); // Ligeramente más alta
                grupo.add(caraSuperior);
                
                // Cara inferior (blanca) - ligeramente más baja
                const caraInferior = new THREE.Mesh(geometry, materialBlanco);
                caraInferior.position.set(0, -0.001, 0); // Ligeramente más baja
                caraInferior.rotation.x = Math.PI; // Rotar 180 grados para que mire hacia abajo
                grupo.add(caraInferior);
                
                grupo.position.copy(position);
                return grupo;
            };
            
            // Norte - vinotinto arriba, blanco abajo
            const norte = createPasilloSuelo(
                new THREE.BoxGeometry(sueloLong, 0.2, corridorWidth),
                new THREE.Vector3(HALL_SIZE / 2, yOffset - 0.1, norteZ),
                pasilloMaterialVinotinto,
                pasilloMaterialBlanco
            );
            scene.add(norte);
            gameCollections.collisionObjects.push(new THREE.Box3().setFromObject(norte));
            
            // Sur - vinotinto arriba, blanco abajo
            const sur = createPasilloSuelo(
                new THREE.BoxGeometry(sueloLong, 0.2, corridorWidth),
                new THREE.Vector3(HALL_SIZE / 2, yOffset - 0.1, surZ),
                pasilloMaterialVinotinto,
                pasilloMaterialBlanco
            );
            scene.add(sur);
            gameCollections.collisionObjects.push(new THREE.Box3().setFromObject(sur));
            
            // Oeste - vinotinto arriba, blanco abajo
            const oeste = createPasilloSuelo(
                new THREE.BoxGeometry(corridorWidth, 0.2, sueloLong),
                new THREE.Vector3(oesteX, yOffset - 0.1, HALL_SIZE / 2),
                pasilloMaterialVinotinto,
                pasilloMaterialBlanco
            );
            scene.add(oeste);
            gameCollections.collisionObjects.push(new THREE.Box3().setFromObject(oeste));
            
            // Este - vinotinto arriba, blanco abajo
            const este = createPasilloSuelo(
                new THREE.BoxGeometry(corridorWidth, 0.2, sueloLong),
                new THREE.Vector3(esteX, yOffset - 0.1, HALL_SIZE / 2),
                pasilloMaterialVinotinto,
                pasilloMaterialBlanco
            );
            scene.add(este);
            gameCollections.collisionObjects.push(new THREE.Box3().setFromObject(este));
            
            // Esquinas - vinotinto arriba, blanco abajo
            const createCorner = (posX, posZ) => {
                const corner = createPasilloSuelo(
                    new THREE.BoxGeometry(corridorWidth, 0.2, corridorWidth),
                    new THREE.Vector3(posX, yOffset - 0.1, posZ),
                    pasilloMaterialVinotinto,
                    pasilloMaterialBlanco
                );
                scene.add(corner);
                gameCollections.collisionObjects.push(new THREE.Box3().setFromObject(corner));
            };
            createCorner(oesteX, norteZ); // NO
            createCorner(esteX, norteZ); // NE
            createCorner(oesteX, surZ); // SO
            createCorner(esteX, surZ); // SE

            // --- Crear techos de pasillos (solo para el segundo piso) ---
            const currentFloor = Math.floor(yOffset / (HALL_HEIGHT + 1));
            if (currentFloor === 1) { // Segundo piso (piso 1, ya que empezamos desde 0)
                const ceilingHeight = 0.2;
                const extendedHeight = HALL_HEIGHT + 1;
                const ceilingY = yOffset + (extendedHeight / 2 + 2.5); // Mucho más alto que el techo de las tiendas
                const extendedCorridorWidth = corridorWidth + 4; // Reducir el sobresaliente del techo
                
                // Norte - techo gris original
                const techoNorte = new THREE.Mesh(new THREE.BoxGeometry(sueloLong, ceilingHeight, extendedCorridorWidth), techoMaterial);
                techoNorte.position.set(HALL_SIZE / 2, ceilingY, norteZ + 2); // Reducir sobresaliente hacia el centro
                // techoNorte.receiveShadow = true;
                // techoNorte.castShadow = true;
                scene.add(techoNorte);
                
                // Sur - techo gris original
                const techoSur = new THREE.Mesh(new THREE.BoxGeometry(sueloLong, ceilingHeight, extendedCorridorWidth), techoMaterial);
                techoSur.position.set(HALL_SIZE / 2, ceilingY, surZ - 2); // Reducir sobresaliente hacia el centro
                // techoSur.receiveShadow = true;
                // techoSur.castShadow = true;
                scene.add(techoSur);
                
                // Oeste - techo gris original
                const techoOeste = new THREE.Mesh(new THREE.BoxGeometry(extendedCorridorWidth, ceilingHeight, sueloLong), techoMaterial);
                techoOeste.position.set(oesteX + 2, ceilingY, HALL_SIZE / 2); // Reducir sobresaliente hacia el centro
                // techoOeste.receiveShadow = true;
                // techoOeste.castShadow = true;
                scene.add(techoOeste);
                
                // Este - techo gris original
                const techoEste = new THREE.Mesh(new THREE.BoxGeometry(extendedCorridorWidth, ceilingHeight, sueloLong), techoMaterial);
                techoEste.position.set(esteX - 2, ceilingY, HALL_SIZE / 2); // Reducir sobresaliente hacia el centro
                // techoEste.receiveShadow = true;
                // techoEste.castShadow = true;
                scene.add(techoEste);
                
                // Esquinas del techo - gris original
                const createCeilingCorner = (posX, posZ) => {
                    const techoCorner = new THREE.Mesh(new THREE.BoxGeometry(extendedCorridorWidth, ceilingHeight, extendedCorridorWidth), techoMaterial);
                    techoCorner.position.set(posX, ceilingY, posZ);
                    // techoCorner.receiveShadow = true;
                    // techoCorner.castShadow = true;
                    scene.add(techoCorner);
                };
                createCeilingCorner(oesteX + 2, norteZ + 2); // NO
                createCeilingCorner(esteX - 2, norteZ + 2); // NE
                createCeilingCorner(oesteX + 2, surZ - 2); // SO
                createCeilingCorner(esteX - 2, surZ - 2); // SE
            }

            // --- Crear techo trapezoidal sobre las tiendas del último piso ---
            // ELIMINADO: Techos trapezoidales para mejorar rendimiento
            // Ya no se necesitan porque solo tenemos 2 pisos
            /*
            if (currentFloor === 3) { // Solo para el último piso (piso 3)
                const trapezoidMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xA0522D, 
                    roughness: 0.8,
                    metalness: 0.1,
                    side: THREE.DoubleSide
                });
                
                // Crear techo trapezoidal para cada lado
                const trapezoidHeight = 6; // Más alto y más grande
                const baseWidth = storeWidth + 2; // Un poco más ancho que la tienda
                
                // Norte - techo trapezoidal
                for (let i = 0; i < numStoresPerSide; i++) {
                    const x = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                    const trapezoidGeometry = new THREE.ConeGeometry(baseWidth / 2, trapezoidHeight, 4);
                    const trapezoid = new THREE.Mesh(trapezoidGeometry, trapezoidMaterial);
                    trapezoid.position.set(x, yOffset + (HALL_HEIGHT + 1) / 2 + 3.5 + trapezoidHeight / 2, storeDepth / 2);
                    trapezoid.rotation.y = Math.PI / 4; // Rotar 45 grados
                    trapezoid.castShadow = true;
                    trapezoid.receiveShadow = true;
                    scene.add(trapezoid);
                }
                
                // Sur - techo trapezoidal
                for (let i = 0; i < numStoresPerSide; i++) {
                    const x = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                    const trapezoidGeometry = new THREE.ConeGeometry(baseWidth / 2, trapezoidHeight, 4);
                    const trapezoid = new THREE.Mesh(trapezoidGeometry, trapezoidMaterial);
                    trapezoid.position.set(x, yOffset + (HALL_HEIGHT + 1) / 2 + 3.5 + trapezoidHeight / 2, HALL_SIZE - storeDepth / 2);
                    trapezoid.rotation.y = Math.PI / 4; // Rotar 45 grados
                    trapezoid.castShadow = true;
                    trapezoid.receiveShadow = true;
                    scene.add(trapezoid);
                }
                
                // Oeste - techo trapezoidal
                for (let i = 0; i < numStoresPerSide; i++) {
                    const z = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                    const trapezoidGeometry = new THREE.ConeGeometry(baseWidth / 2, trapezoidHeight, 4);
                    const trapezoid = new THREE.Mesh(trapezoidGeometry, trapezoidMaterial);
                    trapezoid.position.set(storeDepth / 2, yOffset + (HALL_HEIGHT + 1) / 2 + 3.5 + trapezoidHeight / 2, z);
                    trapezoid.rotation.y = Math.PI / 4; // Rotar 45 grados
                    trapezoid.castShadow = true;
                    trapezoid.receiveShadow = true;
                    scene.add(trapezoid);
                }
                
                // Este - techo trapezoidal
                for (let i = 0; i < numStoresPerSide; i++) {
                    const z = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                    const trapezoidGeometry = new THREE.ConeGeometry(baseWidth / 2, trapezoidHeight, 4);
                    const trapezoid = new THREE.Mesh(trapezoidGeometry, trapezoidMaterial);
                    trapezoid.position.set(HALL_SIZE - storeDepth / 2, yOffset + (HALL_HEIGHT + 1) / 2 + 3.5 + trapezoidHeight / 2, z);
                    trapezoid.rotation.y = Math.PI / 4; // Rotar 45 grados
                    trapezoid.castShadow = true;
                    trapezoid.receiveShadow = true;
                    scene.add(trapezoid);
                }
            }
            */

            // --- Crear barandas al borde exterior de los corredores ---
            const railingHeight = 0.8;
            const railMat = new THREE.MeshStandardMaterial({ color: 0x000000, metalness: 0.5, roughness: 0.5 }); // Color negro
            const cornerGap = 2; // Espacio en las esquinas para no bloquear el paso
            const barandaLong = (sueloLong + corridorWidth - cornerGap) / 2; // Longitud de cada tramo
            const railThickness = 0.3; // Grosor de las barandas para hacerlas sólidas
            
            // Norte - dos tramos separados
            const railN1 = new THREE.Mesh(new THREE.BoxGeometry(barandaLong, railingHeight, railThickness), railMat);
            railN1.position.set(storeDepth + corridorWidth + barandaLong / 2, yOffset + railingHeight / 2 - 0.1, storeDepth + corridorWidth);
            scene.add(railN1);
            const railN2 = new THREE.Mesh(new THREE.BoxGeometry(barandaLong, railingHeight, railThickness), railMat);
            railN2.position.set(HALL_SIZE - storeDepth - corridorWidth - barandaLong / 2, yOffset + railingHeight / 2 - 0.1, storeDepth + corridorWidth);
            scene.add(railN2);
            
            // Sur - dos tramos separados
            const railS1 = new THREE.Mesh(new THREE.BoxGeometry(barandaLong, railingHeight, railThickness), railMat);
            railS1.position.set(storeDepth + corridorWidth + barandaLong / 2, yOffset + railingHeight / 2 - 0.1, HALL_SIZE - storeDepth - corridorWidth);
            scene.add(railS1);
            const railS2 = new THREE.Mesh(new THREE.BoxGeometry(barandaLong, railingHeight, railThickness), railMat);
            railS2.position.set(HALL_SIZE - storeDepth - corridorWidth - barandaLong / 2, yOffset + railingHeight / 2 - 0.1, HALL_SIZE - storeDepth - corridorWidth);
            scene.add(railS2);
            
            // Oeste - dos tramos separados
            const railO1 = new THREE.Mesh(new THREE.BoxGeometry(railThickness, railingHeight, barandaLong), railMat);
            railO1.position.set(storeDepth + corridorWidth, yOffset + railingHeight / 2 - 0.1, storeDepth + corridorWidth + barandaLong / 2);
            scene.add(railO1);
            const railO2 = new THREE.Mesh(new THREE.BoxGeometry(railThickness, railingHeight, barandaLong), railMat);
            railO2.position.set(storeDepth + corridorWidth, yOffset + railingHeight / 2 - 0.1, HALL_SIZE - storeDepth - corridorWidth - barandaLong / 2);
            scene.add(railO2);
            
            // Este - dos tramos separados
            const railE1 = new THREE.Mesh(new THREE.BoxGeometry(railThickness, railingHeight, barandaLong), railMat);
            railE1.position.set(HALL_SIZE - storeDepth - corridorWidth, yOffset + railingHeight / 2 - 0.1, storeDepth + corridorWidth + barandaLong / 2);
            scene.add(railE1);
            const railE2 = new THREE.Mesh(new THREE.BoxGeometry(railThickness, railingHeight, barandaLong), railMat);
            railE2.position.set(HALL_SIZE - storeDepth - corridorWidth, yOffset + railingHeight / 2 - 0.1, HALL_SIZE - storeDepth - corridorWidth - barandaLong / 2);
            scene.add(railE2);

            // --- Actualizar colisiones de las barandas después de agregarlas a la escena ---
            [railN1, railN2, railS1, railS2, railO1, railO2, railE1, railE2].forEach(rail => {
                rail.updateMatrixWorld(true);
                const railBox = new THREE.Box3().setFromObject(rail);
                // Expandir la caja de colisión para hacer las barandas más efectivas
                railBox.expandByScalar(0.2);
                gameCollections.collisionObjects.push(railBox);
            });

            // Crear tiendas usando la función refactorizada
            const storePositions = {
                north: storeDepth / 2,
                south: HALL_SIZE - storeDepth / 2,
                east: HALL_SIZE - storeDepth / 2,
                west: storeDepth / 2
            };
            
            // Crear tiendas en sentido horario: Norte -> Este -> Sur -> Oeste
            let currentLinkIndex = linkIndex;
            
            // Norte
            const northResult = createStoreRow('north', storePositions.north, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, wallMaterial, currentLinkIndex, isCornerPosition);
            currentLinkIndex = northResult.linkIndex;
            
            // Este
            const eastResult = createStoreRow('east', storePositions.east, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, wallMaterial, currentLinkIndex, isCornerPosition);
            currentLinkIndex = eastResult.linkIndex;

            // Sur
            const southResult = createStoreRow('south', storePositions.south, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, wallMaterial, currentLinkIndex, isCornerPosition);
            currentLinkIndex = southResult.linkIndex;

            // Oeste
            const westResult = createStoreRow('west', storePositions.west, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, wallMaterial, currentLinkIndex, isCornerPosition);
            currentLinkIndex = westResult.linkIndex;
            
            linkIndex = currentLinkIndex;

            // --- Crear muros separadores entre tiendas usando la función refactorizada ---
            createSeparatorWalls('north', storeDepth, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, separatorMaterial);
            createSeparatorWalls('south', HALL_SIZE - storeDepth, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, separatorMaterial);
            createSeparatorWalls('west', storeDepth, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, separatorMaterial);
            createSeparatorWalls('east', HALL_SIZE - storeDepth, numStoresPerSide, storeWidth, storeSpacing, initialOffset, yOffset, separatorMaterial);

            return linkIndex;
        }

        function createStore(position, size, rotationY, linkIdx, depth, wallMaterial, floorY, shopNumber) {
            const storeGroup = new THREE.Group();
            storeGroup.position.copy(position);
            storeGroup.rotation.y = rotationY;
            const wallThickness = 0.2;

            // Determinar el piso actual una sola vez
            const currentFloor = Math.floor(floorY / (HALL_HEIGHT + 1));

            // --- Crear material de pared con el color de la pancarta ---
            const url = storeLinks[linkIdx];
            const domain = new URL(url).hostname.replace('www.', '').split('.')[0];
            const storeColor = new THREE.Color().setHSL((linkIdx * 47) % 360 / 360, 0.6, 0.5); // Mismo color que la pancarta
            const storeWallMaterial = new THREE.MeshStandardMaterial({ 
                color: storeColor,
                roughness: 0.9
            });

            // --- Suelo de la tienda con dos colores ---
            // Crear materiales para cada cara
            const storeFloorMaterialNegro = new THREE.MeshStandardMaterial({ 
                color: 0x000000, // Color negro
                roughness: 0.8
            });
            
            const storeFloorMaterialBlanco = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF, // Color blanco
                roughness: 0.8
            });
            
            // Función para crear suelo de tienda con dos colores
            const createStoreFloor = (geometry, position) => {
                const grupo = new THREE.Group();
                
                // Cara superior (negra) - ligeramente más alta
                const caraSuperior = new THREE.Mesh(geometry, storeFloorMaterialNegro);
                caraSuperior.position.set(0, 0.001, 0); // Ligeramente más alta
                grupo.add(caraSuperior);
                
                // Cara inferior (blanca) - ligeramente más baja
                const caraInferior = new THREE.Mesh(geometry, storeFloorMaterialBlanco);
                caraInferior.position.set(0, -0.001, 0); // Ligeramente más baja
                caraInferior.rotation.x = Math.PI; // Rotar 180 grados para que mire hacia abajo
                grupo.add(caraInferior);
                
                grupo.position.copy(position);
                grupo.rotation.x = -Math.PI / 2;
                return grupo;
            };
            
            // Crear suelo de tienda con negro arriba y blanco abajo
            const storeFloor = createStoreFloor(new THREE.PlaneGeometry(size.x, depth), new THREE.Vector3(0, 0, 0));
            
            // Ajustar la posición del suelo según el piso
            if (currentFloor === 1) {
                // Para el segundo piso, subir ligeramente el suelo
                const floorOffset = -0.05 - HALL_HEIGHT / 2; // Reducido de -0.1 a -0.05
                storeFloor.position.set(0, floorOffset, 0);
            } else {
                // Para la planta baja, mantener la posición original
                storeFloor.position.set(0, -size.y / 2 + 0.05, 0);
            }
            
            // storeFloor.receiveShadow = true;
            // storeFloor.castShadow = false; // Desactivar sombras para mejor rendimiento
            storeGroup.add(storeFloor);

            // --- Paredes (extendidas hasta el siguiente piso) ---
            const extendedHeight = HALL_HEIGHT + 1; // Extender hasta el siguiente piso
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(size.x, extendedHeight, wallThickness), storeWallMaterial);
            backWall.position.z = -depth / 2;
            backWall.position.y = (extendedHeight - size.y) / 2; // Centrar en la nueva altura
            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(depth, extendedHeight, wallThickness), storeWallMaterial);
            leftWall.position.set(-size.x / 2, (extendedHeight - size.y) / 2, 0);
            leftWall.rotation.y = Math.PI / 2;
            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(depth, extendedHeight, wallThickness), storeWallMaterial);
            rightWall.position.set(size.x / 2, (extendedHeight - size.y) / 2, 0);
            rightWall.rotation.y = -Math.PI / 2;
            [backWall, leftWall, rightWall].forEach(wall => {
                // wall.castShadow = false; // Desactivar sombras para mejor rendimiento
                // wall.receiveShadow = true;
                storeGroup.add(wall);
            });

            // --- Techo (para el segundo piso) ---
            if (currentFloor === 1) { // Segundo piso (piso 1, ya que empezamos desde 0)
                const ceilingMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF, // Color blanco
                    roughness: 0.8,
                    side: THREE.DoubleSide
                });
                const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(size.x, depth), ceilingMaterial);
                ceiling.rotation.x = Math.PI / 2;
                ceiling.position.set(0, extendedHeight / 2 + 0.5, 0); // Posicionar más alto que las paredes extendidas
                // ceiling.receiveShadow = true;
                // ceiling.castShadow = false; // Desactivar sombras para mejor rendimiento
                storeGroup.add(ceiling);
            }
            
            // --- Cartel principal ---
            const mainSign = createImagePlane(url, domain, size.x * 0.9, size.y * 0.8, linkIdx, true);
            mainSign.position.z = -depth / 2 + wallThickness + 0.01;
            mainSign.position.y = (extendedHeight - size.y) / 2; // Ajustar posición vertical
            storeGroup.add(mainSign);

            // --- Número de tienda ---
            const shopNumberSign = createShopNumberSign(shopNumber, size.x * 0.25, size.y * 0.25);
            shopNumberSign.position.z = -depth / 2 + wallThickness + 0.02;
            shopNumberSign.position.y = (extendedHeight - size.y) / 2 + size.y * 0.4; // Posicionar más abajo
            shopNumberSign.position.x = 0; // Centrar horizontalmente
            storeGroup.add(shopNumberSign);

            // --- Carteles laterales (restaurar ambos carteles) ---
            const sideSignTexts = [ `Ofertas en ${domain}`, `Visítanos ahora`, `Clic para ganar`, `Novedades aquí`];
            const leftSign = createRotatingSign(url, sideSignTexts, 2.5, size.y * 0.6, linkIdx);
            leftSign.position.set(-size.x / 2 + wallThickness + 0.01, (extendedHeight - size.y) / 2, -2);
            leftSign.rotation.y = Math.PI / 2;

            const rightSign = createRotatingSign(url, sideSignTexts.slice(2).concat(sideSignTexts.slice(0,2)), 2.5, size.y * 0.6, linkIdx + 1);
            rightSign.position.set(size.x / 2 - wallThickness - 0.01, (extendedHeight - size.y) / 2, -2);
            rightSign.rotation.y = -Math.PI / 2;
            
            storeGroup.add(leftSign, rightSign);

            // --- Letreros verticales completos para los pasillos ---
            const createVerticalSign = (text, width, height, colorIdx) => {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const canvasW = 256; // Restaurar tamaño original
                const canvasH = 512; // Más alto para texto vertical
                canvas.width = canvasW;
                canvas.height = canvasH;
                
                // Fondo con el mismo color que el cartel principal
                context.fillStyle = `hsl(${colorIdx * 47 % 360}, 60%, 50%)`;
                context.fillRect(0, 0, canvasW, canvasH);
                context.strokeStyle = '#FFFFFF';
                context.lineWidth = 4; // Restaurar grosor original
                context.strokeRect(2, 2, canvasW - 4, canvasH - 4);
                
                // Texto vertical en blanco
                context.fillStyle = '#FFFFFF';
                context.font = `bold ${canvasW * 0.25}px Arial`; // Restaurar tamaño de fuente original
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                
                // Dividir el texto en caracteres y dibujarlos verticalmente de arriba hacia abajo
                const chars = text.split('');
                const charHeight = canvasH * 0.12; // Más espacio entre letras
                const totalHeight = chars.length * charHeight;
                const startY = canvasH / 2 - totalHeight / 2;
                const centerX = canvasW / 2;
                
                chars.forEach((char, index) => {
                    context.fillText(char, centerX, startY + index * charHeight);
                });
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshStandardMaterial({ 
                    map: texture,
                    transparent: true,
                    alphaTest: 0.1
                });
                
                const plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), material);
                return plane;
            };

            // Crear letreros verticales en los bordes de los pasillos (restaurar ambos)
            const verticalSignWidth = 0.8; // Restaurar tamaño original
            const verticalSignHeight = extendedHeight; // Restaurar altura original
            
            // Letrero en el extremo izquierdo del muro (hacia el pasillo)
            const leftVerticalSign = createVerticalSign(domain.toUpperCase(), verticalSignWidth, verticalSignHeight, linkIdx);
            leftVerticalSign.position.set(-size.x / 2 + wallThickness + 0.02, (extendedHeight - size.y) / 2, depth / 2 - 1);
            leftVerticalSign.rotation.y = Math.PI / 2;
            storeGroup.add(leftVerticalSign);
            
            // Número de tienda en el extremo izquierdo del muro
            const leftNumberSign = createShopNumberSign(shopNumber, 0.8, 0.8);
            leftNumberSign.position.set(-size.x / 2 + wallThickness + 0.02, (extendedHeight - size.y) / 2 + 1.5, depth / 2 - 0.2);
            leftNumberSign.rotation.y = Math.PI / 2;
            storeGroup.add(leftNumberSign);
            
            // Letrero en el extremo derecho del muro (hacia el pasillo)
            const rightVerticalSign = createVerticalSign(domain.toUpperCase(), verticalSignWidth, verticalSignHeight, linkIdx);
            rightVerticalSign.position.set(size.x / 2 - wallThickness - 0.02, (extendedHeight - size.y) / 2, depth / 2 - 1);
            rightVerticalSign.rotation.y = -Math.PI / 2;
            storeGroup.add(rightVerticalSign);
            
            // Número de tienda en el extremo derecho del muro
            const rightNumberSign = createShopNumberSign(shopNumber, 0.8, 0.8);
            rightNumberSign.position.set(size.x / 2 - wallThickness - 0.02, (extendedHeight - size.y) / 2 + 1.5, depth / 2 - 0.2);
            rightNumberSign.rotation.y = -Math.PI / 2;
            storeGroup.add(rightNumberSign);

            scene.add(storeGroup);

            // --- Actualizar colisiones ---
            storeGroup.updateMatrixWorld(true);
            [backWall, leftWall, rightWall].forEach(wall => {
                gameCollections.collisionObjects.push(new THREE.Box3().setFromObject(wall));
            });
        }

        function createCentralCubeScreens(x, y, z, size, links, colorOffset, interval) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            const planes = [];

            const cubeGeom = new THREE.BoxGeometry(size, size * 0.6, size);
            const cubeMat = new THREE.MeshStandardMaterial({ color: 0x222, metalness: 0.3, roughness: 0.7 });
            const cube = new THREE.Mesh(cubeGeom, cubeMat);
            cube.position.y = size * 0.3;
            group.add(cube);
            
            for (let i = 0; i < 4; i++) {
                if (i >= links.length) continue;
                const angle = i * Math.PI / 2;
                const url = links[i];
                const domain = new URL(url).hostname.replace('www.', '').split('.')[0];
                const plane = createImagePlane(url, domain, size, size * 0.6, colorOffset + i, true);
                plane.position.set(Math.sin(angle) * (size / 2 + 0.01), size * 0.3, Math.cos(angle) * (size / 2 + 0.01));
                plane.rotation.y = angle;
                group.add(plane);
                planes.push(plane);
            }
            scene.add(group);
            group.updateMatrixWorld(true);
            gameCollections.collisionObjects.push(new THREE.Box3().setFromObject(cube));

            let offset = 0;
            setInterval(() => {
                planes.forEach((plane, i) => {
                    const linkIdx = (offset + i) % links.length;
                    const url = links[linkIdx];
                    const domain = new URL(url).hostname.replace('www.', '').split('.')[0];
                    plane.userData.URL = url;
                    updateImagePlane(plane, url, domain, colorOffset + linkIdx, true);
                });
                offset = (offset + 1) % links.length;
            }, interval);
        }

        function createImagePlane(url, text, width, height, colorIdx, solid) {
            const plane = new THREE.Mesh(
                new THREE.PlaneGeometry(width, height),
                new THREE.MeshStandardMaterial({ roughness: 0.7, metalness: 0.2, transparent: !solid })
            );
            plane.userData.URL = url;
            updateImagePlane(plane, url, text, colorIdx, solid);
            gameCollections.clickableObjects.push(plane);
            return plane;
        }

        // Cache para texturas de logos
        const logoTextureCache = new Map();
        
        function getLogoTexture(domain) {
            const logoFileName = domainToLogoMap[domain];
            if (!logoFileName) {
                return null;
            }
            
            // Verificar si ya está en cache
            if (logoTextureCache.has(domain)) {
                return logoTextureCache.get(domain);
            }
            
            try {
                const textureLoader = new THREE.TextureLoader();
                const texture = textureLoader.load(
                    `assets/images/${logoFileName}`,
                    // onLoad callback
                    function(loadedTexture) {
                        console.log(`Logo cargado exitosamente: ${logoFileName}`);
                    },
                    // onProgress callback
                    function(xhr) {
                        // Silenciar progreso para evitar spam
                    },
                    // onError callback
                    function(error) {
                        console.error(`Error cargando logo ${logoFileName}:`, error);
                        // Remover del cache si falla
                        logoTextureCache.delete(domain);
                    }
                );
                
                // Guardar en cache
                logoTextureCache.set(domain, texture);
                return texture;
            } catch (error) {
                console.error(`Error creando textura para ${domain}:`, error);
                return null;
            }
        }

        function createShopNumberSign(number, width, height) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const canvasW = 256;
            const canvasH = 256;
            canvas.width = canvasW;
            canvas.height = canvasH;
            
            // Fondo circular negro
            context.fillStyle = '#000000';
            context.beginPath();
            context.arc(canvasW / 2, canvasH / 2, canvasW / 2 - 10, 0, 2 * Math.PI);
            context.fill();
            
            // Borde blanco
            context.strokeStyle = '#FFFFFF';
            context.lineWidth = 8;
            context.stroke();
            
            // Número en blanco
            context.fillStyle = '#FFFFFF';
            context.font = `bold ${canvasH * 0.6}px Arial`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(number.toString(), canvasW / 2, canvasH / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshStandardMaterial({ 
                map: texture,
                transparent: true,
                alphaTest: 0.1
            });
            
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), material);
            return plane;
        }

        function updateImagePlane(plane, url, text, colorIdx) {
            try {
                let domain = new URL(url).hostname.replace('www.', '');
                // Extraer el dominio principal (sin subdominios)
                const domainParts = domain.split('.');
                if (domainParts.length > 2) {
                    domain = domainParts[1];
                } else {
                    domain = domainParts[0];
                }
                const logoTexture = getLogoTexture(domain);
                if (logoTexture) {
                    plane.material.map = logoTexture;
                } else {
                    // Fallback a la textura generada si no hay logo
                    const texture = getCachedTexture(text, colorIdx, plane.geometry.parameters.width, plane.geometry.parameters.height);
                    plane.material.map = texture;
                }
                if (plane.material.map && plane.material.map.image) {
                    plane.material.map.needsUpdate = true;
                }
            } catch (error) {
                console.error('Error en updateImagePlane:', error);
                // Fallback seguro
                const texture = getCachedTexture(text, colorIdx, plane.geometry.parameters.width, plane.geometry.parameters.height);
                plane.material.map = texture;
                if (plane.material.map && plane.material.map.image) {
                    plane.material.map.needsUpdate = true;
                }
            }
        }

        function createRotatingSign(url, texts, width, height, colorIdx) {
            const plane = createImagePlane(url, texts[0], width, height, colorIdx, false);
            plane.material.transparent = true;
            
            // Agregar al sistema centralizado en lugar de usar setInterval
            const signIndex = rotatingSigns.length;
            rotatingSigns.push({
                material: plane.material,
                texts: texts
            });
            rotatingSignTextIndexes[signIndex] = 0;
            
            return plane;
        }

        function updateRotatingSign(material, text) {
            let canvas = material.map && material.map.image ? material.map.image : null;
            if (!canvas || !canvas.getContext) {
                canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 128;
                material.map = new THREE.CanvasTexture(canvas);
            }
            const context = canvas.getContext('2d');
            const canvasW = canvas.width;
            const canvasH = canvas.height;
            context.fillStyle = '#fff';
            context.fillRect(0, 0, canvasW, canvasH);
            context.strokeStyle = '#000';
            context.lineWidth = 8;
            context.strokeRect(4, 4, canvasW-8, canvasH-8);
            let fontSize = canvasH * 0.3;
            context.font = `bold ${fontSize}px Arial`;
            context.fillStyle = '#000';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            while(context.measureText(text).width > canvasW - 20 && fontSize > 10) {
                fontSize -= 2;
                context.font = `bold ${fontSize}px Arial`;
            }
            context.fillText(text, canvasW/2, canvasH/2);
            if (material.map && material.map.image) {
                material.map.needsUpdate = true;
            }
        }
        
        function createDigitalClockCube(x, y, z, size) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            const planes = [];

            const cubeGeom = new THREE.BoxGeometry(size, size * 0.6, size);
            const cubeMat = new THREE.MeshStandardMaterial({ color: 0x111, metalness: 0.3, roughness: 0.7 });
            const cube = new THREE.Mesh(cubeGeom, cubeMat);
            cube.position.y = size * 0.3;
            group.add(cube);

            for (let i = 0; i < 4; i++) {
                const angle = i * Math.PI / 2;
                const plane = createClockPlane(size, size * 0.6);
                plane.position.set(Math.sin(angle) * (size / 2 + 0.01), size * 0.3, Math.cos(angle) * (size / 2 + 0.01));
                plane.rotation.y = angle;
                group.add(plane);
                planes.push(plane);
            }
            scene.add(group);
            group.updateMatrixWorld(true);
            gameCollections.collisionObjects.push(new THREE.Box3().setFromObject(cube));

            // Agregar al sistema centralizado en lugar de usar setInterval
            planes.forEach(plane => {
                digitalClocks.push({
                    material: plane.material
                });
            });
        }

        function createClockPlane(width, height) {
            const material = new THREE.MeshStandardMaterial({ roughness: 0.7, metalness: 0.2 });
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), material);
            updateClockPlane(material);
            return plane;
        }

        function updateClockPlane(material) {
            let canvas;
            if (material.map && material.map.image) {
                canvas = material.map.image;
            } else {
                canvas = document.createElement('canvas');
                material.map = new THREE.CanvasTexture(canvas);
            }
            const context = canvas.getContext('2d');
            canvas.width = 800;
            canvas.height = 400;
            
            context.fillStyle = '#111';
            context.fillRect(0, 0, 800, 400);
            
            const now = new Date();
            const timeStr = now.toLocaleTimeString('es-ES', { hour12: false });
            context.font = 'bold 160px monospace';
            context.fillStyle = '#0ff';
            context.shadowColor = '#0ff';
            context.shadowBlur = 32;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(timeStr, 400, 200);
            if (material.map) {
                material.map.needsUpdate = true;
            }
        }

        // --- Manejadores de Eventos ---
        function setupEventListeners() {
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize);
            // Sistema centralizado de eventos de clic
        document.addEventListener('mousedown', handleGlobalClick);
        document.addEventListener('click', handleGlobalClick);
        }
        
        // --- SISTEMA CENTRALIZADO DE EVENT LISTENERS ---
        
        function setupEventListeners() {
            console.log('Configurando event listeners centralizados...');
            
            // Event listeners del documento
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', handleGlobalClick);
            document.addEventListener('click', handleGlobalClick);
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('beforeunload', cleanup);
            
            // Event listeners de UI principal
            setupUIEventListeners();
            
            // Event listeners de chat
            setupChatEventListeners();
            
            // Event listeners de personalización
            setupCustomizationEventListeners();
            
            // Event listeners de habitación personal
            setupRoomEventListeners();
            
            // Event listeners de controles móviles
            setupMobileControls();
            
            // Event listeners de usuarios
            setupUserEventListeners();
            
            console.log('✅ Event listeners configurados');
        }
        
        function setupUIEventListeners() {
            // Botón de personalización
            const customizationBtn = document.getElementById('customization-btn');
            if (customizationBtn) {
                customizationBtn.addEventListener('click', () => {
                    console.log('Botón de personalización clickeado');
                    openCustomizationPanel();
                });
            }
            
            // Botón de habitación personal
            const roomToggleBtn = document.getElementById('room-toggle-btn');
            if (roomToggleBtn) {
                roomToggleBtn.addEventListener('click', () => {
                    console.log('Botón de habitación clickeado');
                    if (gameState.currentScene === 'mall') {
                        enterPersonalRoom();
            } else {
                        returnToMall();
                    }
                });
            }
            
            // Botón de cambio de alias
            const changeAliasBtn = document.getElementById('change-alias-btn');
            if (changeAliasBtn) {
                changeAliasBtn.addEventListener('click', () => {
                    const newAlias = prompt('Ingresa tu nuevo alias:');
                    if (newAlias && newAlias.trim()) {
                        userAlias = newAlias.trim();
                        localStorage.setItem('userAlias', userAlias);
                        if (isConnected) {
                            sendAlias();
                        }
                    }
                });
            }
            
            // Botón para regresar al mall
            const returnToMallBtn = document.getElementById('return-to-mall-btn');
            if (returnToMallBtn) {
                returnToMallBtn.addEventListener('click', () => {
                    console.log('Botón de regreso al mall clickeado');
                    returnToMall();
                });
            }
        }
        
        function setupChatEventListeners() {
            // Botón de toggle del chat
            const chatToggleBtn = document.getElementById('chat-toggle-btn');
            if (chatToggleBtn) {
                chatToggleBtn.addEventListener('click', () => {
                    if (chatOpen) {
                        chatPanel.style.display = 'none';
                        chatOpen = false;
            } else {
                        chatPanel.style.display = 'flex';
                        chatOpen = true;
                        chatInput.focus();
                    }
                });
            }
            
            // Botón de cerrar chat
            const chatCloseBtn = document.getElementById('chat-close-btn');
            if (chatCloseBtn) {
                chatCloseBtn.addEventListener('click', () => {
                    chatPanel.style.display = 'none';
                    chatOpen = false;
                });
            }
            
            // Botón de enviar mensaje
            const chatSendBtn = document.getElementById('chat-send-btn');
            const chatInput = document.getElementById('chat-input');
            if (chatSendBtn && chatInput) {
                chatSendBtn.addEventListener('click', handleSendMessage);
                chatInput.addEventListener('keydown', e => {
                    if (e.key === 'Enter') {
                        handleSendMessage();
                    }
                });
            }
            
            // Toggle de emojis
            const emojiToggle = document.getElementById('emoji-toggle');
            if (emojiToggle) {
                emojiToggle.addEventListener('click', () => {
                    if (emojiPanel.style.display === 'none' || !emojiPanel.style.display) {
                        emojiPanel.style.display = 'flex';
                        createEmojiPanel();
                    } else {
                        emojiPanel.style.display = 'none';
                    }
                });
                }
            }
        
        function setupCustomizationEventListeners() {
            // Botones de personalización
            const saveCustomizationBtn = document.getElementById('save-customization-btn');
            const resetCustomizationBtn = document.getElementById('reset-customization-btn');
            
            if (saveCustomizationBtn) {
                saveCustomizationBtn.addEventListener('click', saveSimpleCustomization);
            }
            
            if (resetCustomizationBtn) {
                resetCustomizationBtn.addEventListener('click', resetSimpleCustomization);
            }
            
            // Botón de cerrar panel simple
            const simplePanelCloseBtn = document.querySelector('#simple-panel .close-btn');
            if (simplePanelCloseBtn) {
                simplePanelCloseBtn.addEventListener('click', closeSimplePanel);
            }
            
            // Input de alias para preview
            const aliasInput = document.getElementById('simple-alias-input');
            if (aliasInput) {
                aliasInput.addEventListener('input', () => {
                    updateAvatarPreview();
                });
            }
            
            // Botones de navegación de skin
            const prevBtn = document.getElementById('skin-prev-btn');
            const nextBtn = document.getElementById('skin-next-btn');
            
            if (prevBtn) {
                prevBtn.addEventListener('click', () => {
                    const skinList = [
                        { key: 'humanMaleA', label: 'Humano Masculino', img: 'assets/kenney 3d characters/Skins/humanMaleA.png' },
                        { key: 'humanFemaleA', label: 'Humano Femenino', img: 'assets/kenney 3d characters/Skins/humanFemaleA.png' },
                        { key: 'zombieMaleA', label: 'Zombie Masculino', img: 'assets/kenney 3d characters/Skins/zombieMaleA.png' },
                        { key: 'zombieFemaleA', label: 'Zombie Femenino', img: 'assets/kenney 3d characters/Skins/zombieFemaleA.png' }
                    ];
                    let currentIdx = skinList.findIndex(s => s.key === avatarState.currentCustomization.skin);
                    if (currentIdx === -1) currentIdx = 0;
                    currentIdx = (currentIdx - 1 + skinList.length) % skinList.length;
                    updateSkinPreview(currentIdx);
                });
            }
            
            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    const skinList = [
                        { key: 'humanMaleA', label: 'Humano Masculino', img: 'assets/kenney 3d characters/Skins/humanMaleA.png' },
                        { key: 'humanFemaleA', label: 'Humano Femenino', img: 'assets/kenney 3d characters/Skins/humanFemaleA.png' },
                        { key: 'zombieMaleA', label: 'Zombie Masculino', img: 'assets/kenney 3d characters/Skins/zombieMaleA.png' },
                        { key: 'zombieFemaleA', label: 'Zombie Femenino', img: 'assets/kenney 3d characters/Skins/zombieFemaleA.png' }
                    ];
                    let currentIdx = skinList.findIndex(s => s.key === avatarState.currentCustomization.skin);
                    if (currentIdx === -1) currentIdx = 0;
                    currentIdx = (currentIdx + 1) % skinList.length;
                    updateSkinPreview(currentIdx);
                });
            }
        }
        
        function setupRoomEventListeners() {
            // Botón de cerrar panel de edición de muebles
            const furnitureEditCloseBtn = document.querySelector('#furniture-edit-panel .close-btn');
            if (furnitureEditCloseBtn) {
                furnitureEditCloseBtn.addEventListener('click', closeFurnitureEditPanel);
            }
            
            // Botón de cerrar navegación de habitación
            const roomNavCloseBtn = document.querySelector('#room-navigation-panel .close-btn');
            if (roomNavCloseBtn) {
                roomNavCloseBtn.addEventListener('click', closeRoomNavigation);
            }
            
            // Botones de habitación personal
            const enterRoomBtn = document.getElementById('enter-room-btn');
            if (enterRoomBtn) {
                enterRoomBtn.addEventListener('click', enterPersonalRoom);
            }
            
            const toggleFurnitureBtn = document.getElementById('toggle-furniture-btn');
            if (toggleFurnitureBtn) {
                toggleFurnitureBtn.addEventListener('click', toggleFurnitureEditMode);
            }
            
            const customizeRoomBtn = document.getElementById('customize-room-btn');
            if (customizeRoomBtn) {
                customizeRoomBtn.addEventListener('click', customizeRoom);
            }
        }
        
        function setupUserEventListeners() {
            // Lista de usuarios
            const usersList = document.getElementById('users-list');
            if (usersList) {
                usersList.addEventListener('click', function(e) {
                    const userItem = e.target.closest('.user-item');
                    if (userItem && !userItem.classList.contains('own')) {
                        const alias = userItem.textContent.replace(' (Tú)', '');
                        openPrivateChatWindow(alias);
                    }
                });
            }
        }
        
        // Función auxiliar para actualizar preview de skin
        function updateSkinPreview(idx) {
            const skinList = [
                { key: 'humanMaleA', label: 'Humano Masculino', img: 'assets/kenney 3d characters/Skins/humanMaleA.png' },
                { key: 'humanFemaleA', label: 'Humano Femenino', img: 'assets/kenney 3d characters/Skins/humanFemaleA.png' },
                { key: 'zombieMaleA', label: 'Zombie Masculino', img: 'assets/kenney 3d characters/Skins/zombieMaleA.png' },
                { key: 'zombieFemaleA', label: 'Zombie Femenino', img: 'assets/kenney 3d characters/Skins/zombieFemaleA.png' }
            ];
            const img = document.getElementById('skin-preview-img');
            const label = document.getElementById('skin-preview-label');
            if (img && label) {
                img.src = skinList[idx].img;
                label.textContent = skinList[idx].label;
                avatarState.currentCustomization.skin = skinList[idx].key;
                updateAvatarPreview && updateAvatarPreview();
            }
        }
        
        function setupMobileControls() {
            const mobileForwardBtn = document.getElementById('mobile-forward');
            const mobileBackwardBtn = document.getElementById('mobile-backward');
            const mobileLeftBtn = document.getElementById('mobile-left');
            const mobileRightBtn = document.getElementById('mobile-right');
            
            // Función auxiliar para configurar controles de botones móviles
            function setupButtonControls(buttonId, flagSetter) {
                const button = document.getElementById(buttonId);
                if (button) {
                    const setFlag = (value) => (e) => { 
                    e.preventDefault();
                        flagSetter(value); 
                    };
                    button.addEventListener('touchstart', setFlag(true));
                    button.addEventListener('touchend', setFlag(false));
                    button.addEventListener('mousedown', setFlag(true));
                    button.addEventListener('mouseup', setFlag(false));
                }
            }
            
            // Configurar controles móviles usando la función auxiliar
            setupButtonControls('mobile-forward', value => mobileForward = value);
            setupButtonControls('mobile-backward', value => mobileBackward = value);
            setupButtonControls('mobile-left', value => mobileLeft = value);
            setupButtonControls('mobile-right', value => mobileRight = value);
        }

        function onKeyDown(event) {
            // Si el chat está abierto, no procesar controles del juego
            if (chatOpen) {
                return;
            }
            
            // Procesar controles para ambas escenas
            const key = event.code.replace('Key', '');
            if (key in keys) keys[key] = true;
            if (event.code === 'ArrowUp') inputState.keyboard.W = true;
            if (event.code === 'ArrowDown') inputState.keyboard.S = true;
            if (event.code === 'ArrowLeft') inputState.keyboard.A = true;
            if (event.code === 'ArrowRight') inputState.keyboard.D = true;
            
            // Controles específicos del mall (cambio de pisos)
            if (gameState.currentScene === 'mall') {
            if (event.code === 'KeyW' && !inputState.keyboard.W) { // W para subir de piso (solo una vez)
                if (gameState.player.floor < MAX_FLOOR) gameState.player.floor++;
                inputState.keyboard.W = true;
            }
            if (event.code === 'KeyS' && !inputState.keyboard.S) { // S para bajar de piso (solo una vez)
                if (gameState.player.floor > MIN_FLOOR) gameState.player.floor--;
                inputState.keyboard.S = true;
            }
            if (event.code === 'KeyA') { // A para moverse hacia la izquierda
                inputState.keyboard.A = true;
            }
            if (event.code === 'KeyD') { // D para moverse hacia la derecha
                inputState.keyboard.D = true;
                }
            }
            
            // Controles de edición de muebles en la habitación personal
            if (gameState.currentScene === 'personal-room' && gameState.furniture.editMode && gameState.furniture.selected) {
                if (event.code === 'KeyW' || event.code === 'ArrowUp') {
                    moveSelectedFurniture('forward');
                }
                if (event.code === 'KeyS' || event.code === 'ArrowDown') {
                    moveSelectedFurniture('backward');
                }
                if (event.code === 'KeyA' || event.code === 'ArrowLeft') {
                    moveSelectedFurniture('left');
                }
                if (event.code === 'KeyD' || event.code === 'ArrowRight') {
                    moveSelectedFurniture('right');
                }
                if (event.code === 'KeyR') {
                    rotateSelectedFurniture();
                }
                if (event.code === 'Enter') {
                    saveFurniturePositions();
                }
                if (event.code === 'Escape') {
                    deselectFurniture();
                }
            }
        }

        function onKeyUp(event) {
            const key = event.code.replace('Key', '');
            if (key in keys) keys[key] = false;
            if (event.code === 'ArrowUp') inputState.keyboard.W = false;
            if (event.code === 'ArrowDown') inputState.keyboard.S = false;
            if (event.code === 'ArrowLeft') inputState.keyboard.A = false;
            if (event.code === 'ArrowRight') inputState.keyboard.D = false;
            
            // Controles específicos del mall
            if (gameState.currentScene === 'mall') {
            if (event.code === 'KeyA') inputState.keyboard.A = false;
            if (event.code === 'KeyD') inputState.keyboard.D = false;
            if (event.code === 'KeyW') inputState.keyboard.W = false;
            if (event.code === 'KeyS') inputState.keyboard.S = false;
            }
        }

        function onWindowResize() {
            // Actualizar cámara y renderer del mall
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Actualizar cámara y renderer de la habitación personal si existe
            if (personalRoomCamera && personalRoomRenderer) {
                personalRoomCamera.aspect = window.innerWidth / window.innerHeight;
                personalRoomCamera.updateProjectionMatrix();
                personalRoomRenderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        // Sistema centralizado de manejo de eventos de clic
        function handleGlobalClick(event) {
            const target = event.target;
            
            // 1. Verificar si es un clic en elementos de UI - NO procesar
            const isUIElement = target.closest('#ui-container') || 
                               target.closest('#chat-panel') || 
                               target.closest('#simple-panel') ||
                               target.closest('#room-navigation-panel') ||
                               target.closest('#ui-overlay') ||
                               target.closest('button') ||
                               target.closest('input') ||
                               target.closest('select');
            
            // Manejo especial para emoji panel
            const emojiPanel = document.getElementById('emoji-panel');
            const emojiToggle = document.getElementById('emoji-toggle');
            if (emojiPanel && emojiToggle && !emojiPanel.contains(target) && !emojiToggle.contains(target)) {
                emojiPanel.style.display = 'none';
            }
            
            if (isUIElement) {
                return; // NO procesar clics en elementos de UI
            }
            
            // 2. Verificar estado de la aplicación
            const overlay = document.getElementById('ui-overlay');
            const simplePanel = document.getElementById('simple-panel');
            const workingPanel = document.getElementById('working-customization-panel');
            
            // Si algún panel está abierto, cerrarlo al hacer clic fuera
            if (chatOpen && !chatPanel.contains(target) && !chatToggleBtn.contains(target)) {
                chatPanel.style.display = 'none';
                chatOpen = false;
                if (overlay) {
                    overlay.style.display = 'none';
                    overlay.style.pointerEvents = 'none';
                }
                return;
            }
            
            if (customizationPanelOpen && !customizationPanel.contains(target)) {
                closeCustomizationPanel();
                return;
            }
            
            if (workingPanel && !workingPanel.contains(target)) {
                closeWorkingPanel();
                return;
            }
            
            // Si el overlay está activo, no procesar clics del juego
            if (overlay && overlay.style.display === 'block' && overlay.style.pointerEvents === 'auto') {
                return;
            }
            
            // Si el chat está abierto, no procesar controles del juego
            if (chatOpen) {
                return;
            }
            
            // Si el panel de personalización está abierto, no procesar clics del juego
            if (simplePanel && simplePanel.style.display === 'block') {
                return;
            }
            
            // 3. Procesar clics del juego
            handleGameClick(event);
        }
        
        function handleGameClick(event) {
            if (event.button !== 0) return; // Solo clic izquierdo
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Si estamos en modo de edición de muebles, usar la cámara de la habitación
            if (gameState.currentScene === 'personal-room' && gameState.furniture.editMode) {
                raycaster.setFromCamera(mouse, personalRoomCamera);
                const furnitureIntersects = raycaster.intersectObjects(furnitureObjects.map(f => f.mesh));
                
                if (furnitureIntersects.length > 0) {
                    const clickedFurniture = furnitureIntersects[0].object;
                    const furniture = furnitureObjects.find(f => f.mesh === clickedFurniture);
                    if (furniture) {
                        selectFurniture(furniture.id);
                        return;
                    }
                }
            } else {
                // Comportamiento normal del mall
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(gameCollections.clickableObjects);
            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                
                // Verificar si es un clic en el nombre del avatar para personalización
                if (clickedObject.userData && clickedObject.userData.type === 'customization') {
                    openCustomizationPanel();
                    return;
                }
                
                // Verificar si es un clic en una tienda
                if (clickedObject.userData.URL) {
                    window.open(clickedObject.userData.URL, '_blank');
                    }
                }
            }
        }
        
        // Función original onMouseDown ahora usa el sistema centralizado
        function onMouseDown(event) {
            handleGlobalClick(event);
        }

        function updateMovement() {
            // Si el chat está abierto, no actualizar movimiento
            if (chatOpen) {
                return;
            }
            
            // --- Rotación con flechas izquierda/derecha y controles móviles ---
            if (inputState.keyboard.ArrowLeft || inputState.mobile.left) gameState.player.targetRotation -= ROTATE_SPEED;
            if (inputState.keyboard.ArrowRight || inputState.mobile.right) gameState.player.targetRotation += ROTATE_SPEED;

            // --- Movimiento hacia adelante/atrás con flechas y controles móviles ---
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();
            
            const velocity = new THREE.Vector3();
            
            // Movimiento hacia adelante/atrás con flechas arriba/abajo y controles móviles
            if (inputState.keyboard.ArrowUp || inputState.mobile.forward) velocity.add(direction);
            if (inputState.keyboard.ArrowDown || inputState.mobile.backward) velocity.sub(direction);
            
            // Movimiento lateral con A y D (teclas)
            const rightDirection = new THREE.Vector3();
            rightDirection.setFromMatrixColumn(camera.matrix, 0);
            rightDirection.y = 0;
            rightDirection.normalize();
            
            if (inputState.keyboard.A) velocity.sub(rightDirection); // Moverse hacia la izquierda
            if (inputState.keyboard.D) velocity.add(rightDirection); // Moverse hacia la derecha
            
            if (velocity.length() > 0) {
                velocity.normalize().multiplyScalar(MOVE_SPEED);
                const newPosition = gameState.player.targetPosition.clone().add(velocity);
                
                // --- Colisiones optimizadas ---
                const playerBox = new THREE.Box3().setFromCenterAndSize(newPosition, new THREE.Vector3(1.0, CAMERA_HEIGHT, 1.0));
                let collision = false;
                
                // Optimización: solo verificar colisiones cercanas
                const nearbyCollisions = collisionObjects.filter(wallBox => {
                    const distance = wallBox.getCenter(new THREE.Vector3()).distanceTo(newPosition);
                    return distance < 20; // Solo verificar objetos dentro de 20 unidades
                });
                
                for (const wallBox of nearbyCollisions) {
                    if (playerBox.intersectsBox(wallBox)) {
                        collision = true;
                        break;
                    }
                }
                
                if (!collision) {
                    gameState.player.targetPosition.copy(newPosition);
                }
            }

            // --- Cambio de Piso ---
            const floorStep = HALL_HEIGHT + 1;
            const targetY = gameState.player.floor * floorStep + CAMERA_HEIGHT;
            gameState.player.targetPosition.y = targetY;

            // --- Interpolación para suavidad ---
            camera.position.lerp(gameState.player.targetPosition, 0.2);
            camera.rotation.y = lerpAngle(camera.rotation.y, gameState.player.targetRotation, 0.2);
        }

        // --- Funciones del sistema de habitaciones personales ---
        function toggleRoomNavigation() {
            const roomNavigationPanel = document.getElementById('room-navigation-panel');
            if (roomNavigationPanel) {
                if (roomNavigationPanelOpen) {
                    roomNavigationPanel.style.display = 'none';
                    roomNavigationPanelOpen = false;
                } else {
                    roomNavigationPanel.style.display = 'flex';
                    roomNavigationPanelOpen = true;
                }
            }
        }
        
        function closeRoomNavigation() {
            const roomNavigationPanel = document.getElementById('room-navigation-panel');
            if (roomNavigationPanel) {
                roomNavigationPanel.style.display = 'none';
                roomNavigationPanelOpen = false;
            }
        }
        
        function enterPersonalRoom() {
            if (gameState.currentScene === 'personal-room') return;
            
            gameState.currentScene = 'personal-room';
            setupPersonalRoom();
            closeRoomNavigation();
            
            // Mostrar botón de regreso al mall
            const returnToMallBtn = document.getElementById('return-to-mall-btn');
            if (returnToMallBtn) {
                returnToMallBtn.style.display = 'flex';
            }
        }
        
        function returnToMall() {
            if (gameState.currentScene === 'mall') return;
            
            gameState.currentScene = 'mall';
            // Limpiar escena de habitación personal
            if (personalRoomRenderer) {
                document.body.removeChild(personalRoomRenderer.domElement);
                personalRoomRenderer.dispose();
            }
            // Mostrar escena del mall
            renderer.domElement.style.display = 'block';
            
            // Ocultar botón de regreso al mall
            const returnToMallBtn = document.getElementById('return-to-mall-btn');
            if (returnToMallBtn) {
                returnToMallBtn.style.display = 'none';
            }
        }
        
        function setupPersonalRoom() {
            // Ocultar escena del mall
            renderer.domElement.style.display = 'none';
            
            // Crear nueva escena para la habitación personal
            personalRoomScene = new THREE.Scene();
            personalRoomScene.background = new THREE.Color(0x2C3E50); // Azul oscuro
            
            // Crear cámara para la habitación
            personalRoomCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            personalRoomCamera.position.set(0, CAMERA_HEIGHT, 3); // Posición inicial en la habitación
            personalRoomCamera.lookAt(0, CAMERA_HEIGHT, 0);
            
            // Configurar posición y rotación objetivo para movimiento suave
            personalRoomTargetPosition = personalRoomCamera.position.clone();
            personalRoomTargetRotationY = personalRoomCamera.rotation.y;
            
            // Crear renderer para la habitación
            personalRoomRenderer = new THREE.WebGLRenderer({ antialias: true });
            personalRoomRenderer.setSize(window.innerWidth, window.innerHeight);
            personalRoomRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            personalRoomRenderer.shadowMap.enabled = false;
            personalRoomRenderer.domElement.style.zIndex = '1';
            document.body.appendChild(personalRoomRenderer.domElement);
            
            // Crear iluminación para la habitación
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            personalRoomScene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            personalRoomScene.add(directionalLight);
            
            // Crear habitación
            createPersonalRoom();
            // Crear y actualizar cielo visible desde las ventanas
            // Eliminar la línea:
            // createPersonalRoomSky();
            // Y también:
            // if (personalRoomSkyInterval) clearInterval(personalRoomSkyInterval);
            // personalRoomSkyInterval = setInterval(updatePersonalRoomSky, 60000); // Actualizar cada minuto
            // updatePersonalRoomSky();
            
            // Iniciar animación de la habitación
            animatePersonalRoom();
        }
        
        function createPersonalRoom() {
            // Dimensiones de la habitación (más grande)
            const roomWidth = 12;
            const roomHeight = 3.5;
            const roomDepth = 12;
            
            // Materiales
            const wallMaterial = getCachedMaterial(0xE8E8E8, 0.9); // Gris claro
            const floorMaterial = getCachedMaterial(0x8B4513, 0.8, 0.1); // Marrón madera
            const ceilingMaterial = getCachedMaterial(0xF5F5F5, 0.9); // Blanco
            
            // Paredes
            const wallGeometry = new THREE.BoxGeometry(roomWidth, roomHeight, 0.2);
            // Pared trasera
            const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
            backWall.position.set(0, roomHeight/2, -roomDepth/2);
            personalRoomScene.add(backWall);
            // Pared izquierda
            const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
            leftWall.position.set(-roomWidth/2, roomHeight/2, 0);
            leftWall.rotation.y = Math.PI / 2;
            personalRoomScene.add(leftWall);
            // Pared derecha
            const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
            rightWall.position.set(roomWidth/2, roomHeight/2, 0);
            rightWall.rotation.y = -Math.PI / 2;
            personalRoomScene.add(rightWall);
            // Pared frontal (con puerta)
            const frontWallLeft = new THREE.Mesh(new THREE.BoxGeometry(roomWidth/2 - 0.5, roomHeight, 0.2), wallMaterial);
            frontWallLeft.position.set(-roomWidth/4 - 0.25, roomHeight/2, roomDepth/2);
            personalRoomScene.add(frontWallLeft);
            const frontWallRight = new THREE.Mesh(new THREE.BoxGeometry(roomWidth/2 - 0.5, roomHeight, 0.2), wallMaterial);
            frontWallRight.position.set(roomWidth/4 + 0.25, roomHeight/2, roomDepth/2);
            personalRoomScene.add(frontWallRight);
            // Puerta mejorada (paneles y manija)
            const doorGeometry = new THREE.BoxGeometry(1, 2.2, 0.1);
            const doorMaterial = getCachedMaterial(0x7B4A1E, 0.85, 0.18); // Madera más cálida
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 1.1, roomDepth/2);
            personalRoomScene.add(door);
            // Paneles de la puerta (relieve)
            const panelMat = getCachedMaterial(0xA67C52, 0.7, 0.25);
            for (let i = 0; i < 3; i++) {
                const panelGeo = new THREE.BoxGeometry(0.7, 0.4, 0.04);
                const panel = new THREE.Mesh(panelGeo, panelMat);
                panel.position.set(0, 1.7 - i * 0.7, roomDepth/2 + 0.055);
                personalRoomScene.add(panel);
            }
            // Manija de la puerta
            const handleGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.18, 16);
            const handleMat = getCachedMaterial(0xCCCCCC, 0.4, 0.7);
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.rotation.z = Math.PI / 2;
            handle.position.set(0.38, 1.1, roomDepth/2 + 0.09);
            personalRoomScene.add(handle);
            // --- Ventanas grandes mejoradas ---
            const skyColor = getSkyColorByHour();
            // Ventana trasera grande (con bisel y reflejo)
            const windowW = 4.5, windowH = 2.2;
            const windowGeometry = new THREE.BoxGeometry(windowW, windowH, 0.08);
            const windowMaterial = new THREE.MeshPhysicalMaterial({ color: skyColor, transparent: true, opacity: 0.82, roughness: 0.15, metalness: 0.2, reflectivity: 0.45, clearcoat: 0.5, clearcoatRoughness: 0.1, transmission: 0.85, ior: 1.45 });
            const backWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            backWindow.position.set(0, 1.7, -roomDepth/2 + 0.13);
            personalRoomScene.add(backWindow);
            // Bisel y marco ventana trasera
            const frameGeometry = new THREE.BoxGeometry(windowW + 0.18, windowH + 0.18, 0.12);
            const frameMaterial = getCachedMaterial(0xE0E0E0, 0.95, 0.18);
            const backFrame = new THREE.Mesh(frameGeometry, frameMaterial);
            backFrame.position.copy(backWindow.position);
            personalRoomScene.add(backFrame);
            // Cruces del marco (vertical y horizontal)
            const crossMat = getCachedMaterial(0xD0D0D0, 0.9, 0.18);
            const crossV = new THREE.Mesh(new THREE.BoxGeometry(0.08, windowH + 0.1, 0.13), crossMat);
            crossV.position.copy(backWindow.position);
            personalRoomScene.add(crossV);
            const crossH = new THREE.Mesh(new THREE.BoxGeometry(windowW + 0.1, 0.08, 0.13), crossMat);
            crossH.position.copy(backWindow.position);
            personalRoomScene.add(crossH);
            // Ventana izquierda grande
            const leftWindow = new THREE.Mesh(windowGeometry, windowMaterial.clone());
            leftWindow.position.set(-roomWidth/2 + 0.13, 1.7, 0);
            leftWindow.rotation.y = Math.PI / 2;
            personalRoomScene.add(leftWindow);
            const leftFrame = new THREE.Mesh(frameGeometry, frameMaterial);
            leftFrame.position.copy(leftWindow.position);
            leftFrame.rotation.y = Math.PI / 2;
            personalRoomScene.add(leftFrame);
            // Cruces marco izquierdo
            const leftCrossV = new THREE.Mesh(new THREE.BoxGeometry(0.08, windowH + 0.1, 0.13), crossMat);
            leftCrossV.position.copy(leftWindow.position);
            leftCrossV.rotation.y = Math.PI / 2;
            personalRoomScene.add(leftCrossV);
            const leftCrossH = new THREE.Mesh(new THREE.BoxGeometry(windowW + 0.1, 0.08, 0.13), crossMat);
            leftCrossH.position.copy(leftWindow.position);
            leftCrossH.rotation.y = Math.PI / 2;
            personalRoomScene.add(leftCrossH);
            // Ventana derecha grande
            const rightWindow = new THREE.Mesh(windowGeometry, windowMaterial.clone());
            rightWindow.position.set(roomWidth/2 - 0.13, 1.7, 0);
            rightWindow.rotation.y = -Math.PI / 2;
            personalRoomScene.add(rightWindow);
            const rightFrame = new THREE.Mesh(frameGeometry, frameMaterial);
            rightFrame.position.copy(rightWindow.position);
            rightFrame.rotation.y = -Math.PI / 2;
            personalRoomScene.add(rightFrame);
            // Cruces marco derecho
            const rightCrossV = new THREE.Mesh(new THREE.BoxGeometry(0.08, windowH + 0.1, 0.13), crossMat);
            rightCrossV.position.copy(rightWindow.position);
            rightCrossV.rotation.y = -Math.PI / 2;
            personalRoomScene.add(rightCrossV);
            const rightCrossH = new THREE.Mesh(new THREE.BoxGeometry(windowW + 0.1, 0.08, 0.13), crossMat);
            rightCrossH.position.copy(rightWindow.position);
            rightCrossH.rotation.y = -Math.PI / 2;
            personalRoomScene.add(rightCrossH);
            // Actualizar color del cielo cada minuto
            setInterval(() => {
                const newSky = getSkyColorByHour();
                [backWindow, leftWindow, rightWindow].forEach(w => w.material.color.set(newSky));
            }, 60000);
            // Muebles básicos
            createRoomFurniture(roomWidth, roomHeight, roomDepth);
            // Cargar posiciones guardadas de muebles
            loadFurniturePositions();
        }
        
        function createRoomFurniture(roomWidth, roomHeight, roomDepth) {
            // Limpiar array de muebles
            furnitureObjects = [];
            let furnitureId = 1;
            
            // ===== ZONA DE DORMITORIO (Lado izquierdo) =====
            
            // Cama principal - Crear grupo para todas las partes
            const bedGroup = new THREE.Group();
            bedGroup.position.set(-4, 0, -3);
            
            // Marco de la cama
            const bedFrameGeometry = new THREE.BoxGeometry(2.2, 0.4, 3.2);
            const bedFrameMaterial = getCachedMaterial(0x8B4513, 0.7, 0.1);
            const bedFrame = new THREE.Mesh(bedFrameGeometry, bedFrameMaterial);
            bedFrame.position.set(0, 0.2, 0);
            bedGroup.add(bedFrame);
            
            // Registrar grupo de cama en el array de muebles
            furnitureObjects.push({
                id: furnitureId++,
                name: 'Cama',
                mesh: bedGroup,
                type: 'bed'
            });
            
            // Colchón
            const mattressGeometry = new THREE.BoxGeometry(2, 0.3, 3);
            const mattressMaterial = getCachedMaterial(0x4A90E2, 0.8, 0.1); // Azul
            const mattress = new THREE.Mesh(mattressGeometry, mattressMaterial);
            mattress.position.set(0, 0.5, 0);
            bedGroup.add(mattress);
            
            // Almohadas
            const pillowGeometry = new THREE.BoxGeometry(0.6, 0.15, 0.8);
            const pillowMaterial = getCachedMaterial(0xFFFFFF, 0.9, 0.1);
            const pillow1 = new THREE.Mesh(pillowGeometry, pillowMaterial);
            pillow1.position.set(-0.3, 0.65, -1.2);
            bedGroup.add(pillow1);
            
            const pillow2 = new THREE.Mesh(pillowGeometry, pillowMaterial);
            pillow2.position.set(0.3, 0.65, -1.2);
            bedGroup.add(pillow2);
            
            // Agregar el grupo completo a la escena
            personalRoomScene.add(bedGroup);
            
            // Mesa de noche izquierda
            const nightstandGeometry = new THREE.BoxGeometry(0.8, 0.7, 0.8);
            const nightstandMaterial = getCachedMaterial(0x8B4513, 0.7, 0.1);
            const nightstandLeft = new THREE.Mesh(nightstandGeometry, nightstandMaterial);
            nightstandLeft.position.set(-5.5, 0.35, -3);
            personalRoomScene.add(nightstandLeft);
            
            // Registrar mesa de noche izquierda en el array de muebles
            furnitureObjects.push({
                id: furnitureId++,
                name: 'Mesa de Noche Izquierda',
                mesh: nightstandLeft,
                type: 'nightstand'
            });
            
            // Mesa de noche derecha
            const nightstandRight = new THREE.Mesh(nightstandGeometry, nightstandMaterial);
            nightstandRight.position.set(-2.5, 0.35, -3);
            personalRoomScene.add(nightstandRight);
            
            // Registrar mesa de noche derecha en el array de muebles
            furnitureObjects.push({
                id: furnitureId++,
                name: 'Mesa de Noche Derecha',
                mesh: nightstandRight,
                type: 'nightstand'
            });
            
            // Lámpara de mesa - Crear grupo para todas las partes
            const lampGroup = new THREE.Group();
            lampGroup.position.set(-5.5, 0, -3);
            
            const lampBaseGeometry = new THREE.CylinderGeometry(0.1, 0.15, 0.1, 8);
            const lampBaseMaterial = getCachedMaterial(0x2C3E50, 0.8, 0.2);
            const lampBase = new THREE.Mesh(lampBaseGeometry, lampBaseMaterial);
            lampBase.position.set(0, 0.75, 0);
            lampGroup.add(lampBase);
            
            const lampPoleGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.4, 6);
            const lampPoleMaterial = getCachedMaterial(0x2C3E50, 0.8, 0.2);
            const lampPole = new THREE.Mesh(lampPoleGeometry, lampPoleMaterial);
            lampPole.position.set(0, 1, 0);
            lampGroup.add(lampPole);
            
            const lampShadeGeometry = new THREE.ConeGeometry(0.3, 0.2, 8);
            const lampShadeMaterial = getCachedMaterial(0xECF0F1, 0.9, 0.1);
            const lampShade = new THREE.Mesh(lampShadeGeometry, lampShadeMaterial);
            lampShade.position.set(0, 1.25, 0);
            lampShade.rotation.x = Math.PI;
            lampGroup.add(lampShade);
            
            // Registrar grupo de lámpara en el array de muebles
            furnitureObjects.push({
                id: furnitureId++,
                name: 'Lámpara de Mesa',
                mesh: lampGroup,
                type: 'lamp'
            });
            
            // Agregar el grupo completo a la escena
            personalRoomScene.add(lampGroup);
            
            // ===== ZONA DE TRABAJO (Lado derecho) =====
            
            // Escritorio principal - Crear grupo para todas las partes
            const deskGroup = new THREE.Group();
            deskGroup.position.set(4, 0, -3);
            
            // Mesa del escritorio
            const deskGeometry = new THREE.BoxGeometry(2.5, 0.1, 1.2);
            const deskMaterial = getCachedMaterial(0x8B4513, 0.7, 0.1);
            const desk = new THREE.Mesh(deskGeometry, deskMaterial);
            desk.position.set(0, 0.7, 0);
            deskGroup.add(desk);
            
            // Registrar grupo de escritorio en el array de muebles
            furnitureObjects.push({
                id: furnitureId++,
                name: 'Escritorio',
                mesh: deskGroup,
                type: 'desk'
            });
            
            // Patas del escritorio
            for (let i = 0; i < 4; i++) {
                const legGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.7, 6);
                const legMaterial = getCachedMaterial(0x8B4513, 0.7, 0.1);
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                const x = (i % 2 === 0 ? -1 : 1) * 1.2;
                const z = (i < 2 ? -1 : 1) * 0.5;
                leg.position.set(x, 0.35, z);
                deskGroup.add(leg);
            }
            
            // Agregar el grupo completo a la escena
            personalRoomScene.add(deskGroup);
            
            // Silla ergonómica del escritorio - Crear grupo para todas las partes
            const chairGroup = new THREE.Group();
            chairGroup.position.set(4, 0, -1.8);
            
            // Asiento de la silla
            const chairSeatGeometry = new THREE.BoxGeometry(0.7, 0.1, 0.7);
            const chairSeatMaterial = getCachedMaterial(0x2C3E50, 0.8, 0.1);
            const chairSeat = new THREE.Mesh(chairSeatGeometry, chairSeatMaterial);
            chairSeat.position.set(0, 0.45, 0);
            chairGroup.add(chairSeat);
            
            // Registrar grupo de silla en el array de muebles
            furnitureObjects.push({
                id: furnitureId++,
                name: 'Silla de Escritorio',
                mesh: chairGroup,
                type: 'chair'
            });
            
            // Respaldo de la silla
            const chairBackGeometry = new THREE.BoxGeometry(0.7, 0.8, 0.1);
            const chairBackMaterial = getCachedMaterial(0x2C3E50, 0.8, 0.1);
            const chairBack = new THREE.Mesh(chairBackGeometry, chairBackMaterial);
            chairBack.position.set(0, 0.85, -0.4);
            chairGroup.add(chairBack);
            
            // Patas de la silla
            for (let i = 0; i < 4; i++) {
                const chairLegGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.45, 6);
                const chairLegMaterial = getCachedMaterial(0x2C3E50, 0.8, 0.1);
                const chairLeg = new THREE.Mesh(chairLegGeometry, chairLegMaterial);
                const x = (i % 2 === 0 ? -1 : 1) * 0.3;
                const z = (i < 2 ? -1 : 1) * 0.3;
                chairLeg.position.set(x, 0.225, z);
                chairGroup.add(chairLeg);
            }
            
            // Agregar el grupo completo a la escena
            personalRoomScene.add(chairGroup);
            
            // Computadora completa - Crear grupo para todas las partes
            const computerGroup = new THREE.Group();
            computerGroup.position.set(4, 0, -3);
            
            const monitorGeometry = new THREE.BoxGeometry(1.4, 0.9, 0.1);
            const monitorMaterial = getCachedMaterial(0x000000, 0.8, 0.2);
            const monitor = new THREE.Mesh(monitorGeometry, monitorMaterial);
            monitor.position.set(0, 1.3, 0);
            computerGroup.add(monitor);
            
            // Base del monitor
            const monitorBaseGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.1, 8);
            const monitorBaseMaterial = getCachedMaterial(0x2C3E50, 0.8, 0.2);
            const monitorBase = new THREE.Mesh(monitorBaseGeometry, monitorBaseMaterial);
            monitorBase.position.set(0, 0.8, 0);
            computerGroup.add(monitorBase);
            
            // CPU/Torre
            const cpuGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.2);
            const cpuMaterial = getCachedMaterial(0x2C3E50, 0.8, 0.2);
            const cpu = new THREE.Mesh(cpuGeometry, cpuMaterial);
            cpu.position.set(1.5, 0.7, 0);
            computerGroup.add(cpu);
            
            // Teclado
            const keyboardGeometry = new THREE.BoxGeometry(1.2, 0.05, 0.4);
            const keyboardMaterial = getCachedMaterial(0x34495E, 0.8, 0.1);
            const keyboard = new THREE.Mesh(keyboardGeometry, keyboardMaterial);
            keyboard.position.set(0, 0.75, 0.5);
            computerGroup.add(keyboard);
            
            // Mouse
            const mouseGeometry = new THREE.BoxGeometry(0.12, 0.05, 0.2);
            const mouseMaterial = getCachedMaterial(0x34495E, 0.8, 0.1);
            const mouse = new THREE.Mesh(mouseGeometry, mouseMaterial);
            mouse.position.set(1.2, 0.75, 0.5);
            computerGroup.add(mouse);
            
            // Registrar grupo de computadora en el array de muebles
            furnitureObjects.push({
                id: furnitureId++,
                name: 'Computadora',
                mesh: computerGroup,
                type: 'computer'
            });
            
            // Agregar el grupo completo a la escena
            personalRoomScene.add(computerGroup);
            
            // ===== ZONA DE ALMACENAMIENTO =====
            
            // Estantería grande - Crear grupo para todas las partes
            const shelfGroup = new THREE.Group();
            shelfGroup.position.set(5.5, 0, 0);
            
            // Estructura principal de la estantería
            const shelfGeometry = new THREE.BoxGeometry(2, 2.2, 0.5);
            const shelfMaterial = getCachedMaterial(0x8B4513, 0.7, 0.1);
            const shelf = new THREE.Mesh(shelfGeometry, shelfMaterial);
            shelf.position.set(0, 1.1, 0);
            shelfGroup.add(shelf);
            
            // Registrar grupo de estantería en el array de muebles
            furnitureObjects.push({
                id: furnitureId++,
                name: 'Estantería',
                mesh: shelfGroup,
                type: 'shelf'
            });
            
            // Estantes de la estantería
            for (let i = 0; i < 4; i++) {
                const shelfLevelGeometry = new THREE.BoxGeometry(2, 0.05, 0.5);
                const shelfLevel = new THREE.Mesh(shelfLevelGeometry, shelfMaterial);
                shelfLevel.position.set(0, 0.3 + i * 0.5, 0);
                shelfGroup.add(shelfLevel);
            }
            
            // Libros en la estantería
            for (let i = 0; i < 8; i++) {
                const bookGeometry = new THREE.BoxGeometry(0.15, 0.25, 0.4);
                const bookMaterial = getCachedMaterial(0xE74C3C + i * 0x111111, 0.8, 0.1);
                const book = new THREE.Mesh(bookGeometry, bookMaterial);
                const row = Math.floor(i / 4);
                const col = i % 4;
                book.position.set((col - 1.5) * 0.2, 0.4 + row * 0.5, 0);
                shelfGroup.add(book);
            }
            
            // Agregar el grupo completo a la escena
            personalRoomScene.add(shelfGroup);
            
            // ===== ZONA DE RELAX (Centro) =====
            
            // Sofá pequeño - Crear grupo para todas las partes
            const sofaGroup = new THREE.Group();
            sofaGroup.position.set(0, 0, 2);
            
            // Estructura principal del sofá
            const sofaGeometry = new THREE.BoxGeometry(2.5, 0.8, 1);
            const sofaMaterial = getCachedMaterial(0x3498DB, 0.8, 0.1);
            const sofa = new THREE.Mesh(sofaGeometry, sofaMaterial);
            sofa.position.set(0, 0.4, 0);
            sofaGroup.add(sofa);
            
            // Registrar grupo de sofá en el array de muebles
            furnitureObjects.push({
                id: furnitureId++,
                name: 'Sofá',
                mesh: sofaGroup,
                type: 'sofa'
            });
            
            // Cojines del sofá
            for (let i = 0; i < 3; i++) {
                const cushionGeometry = new THREE.BoxGeometry(0.7, 0.2, 0.8);
                const cushionMaterial = getCachedMaterial(0x2980B9, 0.8, 0.1);
                const cushion = new THREE.Mesh(cushionGeometry, cushionMaterial);
                cushion.position.set(-0.8 + i * 0.8, 0.6, 0);
                sofaGroup.add(cushion);
            }
            
            // Agregar el grupo completo a la escena
            personalRoomScene.add(sofaGroup);
            
            // Mesa de centro - Crear grupo para todas las partes
            const coffeeTableGroup = new THREE.Group();
            coffeeTableGroup.position.set(0, 0, 3.5);
            
            const coffeeTableGeometry = new THREE.BoxGeometry(1.2, 0.1, 0.8);
            const coffeeTableMaterial = getCachedMaterial(0x8B4513, 0.7, 0.1);
            const coffeeTable = new THREE.Mesh(coffeeTableGeometry, coffeeTableMaterial);
            coffeeTable.position.set(0, 0.5, 0);
            coffeeTableGroup.add(coffeeTable);
            
            // Patas de la mesa de centro
            for (let i = 0; i < 4; i++) {
                const tableLegGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 6);
                const tableLegMaterial = getCachedMaterial(0x8B4513, 0.7, 0.1);
                const tableLeg = new THREE.Mesh(tableLegGeometry, tableLegMaterial);
                const x = (i % 2 === 0 ? -1 : 1) * 0.5;
                const z = (i < 2 ? -1 : 1) * 0.3;
                tableLeg.position.set(x, 0.25, z);
                coffeeTableGroup.add(tableLeg);
            }
            
            // Registrar grupo de mesa de centro en el array de muebles
            furnitureObjects.push({
                id: furnitureId++,
                name: 'Mesa de Centro',
                mesh: coffeeTableGroup,
                type: 'table'
            });
            
            // Agregar el grupo completo a la escena
            personalRoomScene.add(coffeeTableGroup);
            
            // ===== ELEMENTOS DECORATIVOS =====
            
            // Ventana principal (más grande)
            const windowGeometry = new THREE.BoxGeometry(3, 2, 0.1);
            const windowMaterial = getCachedMaterial(0x87CEEB, 0.3, 0.8);
            const window = new THREE.Mesh(windowGeometry, windowMaterial);
            window.position.set(0, 1.75, roomDepth/2 - 0.1);
            personalRoomScene.add(window);
            
            // Marco de la ventana
            const windowFrameGeometry = new THREE.BoxGeometry(3.2, 2.2, 0.2);
            const windowFrameMaterial = getCachedMaterial(0xFFFFFF, 0.9, 0.1);
            const windowFrame = new THREE.Mesh(windowFrameGeometry, windowFrameMaterial);
            windowFrame.position.set(0, 1.75, roomDepth/2 - 0.05);
            personalRoomScene.add(windowFrame);
            
            // Alfombra
            const carpetGeometry = new THREE.BoxGeometry(8, 0.05, 6);
            const carpetMaterial = getCachedMaterial(0xE67E22, 0.8, 0.1);
            const carpet = new THREE.Mesh(carpetGeometry, carpetMaterial);
            carpet.position.set(0, 0.025, 0);
            personalRoomScene.add(carpet);
            
            // Lámpara de techo
            const ceilingLampGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.2, 8);
            const ceilingLampMaterial = getCachedMaterial(0xF1C40F, 0.8, 0.2);
            const ceilingLamp = new THREE.Mesh(ceilingLampGeometry, ceilingLampMaterial);
            ceilingLamp.position.set(0, roomHeight - 0.1, 0);
            personalRoomScene.add(ceilingLamp);
            
            // Cable de la lámpara
            const lampCableGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 6);
            const lampCableMaterial = getCachedMaterial(0x2C3E50, 0.8, 0.1);
            const lampCable = new THREE.Mesh(lampCableGeometry, lampCableMaterial);
            lampCable.position.set(0, roomHeight - 0.35, 0);
            personalRoomScene.add(lampCable);
        }
        
        function updatePersonalRoomMovement() {
            // Si el chat está abierto, no actualizar movimiento
            if (chatOpen) {
                return;
            }
            
            // --- Rotación con flechas izquierda/derecha y controles móviles ---
            if (keys.ArrowLeft || mobileLeft) personalRoomTargetRotationY += ROTATE_SPEED;
            if (keys.ArrowRight || mobileRight) personalRoomTargetRotationY -= ROTATE_SPEED;

            // --- Movimiento hacia adelante/atrás con flechas y controles móviles ---
            const direction = new THREE.Vector3();
            personalRoomCamera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();
            
            const velocity = new THREE.Vector3();
            
            // Movimiento hacia adelante/atrás con flechas arriba/abajo y controles móviles
            if (keys.ArrowUp || mobileForward) velocity.add(direction);
            if (keys.ArrowDown || mobileBackward) velocity.sub(direction);
            
            // Movimiento lateral con A y D (teclas)
            const rightDirection = new THREE.Vector3();
            rightDirection.setFromMatrixColumn(personalRoomCamera.matrix, 0);
            rightDirection.y = 0;
            rightDirection.normalize();
            
            if (keyA) velocity.sub(rightDirection); // Moverse hacia la izquierda
            if (keyD) velocity.add(rightDirection); // Moverse hacia la derecha
            
            if (velocity.length() > 0) {
                velocity.normalize().multiplyScalar(MOVE_SPEED);
                const newPosition = personalRoomTargetPosition.clone().add(velocity);
                
                // --- Límites de la habitación (12x12 metros) ---
                const roomBounds = {
                    minX: -5.5,
                    maxX: 5.5,
                    minZ: -5.5,
                    maxZ: 5.5
                };
                
                // Aplicar límites de la habitación
                newPosition.x = Math.max(roomBounds.minX, Math.min(roomBounds.maxX, newPosition.x));
                newPosition.z = Math.max(roomBounds.minZ, Math.min(roomBounds.maxZ, newPosition.z));
                
                personalRoomTargetPosition.copy(newPosition);
            }

            // --- Mantener altura fija en la habitación ---
            personalRoomTargetPosition.y = CAMERA_HEIGHT;
        }
        
        function animatePersonalRoom() {
            requestAnimationFrame(animatePersonalRoom);
            
            // Actualizar movimiento en la habitación personal
            updatePersonalRoomMovement();
            
            // Aplicar movimiento suave a la cámara
            personalRoomCamera.position.lerp(personalRoomTargetPosition, 0.2);
            personalRoomCamera.rotation.y = lerpAngle(personalRoomCamera.rotation.y, personalRoomTargetRotationY, 0.2);
            
            personalRoomRenderer.render(personalRoomScene, personalRoomCamera);
        }
        
        function customizeRoom() {
            // Función placeholder para personalización de habitación
            alert('Función de personalización de habitación próximamente disponible');
        }
        
        // --- Funciones del sistema de edición de muebles ---
        function toggleFurnitureEditMode() {
            if (gameState.currentScene !== 'personal-room') {
                alert('Debes estar en tu habitación para editar muebles');
                return;
            }
            
            gameState.furniture.editMode = !gameState.furniture.editMode;
            
            if (furnitureEditMode) {
                // Limpiar todos los resaltados al entrar en modo de edición
                clearAllFurnitureHighlights();
                openFurnitureEditPanel();
                setupFurnitureSelection();
            } else {
                closeFurnitureEditPanel();
                deselectFurniture();
            }
        }
        
        function openFurnitureEditPanel() {
            const furnitureEditPanel = document.getElementById('furniture-edit-panel');
            if (furnitureEditPanel) {
                furnitureEditPanel.style.display = 'flex';
                furnitureEditPanelOpen = true;
                updateFurnitureList();
            }
        }
        
        function closeFurnitureEditPanel() {
            const furnitureEditPanel = document.getElementById('furniture-edit-panel');
            if (furnitureEditPanel) {
                furnitureEditPanel.style.display = 'none';
                furnitureEditPanelOpen = false;
            }
            furnitureEditMode = false;
            // Limpiar todos los resaltados al cerrar el panel
            clearAllFurnitureHighlights();
            deselectFurniture();
        }
        
        function setupFurnitureSelection() {
            // Hacer todos los muebles clickeables
            furnitureObjects.forEach(furniture => {
                if (furniture.mesh) {
                    furniture.mesh.userData.clickable = true;
                    furniture.mesh.userData.furnitureId = furniture.id;
                }
            });
        }
        
        function updateFurnitureList() {
            const furnitureList = document.getElementById('furniture-list');
            if (!furnitureList) return;
            
            furnitureList.innerHTML = '';
            
            furnitureObjects.forEach(furniture => {
                const furnitureItem = document.createElement('div');
                furnitureItem.style.cssText = 'padding: 12px; margin: 6px 0; background: rgba(52,73,94,0.8); border-radius: 8px; cursor: pointer; border: 2px solid transparent; transition: all 0.2s;';
                furnitureItem.innerHTML = `
                    <div style="font-weight: bold; color: #fff; font-size: 16px; margin-bottom: 4px;">${furniture.name}</div>
                    <div style="font-size: 14px; color: #bdc3c7;">Posición: (${furniture.mesh.position.x.toFixed(1)}, ${furniture.mesh.position.z.toFixed(1)})</div>
                `;
                
                furnitureItem.onclick = () => selectFurniture(furniture.id);
                furnitureItem.onmouseenter = () => furnitureItem.style.borderColor = '#3498db';
                furnitureItem.onmouseleave = () => furnitureItem.style.borderColor = 'transparent';
                
                if (selectedFurniture && selectedFurniture.id === furniture.id) {
                    furnitureItem.style.borderColor = '#27ae60';
                    furnitureItem.style.background = 'rgba(39,174,96,0.8)';
                }
                
                furnitureList.appendChild(furnitureItem);
            });
        }
        
        function loadFurniturePositions() {
            const savedPositions = localStorage.getItem('furniturePositions');
            if (savedPositions) {
                try {
                    const furniturePositions = JSON.parse(savedPositions);
                    furnitureObjects.forEach(furniture => {
                        const savedData = furniturePositions[furniture.id];
                        if (savedData && furniture.mesh) {
                            // Aplicar posición guardada
                            furniture.mesh.position.set(
                                savedData.position.x,
                                savedData.position.y,
                                savedData.position.z
                            );
                            // Aplicar rotación guardada
                            furniture.mesh.rotation.y = savedData.rotation.y;
                        }
                    });
                    console.log('Posiciones de muebles cargadas desde localStorage');
                } catch (error) {
                    console.error('Error al cargar posiciones de muebles:', error);
                }
            }
        }
        
        function selectFurniture(furnitureId) {
            const furniture = furnitureObjects.find(f => f.id === furnitureId);
            if (!furniture) return;
            
            // Limpiar todos los resaltados primero
            clearAllFurnitureHighlights();
            
            selectedFurniture = furniture;
            
            // Ocultar la ventana de la habitación cuando se selecciona un mueble
            const roomNavigationPanel = document.getElementById('room-navigation-panel');
            if (roomNavigationPanel) {
                roomNavigationPanel.style.display = 'none';
            }
            
            // Resaltar SOLO el mueble seleccionado
            if (furniture.mesh) {
                if (furniture.mesh.children && furniture.mesh.children.length > 0) {
                    // Si es un grupo, resaltar todos los hijos
                    furniture.mesh.children.forEach(child => {
                        if (child.material) {
                            child.material.emissive = new THREE.Color(0x27ae60);
                            child.material.emissiveIntensity = 0.3;
                        }
                    });
                } else {
                    // Si es un mueble individual, resaltar directamente
                    if (furniture.mesh.material) {
                        furniture.mesh.material.emissive = new THREE.Color(0x27ae60);
                        furniture.mesh.material.emissiveIntensity = 0.3;
                    }
                }
            }
            
            updateFurnitureList();
        }
        
        function clearAllFurnitureHighlights() {
            // Limpiar resaltado de todos los muebles
            furnitureObjects.forEach(furniture => {
                if (furniture.mesh) {
                    if (furniture.mesh.children && furniture.mesh.children.length > 0) {
                        // Si es un grupo, quitar resaltado de todos los hijos
                        furniture.mesh.children.forEach(child => {
                            if (child.material) {
                                child.material.emissive = new THREE.Color(0x000000);
                                child.material.emissiveIntensity = 0;
                            }
                        });
                    } else {
                        // Si es un mueble individual, quitar resaltado directamente
                        if (furniture.mesh.material) {
                            furniture.mesh.material.emissive = new THREE.Color(0x000000);
                            furniture.mesh.material.emissiveIntensity = 0;
                        }
                    }
                }
            });
        }
        
        function deselectFurniture() {
            if (selectedFurniture && selectedFurniture.mesh) {
                if (selectedFurniture.mesh.children && selectedFurniture.mesh.children.length > 0) {
                    // Si es un grupo, quitar resaltado de todos los hijos
                    selectedFurniture.mesh.children.forEach(child => {
                        if (child.material) {
                            child.material.emissive = new THREE.Color(0x000000);
                            child.material.emissiveIntensity = 0;
                        }
                    });
                } else {
                    // Si es un mueble individual, quitar resaltado directamente
                    if (selectedFurniture.mesh.material) {
                        selectedFurniture.mesh.material.emissive = new THREE.Color(0x000000);
                        selectedFurniture.mesh.material.emissiveIntensity = 0;
                    }
                }
            }
            selectedFurniture = null;
            updateFurnitureList();
            
            // Mostrar la ventana de la habitación cuando se deselecciona un mueble
            const roomNavigationPanel = document.getElementById('room-navigation-panel');
            if (roomNavigationPanel && roomNavigationPanelOpen) {
                roomNavigationPanel.style.display = 'flex';
            }
        }
        
        function moveSelectedFurniture(direction) {
            if (!selectedFurniture || !selectedFurniture.mesh) return;
            
            const moveSpeed = 0.2;
            const currentPosition = selectedFurniture.mesh.position.clone();
            
            switch (direction) {
                case 'forward':
                    currentPosition.z -= moveSpeed;
                    break;
                case 'backward':
                    currentPosition.z += moveSpeed;
                    break;
                case 'left':
                    currentPosition.x -= moveSpeed;
                    break;
                case 'right':
                    currentPosition.x += moveSpeed;
                    break;
            }
            
            // Aplicar límites de la habitación
            const roomBounds = {
                minX: -5.5,
                maxX: 5.5,
                minZ: -5.5,
                maxZ: 5.5
            };
            
            currentPosition.x = Math.max(roomBounds.minX, Math.min(roomBounds.maxX, currentPosition.x));
            currentPosition.z = Math.max(roomBounds.minZ, Math.min(roomBounds.maxZ, currentPosition.z));
            
            // Mover el grupo completo
            selectedFurniture.mesh.position.set(currentPosition.x, currentPosition.y, currentPosition.z);
            updateFurnitureList();
            
            // Guardar automáticamente la posición sin deseleccionar
            saveFurniturePositionsSilently();
        }
        
        function rotateSelectedFurniture() {
            if (!selectedFurniture || !selectedFurniture.mesh) return;
            
            selectedFurniture.mesh.rotation.y += Math.PI / 4; // Rotar 45 grados
            updateFurnitureList();
            
            // Guardar automáticamente la rotación sin deseleccionar
            saveFurniturePositionsSilently();
        }
        
        function saveFurniturePositions() {
            // Guardar todas las posiciones de muebles en localStorage
            const furniturePositions = {};
            furnitureObjects.forEach(furniture => {
                furniturePositions[furniture.id] = {
                    position: {
                        x: furniture.mesh.position.x,
                        y: furniture.mesh.position.y,
                        z: furniture.mesh.position.z
                    },
                    rotation: {
                        y: furniture.mesh.rotation.y
                    }
                };
            });
            
            localStorage.setItem('furniturePositions', JSON.stringify(furniturePositions));
            console.log('Posiciones de muebles guardadas en localStorage');
            
            // Si hay un mueble seleccionado, deseleccionarlo
            if (selectedFurniture) {
                deselectFurniture();
                
                // Mostrar la ventana de la habitación después de guardar
                const roomNavigationPanel = document.getElementById('room-navigation-panel');
                if (roomNavigationPanel && roomNavigationPanelOpen) {
                    roomNavigationPanel.style.display = 'flex';
                }
            }
        }
        
        function saveFurniturePositionsSilently() {
            // Guardar todas las posiciones de muebles en localStorage sin deseleccionar
            const furniturePositions = {};
            furnitureObjects.forEach(furniture => {
                furniturePositions[furniture.id] = {
                    position: {
                        x: furniture.mesh.position.x,
                        y: furniture.mesh.position.y,
                        z: furniture.mesh.position.z
                    },
                    rotation: {
                        y: furniture.mesh.rotation.y
                    }
                };
            });
            
            localStorage.setItem('furniturePositions', JSON.stringify(furniturePositions));
        }

        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            // Control de FPS
            const frameDeltaTime = currentTime - animationState.lastTime;
            if (frameDeltaTime < animationState.frameInterval) {
                return;
            }
            
            animationState.lastTime = currentTime - (frameDeltaTime % animationState.frameInterval);
            animationState.frameCount++;
            
            // Sistema de timing centralizado para actualizaciones periódicas
            updatePeriodicSystems(currentTime);
            
            // Solo actualizar y renderizar si estamos en la escena del mall
            if (gameState.currentScene === 'mall') {
            updateMovement();
            updateAvatarPositions(); // Actualizar posiciones de avatares
            
                // Actualizar animaciones de avatares con el delta time correcto
                updateAvatarAnimations(frameDeltaTime);
                
                renderer.render(scene, camera);
            }
        }
        
        // Función centralizada para manejar todas las actualizaciones periódicas
        function updatePeriodicSystems(currentTime) {
            // Actualizar el color del cielo
            if (timingSystem.shouldUpdate(timingState.lastSkyUpdate, timingState.intervals.SKY)) {
                scene.background = getSkyColor();
                timingSystem.updateLastTime('SKY');
            }
            
            // Enviar posición del usuario
            if (timingSystem.shouldUpdate(timingState.lastPositionUpdate, timingState.intervals.POSITION)) {
                sendUserPosition();
                timingSystem.updateLastTime('POSITION');
            }
            
            // Actualizar carteles rotativos
            if (timingSystem.shouldUpdate(timingState.lastRotatingSignUpdate, timingState.intervals.ROTATING_SIGN)) {
                updateRotatingSigns();
                timingSystem.updateLastTime('ROTATING_SIGN');
            }
            
            // Actualizar relojes digitales
            if (timingSystem.shouldUpdate(timingState.lastClockUpdate, timingState.intervals.CLOCK)) {
                updateDigitalClocks();
                timingSystem.updateLastTime('CLOCK');
            }
        }
        
        // Variables globales para carteles rotativos y relojes
        let rotatingSigns = [];
        let digitalClocks = [];
        let rotatingSignTextIndexes = {};
        
        // Función para actualizar carteles rotativos
        function updateRotatingSigns() {
            rotatingSigns.forEach((sign, index) => {
                if (sign.texts && sign.texts.length > 0) {
                    const textIndex = rotatingSignTextIndexes[index] || 0;
                    const nextIndex = (textIndex + 1) % sign.texts.length;
                    rotatingSignTextIndexes[index] = nextIndex;
                    updateRotatingSign(sign.material, sign.texts[nextIndex]);
                }
            });
        }
        
        // Función para actualizar relojes digitales
        function updateDigitalClocks() {
            digitalClocks.forEach(clock => {
                updateClockPlane(clock.material);
            });
        }
        
        // Función para limpiar recursos
        function cleanup() {
            // Limpiar cache de texturas
            logoTextureCache.forEach(texture => {
                if (texture && texture.dispose) {
                    texture.dispose();
                }
            });
            logoTextureCache.clear();
            
            // Limpiar cache de materiales
            materialCache.forEach(material => {
                if (material && material.dispose) {
                    material.dispose();
                }
            });
            materialCache.clear();
            
            // Limpiar cache de texturas generadas
            textureCache.forEach(texture => {
                if (texture && texture.dispose) {
                    texture.dispose();
                }
            });
            textureCache.clear();
            
            // Limpiar mixers de animación
            gameCollections.userAvatars.forEach((avatar, alias) => {
                if (avatar.mixer) {
                    avatar.mixer.stopAllAction();
                    avatar.mixer.uncacheRoot(avatar.group);
                }
            });
            
            // Limpiar arrays del sistema centralizado
            rotatingSigns = [];
            digitalClocks = [];
            rotatingSignTextIndexes = {};
        }
        
        // Limpiar al cerrar la página
        window.addEventListener('beforeunload', cleanup);

        function lerpAngle(a, b, t) {
            let diff = b - a;
            while (diff < -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;
            return a + diff * t;
        }

        // --- Chat UI Logic ---
        const chatToggleBtn = document.getElementById('chat-toggle-btn');
        const chatPanel = document.getElementById('chat-panel');
        const chatCloseBtn = document.getElementById('chat-close-btn');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');
        const emojiToggle = document.getElementById('emoji-toggle');
        const emojiPanel = document.getElementById('emoji-panel');
        const usersList = document.getElementById('users-list');
        const changeAliasBtn = document.getElementById('change-alias-btn');
        let userAlias = localStorage.getItem('userAlias') || '';
        let chatOpen = false;
        let connectedUsers = [];
        
        chatToggleBtn.onclick = () => {
            const simplePanel = document.getElementById('simple-panel');
            if (simplePanel && simplePanel.style.display === 'block') {
                closeSimplePanel();
            }
            chatPanel.style.display = 'flex';
            chatOpen = true;
            chatInput.focus();
            // Forzar scroll abajo al abrir
            setTimeout(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }, 50);
            // El overlay NO debe mostrarse al abrir el chat
        };
        chatCloseBtn.onclick = () => {
            chatPanel.style.display = 'none';
            chatOpen = false;
            // El overlay NO debe ocultarse al cerrar el chat
        };

        // --- Emojis ---
        const emojis = ['😊', '😂', '❤️', '👍', '🎉', '🔥', '😎', '🤔', '😢', '😡', '👋', '💪', '🎯', '⭐', '💯', '🚀', '💎', '🎮', '🍕', '☕', '🌮', '🍺', '🎵', '🎬', '⚽', '🏀', '🎾', '🏈', '⚡', '🌈', '🌙', '☀️'];
        function createEmojiPanel() {
            emojiPanel.innerHTML = '';
            emojis.forEach(emoji => {
                const btn = document.createElement('button');
                btn.className = 'emoji-btn';
                btn.textContent = emoji;
                btn.onclick = () => {
                    chatInput.value += emoji;
                    chatInput.focus();
                    emojiPanel.style.display = 'none';
                };
                emojiPanel.appendChild(btn);
            });
        }
        emojiToggle.onclick = () => {
            if (emojiPanel.style.display === 'none' || !emojiPanel.style.display) {
                emojiPanel.style.display = 'flex';
                createEmojiPanel();
            } else {
                emojiPanel.style.display = 'none';
            }
        };

        // El manejo de emoji panel ahora está integrado en handleGlobalClick

        // --- Firebase Chat Logic ---
        function handleSendMessage() {
            const message = chatInput.value.trim();
            if (message.length > 0 && userAlias) {
                    sendMessage(message);
                chatInput.value = '';
            }
        }
        if (chatSendBtn && chatInput) {
            chatSendBtn.onclick = handleSendMessage;
            chatInput.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    handleSendMessage();
                }
            });
        } else {
            console.warn('chatSendBtn o chatInput no existen en el DOM al inicializar.');
        }

        // Alias setup and connect to chat
        if (!userAlias) {
            userAlias = 'Usuario_' + Math.floor(Math.random() * 10000);
            localStorage.setItem('userAlias', userAlias);
        }
        if (userAlias) {
            changeAliasBtn.style.display = 'flex';
        }
        connectToChat(userAlias); // Provided by firebase-config.js

        // --- Funciones de personalización de avatar ---
        const saveCustomizationBtn = document.getElementById('save-customization-btn');
        const resetCustomizationBtn = document.getElementById('reset-customization-btn');
        const shirtColorsGrid = document.getElementById('shirt-colors');
        const pantsColorsGrid = document.getElementById('pants-colors');
        const shoesColorsGrid = document.getElementById('shoes-colors');
        


        function openCustomizationPanel() {
            console.log('Abriendo panel simple de personalización');
            
            // Cerrar chat si está abierto
            if (chatOpen) {
                chatPanel.style.display = 'none';
                chatOpen = false;
            }
            
            const simplePanel = document.getElementById('simple-panel');
            if (simplePanel) {
                // Actualizar el alias actual
                const currentAliasElement = document.getElementById('current-alias');
                if (currentAliasElement) {
                    currentAliasElement.textContent = userAlias || 'Sin alias';
                }
                
                // Poblar el input con el alias actual
                const aliasInput = document.getElementById('simple-alias-input');
                if (aliasInput) {
                    aliasInput.value = userAlias || '';
                    // Agregar event listener para actualizar vista previa en tiempo real
                    aliasInput.addEventListener('input', function() {
                        updateAvatarPreview();
                    });
                }
                
                // Mostrar el panel primero
                simplePanel.style.display = 'block';
                simplePanel.style.zIndex = '31000';
                simplePanel.style.pointerEvents = 'auto';
                customizationPanelOpen = true;
                
                // Inicializar vista previa del avatar
                updateAvatarPreview();
                
                console.log('✅ Panel simple mostrado');
                
                // Mostrar overlay después del panel, pero con pointer-events: none para el panel
            const overlay = document.getElementById('ui-overlay');
            if (overlay) {
                overlay.style.display = 'block';
                    overlay.style.pointerEvents = 'none'; // Cambiar a none para que no interfiera
                overlay.style.zIndex = '20000';
            }
            } else {
                console.log('❌ Panel simple no encontrado');
            }
        }
        

        
        function changeShirtColor(color) {
            console.log('Cambiando color de camisa a:', color);
            avatarState.currentCustomization.shirtColor = color;
            updateAvatarPreview();
            updateColorButtonSelection('shirt', color);
        }
        
        function changePantsColor(color) {
            console.log('Cambiando color de pantalón a:', color);
            avatarState.currentCustomization.pantsColor = color;
            
            // Actualizar el avatar en tiempo real usando el sistema correcto
            const avatar = gameCollections.userAvatars.get(userAlias);
            if (avatar && avatar.pantsMaterial) {
                avatar.pantsMaterial.color.setHex(color);
                avatar.pantsMaterial.needsUpdate = true;
            }
            
            // Actualizar vista previa
            updateAvatarPreview();
            
            // Feedback visual en los botones
            updateColorButtonSelection('pants', color);
        }
        
        function changeShoesColor(color) {
            console.log('Cambiando color de zapatos a:', color);
            avatarState.currentCustomization.shoesColor = color;
            
            // Actualizar el avatar en tiempo real usando el sistema correcto
            const avatar = gameCollections.userAvatars.get(userAlias);
            if (avatar && avatar.shoeMaterial) {
                avatar.shoeMaterial.color.setHex(color);
                avatar.shoeMaterial.needsUpdate = true;
            }
            
            // Actualizar vista previa
            updateAvatarPreview();
            
            // Feedback visual en los botones
            updateColorButtonSelection('shoes', color);
        }
        
        function updateColorButtonSelection(type, selectedColor) {
            // Remover selección anterior
            document.querySelectorAll('.color-option').forEach(btn => {
                btn.style.borderColor = 'transparent';
                btn.style.transform = 'scale(1)';
            });
            
            // Marcar el botón seleccionado
            const selectedBtn = document.querySelector(`[data-color="${selectedColor}"]`);
            if (selectedBtn) {
                selectedBtn.style.borderColor = '#FFD700';
                selectedBtn.style.transform = 'scale(1.1)';
                selectedBtn.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.5)';
            }
        }
        
        function updateAvatarPreview() {
            const previewDiv = document.getElementById('avatar-preview');
            const aliasInput = document.getElementById('simple-alias-input');
            if (previewDiv) {
                // Obtener el skin seleccionado
                let skinName = avatarState.currentCustomization && avatarState.currentCustomization.skin ? avatarState.currentCustomization.skin : 'humanMaleA';
                // Mapear nombre a archivo
                const skinFileMap = {
                    'humanMaleA': 'humanMaleA.png',
                    'humanFemaleA': 'humanFemaleA.png',
                    'zombieMaleA': 'zombieMaleA.png',
                    'zombieFemaleA': 'zombieFemaleA.png'
                };
                const skinFile = skinFileMap[skinName] || 'humanMaleA.png';
                const skinImgSrc = `assets/kenney 3d characters/Skins/${skinFile}`;

                // Actualizar el alias en la vista previa
                const currentAlias = aliasInput ? aliasInput.value.trim() : userAlias;
                // Crear una vista previa visual del avatar más detallada
                const shirtColorHex = avatarState.currentCustomization.shirtColor.toString(16).padStart(6, '0');
                const pantsColorHex = avatarState.currentCustomization.pantsColor.toString(16).padStart(6, '0');
                const shoesColorHex = avatarState.currentCustomization.shoesColor.toString(16).padStart(6, '0');
                previewDiv.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 0; position: relative; width: 90px; height: 200px;">
                        <!-- Skin thumbnail -->
                        <img src="${skinImgSrc}" alt="skin" style="width: 48px; height: 48px; object-fit: contain; margin-bottom: 2px; border-radius: 8px; border: 2px solid #FFD700; background: #222; box-shadow: 0 2px 8px rgba(0,0,0,0.2);" />
                        <!-- Cabeza cuadrada -->
                        <div style="width: 40px; height: 40px; background: #FFE4C4; border: 2px solid #333; position: relative; margin-bottom: 0;">
                            <!-- Ojos -->
                            <div style="position: absolute; top: 12px; left: 10px; width: 6px; height: 6px; background: #222; border-radius: 1px;"></div>
                            <div style="position: absolute; top: 12px; right: 10px; width: 6px; height: 6px; background: #222; border-radius: 1px;"></div>
                            <!-- Boca -->
                            <div style="position: absolute; bottom: 10px; left: 12px; width: 16px; height: 4px; background: #222; border-radius: 1px;"></div>
                        </div>
                        <!-- Torso y brazos -->
                        <div style="display: flex; flex-direction: row; align-items: flex-start; height: 50px;">
                            <!-- Brazo izquierdo -->
                            <div style="width: 16px; height: 50px; background: #${shirtColorHex}; border: 2px solid #333; margin-right: 0;"></div>
                            <!-- Torso -->
                            <div style="width: 28px; height: 50px; background: #${shirtColorHex}; border: 2px solid #333; margin: 0 0;"></div>
                            <!-- Brazo derecho -->
                            <div style="width: 16px; height: 50px; background: #${shirtColorHex}; border: 2px solid #333; margin-left: 0;"></div>
                        </div>
                        <!-- Piernas -->
                        <div style="display: flex; flex-direction: row; align-items: flex-start; height: 50px; margin-top: 0;">
                            <!-- Pierna izquierda -->
                            <div style="width: 16px; height: 50px; background: #${pantsColorHex}; border: 2px solid #333; margin-right: 4px;"></div>
                            <!-- Pierna derecha -->
                            <div style="width: 16px; height: 50px; background: #${pantsColorHex}; border: 2px solid #333; margin-left: 4px;"></div>
                        </div>
                        <!-- Zapatos -->
                        <div style="display: flex; flex-direction: row; align-items: flex-start; height: 12px; margin-top: -2px;">
                            <!-- Pie izquierdo -->
                            <div style="width: 16px; height: 12px; background: #${shoesColorHex}; border: 2px solid #333; margin-right: 4px;"></div>
                            <!-- Pie derecho -->
                            <div style="width: 16px; height: 12px; background: #${shoesColorHex}; border: 2px solid #333; margin-left: 4px;"></div>
                        </div>
                        <!-- Nombre del avatar -->
                        <div style="color: #FFD700; font-size: 12px; font-weight: bold; text-align: center; margin-top: 8px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); width: 100%;">${currentAlias || 'Sin nombre'}</div>
                    </div>
                `;
            }
        }
        
        function resetSimpleCustomization() {
            console.log('Restableciendo personalización');
            
            // Restablecer colores por defecto usando el sistema unificado
            avatarState.currentCustomization = {
                shirtColor: 0x4ECDC4,
                pantsColor: 0x2C3E50,
                shoesColor: 0x8B4513,
                skin: 'humanMaleA'
            };
            
            // Restablecer alias
            userAlias = '';
            const aliasInput = document.getElementById('simple-alias-input');
            if (aliasInput) {
                aliasInput.value = '';
            }
            
            // Actualizar avatar en tiempo real usando el sistema correcto
            const avatar = gameCollections.userAvatars.get(userAlias);
            if (avatar) {
                if (avatar.bodyMaterial) avatar.bodyMaterial.color.setHex(avatarState.currentCustomization.shirtColor);
                if (avatar.pantsMaterial) avatar.pantsMaterial.color.setHex(avatarState.currentCustomization.pantsColor);
                if (avatar.shoeMaterial) avatar.shoeMaterial.color.setHex(avatarState.currentCustomization.shoesColor);
                
                // Forzar actualización de materiales
                if (avatar.bodyMaterial) avatar.bodyMaterial.needsUpdate = true;
                if (avatar.pantsMaterial) avatar.pantsMaterial.needsUpdate = true;
                if (avatar.shoeMaterial) avatar.shoeMaterial.needsUpdate = true;
            }
            
            // Actualizar vista previa
            updateAvatarPreview();
            
            // Limpiar selección de botones
            document.querySelectorAll('.color-option').forEach(btn => {
                btn.style.borderColor = 'transparent';
                btn.style.transform = 'scale(1)';
                btn.style.boxShadow = 'none';
            });
            
            console.log('✅ Personalización restablecida');
        }
        
        function saveSimpleCustomization() {
            console.log('Guardando personalización');
            const aliasInput = document.getElementById('simple-alias-input');
            const newAlias = aliasInput ? aliasInput.value.trim() : '';
            // Validar alias
            if (newAlias.length > 20) {
                alert('El nombre no puede tener más de 20 caracteres');
                return;
            }
            // Guardar alias
            userAlias = newAlias;
            // Guardar en localStorage usando el sistema unificado
            localStorage.setItem('avatarCustomization', JSON.stringify(avatarState.currentCustomization));
            // Actualizar nombre en el avatar
            updateAvatarName && updateAvatarName();
            // Aplicar colores al avatar propio si existe
            const myAvatar = gameCollections.userAvatars.get(userAlias);
            if (myAvatar) {
                if (myAvatar.bodyMaterial) myAvatar.bodyMaterial.color.setHex(avatarState.currentCustomization.shirtColor);
                if (myAvatar.pantsMaterial) myAvatar.pantsMaterial.color.setHex(avatarState.currentCustomization.pantsColor);
                if (myAvatar.shoeMaterial) myAvatar.shoeMaterial.color.setHex(avatarState.currentCustomization.shoesColor);
                if (myAvatar.bodyMaterial) myAvatar.bodyMaterial.needsUpdate = true;
                if (myAvatar.pantsMaterial) myAvatar.pantsMaterial.needsUpdate = true;
                if (myAvatar.shoeMaterial) myAvatar.shoeMaterial.needsUpdate = true;
            }
            // Enviar alias al servidor si está conectado
            if (typeof isConnected !== 'undefined' && isConnected) {
                sendAlias && sendAlias();
            }
            // Cerrar panel
            closeSimplePanel && closeSimplePanel();
            console.log('✅ Personalización guardada:', avatarState.currentCustomization);
        }
        
        function closeSimplePanel() {
            const panel = document.getElementById('simple-panel');
            if (panel) {
                panel.style.display = 'none';
                customizationPanelOpen = false;
                // Ocultar overlay y permitir clics
                const overlay = document.getElementById('ui-overlay');
                if (overlay) {
                    overlay.style.display = 'none';
                    overlay.style.pointerEvents = 'none';
                }
                panel.style.zIndex = '21000';
                panel.style.pointerEvents = 'auto';
                console.log('Panel simple cerrado');
            }
        }
        
        // --- SKIN SELECTION ARROWS LOGIC ---
        document.addEventListener('DOMContentLoaded', function() {
    // Skins disponibles
    const skinList = [
        { key: 'humanMaleA', label: 'Humano Masculino', img: 'assets/kenney 3d characters/Skins/humanMaleA.png' },
        { key: 'humanFemaleA', label: 'Humano Femenino', img: 'assets/kenney 3d characters/Skins/humanFemaleA.png' },
        { key: 'zombieMaleA', label: 'Zombie Masculino', img: 'assets/kenney 3d characters/Skins/zombieMaleA.png' },
        { key: 'zombieFemaleA', label: 'Zombie Femenino', img: 'assets/kenney 3d characters/Skins/zombieFemaleA.png' }
    ];
    // Obtener elementos
    const prevBtn = document.getElementById('skin-prev-btn');
    const nextBtn = document.getElementById('skin-next-btn');
    const img = document.getElementById('skin-preview-img');
    const label = document.getElementById('skin-preview-label');
    // Inicializar índice
    let currentIdx = skinList.findIndex(s => s.key === (avatarState.currentCustomization && avatarState.currentCustomization.skin ? avatarState.currentCustomization.skin : 'humanMaleA'));
    if (currentIdx === -1) currentIdx = 0;
    // Función para actualizar preview
    function updateSkinPreview(idx) {
        img.src = skinList[idx].img;
        label.textContent = skinList[idx].label;
        avatarState.currentCustomization.skin = skinList[idx].key;
        updateAvatarPreview && updateAvatarPreview();
    }
    // Asignar eventos
    prevBtn && prevBtn.addEventListener('click', function() {
        currentIdx = (currentIdx - 1 + skinList.length) % skinList.length;
        updateSkinPreview(currentIdx);
    });
    nextBtn && nextBtn.addEventListener('click', function() {
        currentIdx = (currentIdx + 1) % skinList.length;
        updateSkinPreview(currentIdx);
    });
    // Inicializar preview
    updateSkinPreview(currentIdx);

    // Alias input para preview
            const aliasInput = document.getElementById('simple-alias-input');
            if (aliasInput) {
                aliasInput.addEventListener('input', function() {
                    updateAvatarPreview();
                });
            }
        });

        function closeWorkingPanel() {
            const panel = document.getElementById('working-customization-panel');
            if (panel) {
                panel.remove();
            }
            customizationPanelOpen = false;
        }
        
        function changeShirtColor(color) {
            avatarState.currentCustomization.shirtColor = color;
            applyCustomizationToAvatar();
            console.log('Color de camisa cambiado a:', color);
        }
        
        function saveSimpleCustomization() {
            const aliasInput = document.getElementById('simple-alias-input');
            const newAlias = aliasInput.value.trim();
            
            if (newAlias.length > 0) {
                userAlias = newAlias;
                localStorage.setItem('userAlias', userAlias);
                
                if (isConnected) {
                    sendAlias();
                }
                
                console.log('Alias guardado:', newAlias);
            }
            
            localStorage.setItem('avatarCustomization', JSON.stringify(avatarState.currentCustomization));
            closeSimplePanel();
            alert('¡Personalización guardada!');
        }
        
        function createWorkingColorGrids() {
            // Crear opciones de color para camisas (primeros 18 colores)
            const shirtGrid = document.getElementById('working-shirt-colors');
            for (let i = 0; i < 18; i++) {
                const colorOption = document.createElement('div');
                colorOption.style.cssText = `
                    width: 40px;
                    height: 40px;
                    border: 3px solid transparent;
                    border-radius: 8px;
                    cursor: pointer;
                    background-color: #${avatarState.customizationColors[i].toString(16).padStart(6, '0')};
                `;
                colorOption.onclick = () => selectWorkingColor(avatarState.customizationColors[i], 'shirt');
                if (avatarState.customizationColors[i] === avatarState.currentCustomization.shirtColor) {
                    colorOption.style.borderColor = '#FFD700';
                }
                shirtGrid.appendChild(colorOption);
            }
            

        }
        

        

        

        


        function closeCustomizationPanel() {
            customizationPanel.style.display = 'none';
            customizationPanelOpen = false;
        }

        function createSkinSelection() {
    const skinOptions = document.querySelectorAll('.skin-option');
    skinOptions.forEach(btn => {
        btn.onclick = () => {
            const selectedSkin = btn.getAttribute('data-skin');
            avatarState.currentCustomization.skin = selectedSkin;
            updateSelectedSkin();
            updateAvatarPreview();
        };
    });
}

function updateSelectedSkin() {
    const skinOptions = document.querySelectorAll('.skin-option');
    skinOptions.forEach(btn => {
        if (btn.getAttribute('data-skin') === avatarState.currentCustomization.skin) {
            btn.classList.add('selected');
        } else {
            btn.classList.remove('selected');
        }
    });
}

        function selectColor(color, type) {
            // Remover selección previa del mismo tipo
            const allSelected = document.querySelectorAll(`.color-option.selected[data-type="${type}"]`);
            allSelected.forEach(btn => btn.classList.remove('selected'));
            
            // Seleccionar nueva opción
            const selectedOption = document.querySelector(`[data-color="${color}"][data-type="${type}"]`);
            if (selectedOption) {
                selectedOption.classList.add('selected');
            }
            
            // Actualizar color actual
            switch (type) {
                case 'shirt':
                    avatarState.currentCustomization.shirtColor = color;
                    break;
                case 'pants':
                    avatarState.currentCustomization.pantsColor = color;
                    break;
                case 'shoes':
                    avatarState.currentCustomization.shoesColor = color;
                    break;
            }
            
            // Actualizar selecciones visuales
            updateSelectedColors();
            
            // Aplicar cambios inmediatamente al avatar
            applyCustomizationToAvatar();
        }

        function updateSelectedColors() {
            // Actualizar selecciones visuales
            const shirtOption = document.querySelector(`[data-color="${avatarState.currentCustomization.shirtColor}"][data-type="shirt"]`);
            const pantsOption = document.querySelector(`[data-color="${avatarState.currentCustomization.pantsColor}"][data-type="pants"]`);
            const shoesOption = document.querySelector(`[data-color="${avatarState.currentCustomization.shoesColor}"][data-type="shoes"]`);
            
            if (shirtOption) shirtOption.classList.add('selected');

    // Seleccionar nueva opción
    const selectedOption = document.querySelector(`[data-color="${color}"][data-type="${type}"]`);
    if (selectedOption) {
        selectedOption.classList.add('selected');
    }

    // Actualizar color actual
    switch (type) {
        case 'shirt':
                    avatarState.currentCustomization.shirtColor = color;
            break;
        case 'pants':
                    avatarState.currentCustomization.pantsColor = color;
            break;
        case 'shoes':
                    avatarState.currentCustomization.shoesColor = color;
            break;
    }
            
            // Validar el alias
            if (newAlias.length === 0) {
                addMessageToChat('Sistema', 'El alias no puede estar vacío', 'system');
                return;
            }
            
            if (newAlias.length > 18) {
                addMessageToChat('Sistema', 'El alias no puede tener más de 18 caracteres', 'system');
                return;
            }
            
            // Actualizar el alias si ha cambiado
            if (newAlias !== userAlias) {
                userAlias = newAlias;
                localStorage.setItem('userAlias', userAlias);
                
                // Enviar nuevo alias al servidor
                if (isConnected) {
                    sendAlias();
                }
            }
            
            // Guardar personalización en localStorage
            localStorage.setItem('avatarCustomization', JSON.stringify(currentCustomization));
            closeCustomizationPanel();
            
            // Mostrar mensaje de confirmación
            addMessageToChat('Sistema', 'Personalización guardada exitosamente', 'system');
        }

        // --- FUNCIONES UNIFICADAS DE PERSONALIZACIÓN ---

        function loadCustomization() {
            const saved = localStorage.getItem('avatarCustomization');
            if (saved) {
                try {
                    avatarState.currentCustomization = JSON.parse(saved);
                    // Si falta la propiedad skin, asignar valor por defecto
                    if (!avatarState.currentCustomization.skin) avatarState.currentCustomization.skin = 'humanMaleA';
                    applyCustomizationToAvatar();
                } catch (error) {
                    console.error('Error cargando personalización:', error);
                }
            }
        }

        function applyCustomizationToAvatar() {
            if (!avatarState.currentCustomization) return;
            
            // Actualizar colores del avatar
            const shirtColor = avatarState.currentCustomization.shirtColor || 0x4ECDC4;
            const pantsColor = avatarState.currentCustomization.pantsColor || 0x2C3E50;
            const shoesColor = avatarState.currentCustomization.shoesColor || 0x8B4513;
            
            // Buscar y actualizar materiales del avatar
            if (gameCollections.userAvatars.has(userAlias)) {
                const avatarData = gameCollections.userAvatars.get(userAlias);
                if (avatarData && avatarData.group) {
                    const group = avatarData.group;
                    
                    // Actualizar colores de materiales
                    if (group.bodyMaterial) group.bodyMaterial.color.setHex(shirtColor);
                    if (group.armMaterial) group.armMaterial.color.setHex(shirtColor);
                    if (group.pantsMaterial) group.pantsMaterial.color.setHex(pantsColor);
                    
                    // Actualizar UI de selección de colores
                    updateColorButtonSelection('shirt', shirtColor);
                    updateColorButtonSelection('pants', pantsColor);
                    updateColorButtonSelection('shoes', shoesColor);
                }
            }
        }

        // El manejo de cierre de paneles ahora está integrado en handleGlobalClick

        // El manejo del overlay ahora está integrado en handleGlobalClick

        // Cargar personalización al iniciar
        loadCustomization();

        function sendUserPosition() {
            if (userAlias) {
                // TODO: Enviar posición a Firebase
                // firebase.database().ref('positions').child(userAlias).set({ ... })
            }
        }

        function updateAvatarPosition(alias, position, floor, rotation = 0, shirtColor, pantsColor, shoesColor) {
            if (!position || typeof position.x !== 'number' || typeof position.y !== 'number' || typeof position.z !== 'number') {
                console.warn('Posición inválida para alias:', alias, position);
                return;
            }
            if (typeof floor !== 'number') {
                console.warn('Floor inválido para alias:', alias, floor);
                return;
            }
            if (typeof rotation !== 'number') {
                console.warn('Rotación inválida para alias:', alias, rotation);
                return;
            }
            // No crear avatar para el usuario propio
            if (alias === userAlias) {
                return;
            }
            let avatar = gameCollections.userAvatars.get(alias);
            if (!avatar) {
                // Solo pasar skin si existe
                let custom = {};
                if (typeof skin !== 'undefined') custom.skin = skin;
                createUserAvatar(alias, position, floor, custom);
                avatar = gameCollections.userAvatars.get(alias);
            }
            if (avatar) {
                // Actualización de posición y rotación en tiempo real
                const floorStep = HALL_HEIGHT + 1;
                const targetY = floor * floorStep;
                avatar.targetPosition.set(position.x, targetY, position.z);
                avatar.currentFloor = floor;
                let normalizedRotation = rotation;
                while (normalizedRotation > Math.PI) normalizedRotation -= 2 * Math.PI;
                while (normalizedRotation < -Math.PI) normalizedRotation += 2 * Math.PI;
                avatar.targetRotation = normalizedRotation;
            }
        }

        // Asegurar que el DOM esté completamente cargado antes de inicializar
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
        
        // Función para detectar dispositivo móvil
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   window.innerWidth <= 768;
        }
        
        // Función para mostrar/ocultar controles móviles
        function toggleMobileControls() {
            const mobileControls = document.getElementById('mobile-controls');
            const mobileRotationControls = document.getElementById('mobile-rotation-controls');
            
            if (mobileControls) {
                if (isMobileDevice()) {
                    mobileControls.style.display = 'block';
                } else {
                    mobileControls.style.display = 'none';
                }
            }
            
            if (mobileRotationControls) {
                if (isMobileDevice()) {
                    mobileRotationControls.style.display = 'block';
                } else {
                    mobileRotationControls.style.display = 'none';
                }
            }
        }
        
        // Detectar cambios de tamaño de ventana
        window.addEventListener('resize', toggleMobileControls);
        
        // Inicializar controles móviles al cargar
        document.addEventListener('DOMContentLoaded', toggleMobileControls);

        // Configurar overlay al cargar la página
        document.addEventListener('DOMContentLoaded', () => {
            const overlay = document.getElementById('ui-overlay');
            if (overlay) {
                overlay.style.pointerEvents = 'auto';
            }
        });

        
       

        // Mostrar prompt de alias si no existe
        if (!userAlias) {
            userAlias = prompt('Ingresa tu alias:');
            if (userAlias) {
                localStorage.setItem('userAlias', userAlias);
            } else {
                userAlias = 'Usuario_' + Math.floor(Math.random() * 10000);
                localStorage.setItem('userAlias', userAlias);
            }
        }

        // Conectar al chat de Firebase
        connectToChat(userAlias);

        

        // Sistema de posición centralizado - manejado por updatePeriodicSystems()

        // Función mejorada para mostrar mensajes en el chat
        function addMessageToChat(alias, message, type = 'user', timestamp = null, isPrivate = false, recipient = null) {
            const chatMessages = document.getElementById('chat-messages');
            if (!chatMessages) return;
            let timeStr = '';
            if (timestamp) {
                const date = new Date(timestamp);
                timeStr = `<span style="color:#aaa; font-size:11px; margin-left:8px;">${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>`;
            }
            const isOwn = (alias === userAlias || type === 'own');
            const msgDiv = document.createElement('div');
            msgDiv.className = isOwn ? 'chat-message own' : 'chat-message';
            msgDiv.style.margin = '6px 0';
            msgDiv.style.textAlign = isOwn ? 'right' : 'left';
            if (isPrivate) {
                msgDiv.style.background = 'rgba(255,215,0,0.12)';
                msgDiv.style.border = '1px solid #FFD700';
                msgDiv.innerHTML = `<span style="color:${isOwn ? '#FFD700' : '#4ECDC4'}; font-weight:bold;">${alias} (privado):</span> <span style="color:#fff;">${message}</span> ${timeStr}`;
            } else {
                msgDiv.innerHTML = `<span style="color:${isOwn ? '#FFD700' : '#4ECDC4'}; font-weight:bold;">${alias}:</span> <span style="color:#fff;">${message}</span> ${timeStr}`;
            }
            chatMessages.appendChild(msgDiv);
            // Limitar a los últimos 10 mensajes
            while (chatMessages.children.length > 10) {
                chatMessages.removeChild(chatMessages.firstChild);
            }
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        window.addMessageToChat = addMessageToChat;

        // Listener de mensajes de Firebase - ELIMINADO para evitar duplicados
        // El listener principal está en firebase-config.js

        // Sistema de Firebase listeners optimizado - manejado en firebase-config.js
        // Los listeners específicos (child_added, child_changed, child_removed) están configurados allí

        // --- Eliminar avatar de usuario de la escena y del mapa ---
function removeUserAvatar(alias) {
    const avatar = gameCollections.userAvatars.get(alias);
            if (avatar) {
                if (avatar.group) {
        scene.remove(avatar.group);
                }
                // Limpiar mixer de animación
                if (avatar.mixer) {
                    avatar.mixer.stopAllAction();
                    avatar.mixer.uncacheRoot(avatar.group);
                }
    }
    gameCollections.userAvatars.delete(alias);
    pendingAvatarLoads.delete(alias);
}
        
        // Exponer función para uso en firebase-config.js
        window.removeUserAvatar = removeUserAvatar;

// --- Control de cargas pendientes para evitar duplicados por race conditions ---
const pendingAvatarLoads = new Set();

// --- Función para crear un avatar de usuario con animaciones correctamente cargadas ---
function createUserAvatar(alias, position = {x:0, y:0, z:0}, floor = 0, custom = {}) {
    console.log('[createUserAvatar] llamado para alias:', alias, position, floor, custom);
    
    // Si ya hay una carga pendiente para este alias, no la repitas
    if (pendingAvatarLoads.has(alias)) return;
    
    // Elimina cualquier avatar anterior con el mismo alias para evitar duplicados
    removeUserAvatar(alias);
    
    // Si por alguna razón sigue existiendo, no continuar
    if (gameCollections.userAvatars.has(alias)) return;
    
    pendingAvatarLoads.add(alias);
    
    const modelPath = 'assets/kenney 3d characters/Model/characterMedium.fbx';
    
    // Elegir el skin correcto
    let skinName = (custom && custom.skin) ? custom.skin : (currentCustomization && currentCustomization.skin ? currentCustomization.skin : 'humanMaleA');
    const skinFileMap = {
        'humanMaleA': 'humanMaleA.png',
        'humanFemaleA': 'humanFemaleA.png',
        'zombieMaleA': 'zombieMaleA.png',
        'zombieFemaleA': 'zombieFemaleA.png'
    };
    const texturePath = `assets/kenney 3d characters/Skins/${skinFileMap[skinName] || 'humanMaleA.png'}`;
    
    const fbxLoader = new THREE.FBXLoader();
    const textureLoader = new THREE.TextureLoader();
    
    // Calcular la posición Y correcta para el piso
    const floorStep = HALL_HEIGHT + 1;
    const correctY = floor * floorStep;
    
    // Usaremos Promises para manejar las cargas asíncronas de forma limpia
    const modelPromise = new Promise(resolve => fbxLoader.load(modelPath, resolve));
    const texturePromise = new Promise(resolve => textureLoader.load(texturePath, resolve));
    const idleAnimPromise = new Promise(resolve => fbxLoader.load('assets/kenney 3d characters/Animations/idle.fbx', resolve));
    const runAnimPromise = new Promise(resolve => fbxLoader.load('assets/kenney 3d characters/Animations/run.fbx', resolve));
    
    Promise.all([modelPromise, texturePromise, idleAnimPromise, runAnimPromise])
        .then(([avatar, texture, idleAnimation, runAnimation]) => {
            
            pendingAvatarLoads.delete(alias);
            
            // Si el alias ya no es válido (fue eliminado durante la carga), no agregues el avatar
            if (gameCollections.userAvatars.has(alias)) return;
            
            // Aplicar la textura al modelo
            avatar.traverse(child => {
                if (child.isMesh) {
                    child.material.map = texture;
                    child.material.needsUpdate = true;
                }
            });
            
            // Configurar posición y escala
            avatar.position.set(position.x, correctY, position.z);
            avatar.scale.set(0.009, 0.009, 0.009);
            scene.add(avatar);
            
            // --- LÓGICA DE ANIMACIÓN CORRECTA ---
            const mixer = new THREE.AnimationMixer(avatar);
            const actions = {};
            
            // Los clips de animación vienen en el array `animations` de los archivos cargados
            const idleClip = idleAnimation.animations[0];
            const runClip = runAnimation.animations[0];
            
            console.log(`[${alias}] Animaciones cargadas:`, {
                idleAnimation: idleAnimation.animations.length,
                runAnimation: runAnimation.animations.length,
                idleClip: idleClip ? idleClip.name : 'null',
                runClip: runClip ? runClip.name : 'null'
            });
            
            if (idleClip) {
                actions.idle = mixer.clipAction(idleClip);
                actions.idle.setLoop(THREE.LoopRepeat);
                actions.idle.play(); // Iniciar en 'idle' por defecto
                console.log(`[${alias}] Animación Idle cargada y reproduciendo`);
            } else {
                console.warn(`[${alias}] No se encontró clip de animación idle`);
            }
            
            if (runClip) {
                // Renombramos el clip para que coincida con lo que buscamos ('walk')
                runClip.name = 'walk';
                actions.walk = mixer.clipAction(runClip);
                actions.walk.setLoop(THREE.LoopRepeat);
                console.log(`[${alias}] Animación Walk/Run cargada como 'walk'`);
            } else {
                console.warn(`[${alias}] No se encontró clip de animación run`);
            }
            
            // Si no se cargó ninguna animación, al menos el avatar aparecerá estático
            if (Object.keys(actions).length === 0) {
                console.warn(`No se cargaron clips de animación para el avatar ${alias}`);
            }
            
            // --- FIN DE LA LÓGICA DE ANIMACIÓN ---
            
            printAllBones({ group: avatar }); // Debug: mostrar huesos en consola
            console.log('Avatar añadido:', alias, avatar.position, avatar.scale);
            
            // Guardar el avatar y su mixer
            gameCollections.userAvatars.set(alias, {
                group: avatar,
                mixer: mixer,
                actions: actions,
                targetPosition: new THREE.Vector3(position.x, correctY, position.z),
                targetRotation: 0,
                currentFloor: floor,
                isMoving: false
            });
            
        }).catch(error => {
            console.error(`Error al cargar los recursos para el avatar ${alias}:`, error);
            pendingAvatarLoads.delete(alias);
        });
}

        // --- Utilidad para debug: imprimir huesos del modelo FBX ---
        function printAllBones(avatar) {
            if (!avatar || !avatar.group) return;
            console.log('--- Huesos del avatar:', avatar.group.name, '---');
            avatar.group.traverse(child => {
                if (child.isBone) {
                    console.log('Bone:', child.name);
                }
            });
        }
       
        // Utilidad opcional para hashCode de string (alias)
        if (!String.prototype.hashCode) {
    String.prototype.hashCode = function() {
        var hash = 0, i, chr;
        if (this.length === 0) return hash;
        for (i = 0; i < this.length; i++) {
            chr   = this.charCodeAt(i);
            hash  = ((hash << 5) - hash) + chr;
            hash |= 0; // Convert to 32bit integer
        }
        return hash;
    };
}
        // --- Función para actualizar todas las posiciones de avatares ---
        function updateAvatarPositions() {
            gameCollections.userAvatars.forEach((avatar, alias) => {
                // Interpolar posición y rotación
                avatar.group.position.lerp(avatar.targetPosition, 0.2);
                avatar.group.rotation.y = lerpAngle(avatar.group.rotation.y, avatar.targetRotation, 0.2);

                // --- LÓGICA DE CONTROL DE ANIMACIÓN ---
                const isNowMoving = avatar.group.position.distanceTo(avatar.targetPosition) > 0.1;

                if (isNowMoving && !avatar.isMoving) {
                    // Empezó a moverse: cambia de 'idle' a 'walk'
                    console.log(`[${alias}] Empezó a moverse - Cambiando a walk animation`);
                    if (avatar.actions && avatar.actions.walk && avatar.actions.idle) {
                        console.log(`[${alias}] Transición: idle -> walk`);
                        avatar.actions.idle.fadeOut(0.3);
                        avatar.actions.walk.reset().fadeIn(0.3).play();
                    } else if (avatar.actions && avatar.actions.walk && avatar.actions.default) {
                        // Si no hay idle, usar default
                        console.log(`[${alias}] Transición: default -> walk`);
                        avatar.actions.default.fadeOut(0.3);
                        avatar.actions.walk.reset().fadeIn(0.3).play();
                    } else {
                        console.warn(`[${alias}] No se pudo cambiar a walk animation. Actions disponibles:`, Object.keys(avatar.actions || {}));
                    }
                    avatar.isMoving = true;
                } else if (!isNowMoving && avatar.isMoving) {
                    // Dejó de moverse: cambia de 'walk' a 'idle'
                    console.log(`[${alias}] Dejó de moverse - Cambiando a idle animation`);
                    if (avatar.actions && avatar.actions.walk && avatar.actions.idle) {
                        console.log(`[${alias}] Transición: walk -> idle`);
                        avatar.actions.walk.fadeOut(0.3);
                        avatar.actions.idle.reset().fadeIn(0.3).play();
                    } else if (avatar.actions && avatar.actions.walk && avatar.actions.default) {
                        // Si no hay idle, usar default
                        console.log(`[${alias}] Transición: walk -> default`);
                        avatar.actions.walk.fadeOut(0.3);
                        avatar.actions.default.reset().fadeIn(0.3).play();
                    } else {
                        console.warn(`[${alias}] No se pudo cambiar a idle animation. Actions disponibles:`, Object.keys(avatar.actions || {}));
                    }
                    avatar.isMoving = false;
                }
            });
        }

        // --- Función para actualizar animaciones de avatares ---
        function updateAvatarAnimations(deltaTime) {
            gameCollections.userAvatars.forEach((avatar, alias) => {
                if (avatar.mixer) {
                    // deltaTime ya está en segundos desde THREE.Clock
                    avatar.mixer.update(deltaTime);
                    

                }
            });
        }

        

        function openSimplePanel() {
            const panel = document.getElementById('simple-panel');
            if (panel) {
                panel.style.display = 'block';
                customizationPanelOpen = true;
                // Inicializar vista previa del avatar
                updateAvatarPreview();
                // Inicializar los grids de colores
                createColorGrids();
                // Inicializar selección de skin
                createSkinSelection();
                // Actualizar selecciones de colores
                updateSelectedColors();
                // Actualizar selección de skin
                updateSelectedSkin();
            }
        }

        // Inicialización robusta de colores de avatar
        // Los colores ahora se manejan a través del sistema unificado avatarState.currentCustomization
        // No se necesitan verificaciones de variables globales
        
        // UI: Al hacer clic en un usuario, activar modo privado
        usersList.addEventListener('click', function(e) {
            const userItem = e.target.closest('.user-item');
            if (userItem && !userItem.classList.contains('own')) {
                const alias = userItem.textContent.replace(' (Tú)', '').trim();
                openPrivateChatWindow(alias);
            }
        });
        

        // Eliminar definición duplicada de addMessageToChat y el listener de mensajes públicos en index.html
        // Dejar solo la versión de addMessageToChat que soporta mensajes privados y exponerla en window
        window.addMessageToChat = addMessageToChat;

        // --- Sistema de posición centralizado ---
        function sendUserPosition() {
                if (
                    typeof camera !== 'undefined' &&
                    camera.position &&
                    typeof camera.position.x !== 'undefined' &&
                    typeof camera.position.y !== 'undefined' &&
                    typeof camera.position.z !== 'undefined'
                ) {
                    const position = {
                        x: camera.position.x,
                        y: camera.position.y,
                        z: camera.position.z
                    };
                    const floor = typeof currentFloor !== 'undefined' ? currentFloor : 0;
                    const rotation = typeof camera.rotation !== 'undefined' ? -camera.rotation.y : 0;
                    sendPosition(position, floor, rotation);
                }
        }
        
        // Iniciar al conectar
        document.addEventListener('DOMContentLoaded', () => {
            connectToChat(userAlias);
        });
        
        // Limpiar al cerrar la página
        window.addEventListener('beforeunload', () => {
            disconnectFromChat();
        });

        // Función para controlar los eventos del canvas según el estado de la UI
        function updateCanvasPointerEvents() {
            const canvas = renderer.domElement;
            const chatOpen = document.getElementById('chat-panel').style.display === 'flex';
            const panelOpen = document.getElementById('simple-panel').style.display === 'block';
            
            if (chatOpen || panelOpen) {
                canvas.style.pointerEvents = 'none';
            } else {
                canvas.style.pointerEvents = 'auto';
            }
        }

        // --- Ventanas independientes para chats privados ---
        const privateChatsContainer = document.getElementById('private-chats-container');
        const privateChatWindows = {};
        const privateChatListeners = {};

        function openPrivateChatWindow(alias) {
            if (!alias || alias === userAlias) return;
            if (privateChatWindows[alias]) {
                // Traer al frente
                privateChatWindows[alias].style.zIndex = Date.now();
                privateChatWindows[alias].style.display = 'block';
                privateChatsContainer.style.pointerEvents = 'auto';
                return;
            }
            // Crear ventana
            const win = document.createElement('div');
            win.className = 'private-chat-window';
            win.style.cssText = `width:320px; height:380px; background:rgba(30,30,30,0.97); border-radius:10px; box-shadow:0 4px 24px #000a; position:relative; margin-bottom:16px; margin-left:16px; display:block; pointer-events:auto; overflow:hidden; border:2px solid #FFD700;`;
            win.style.zIndex = Date.now();
            win.innerHTML = `
                <div style="background:#222; color:#FFD700; padding:10px 14px; font-weight:bold; display:flex; align-items:center; justify-content:space-between;">
                    <span>Chat privado con ${alias}</span>
                    <button style="background:none; border:none; color:#FFD700; font-size:18px; cursor:pointer;" title="Cerrar">✖</button>
                </div>
                <div class="private-chat-messages" style="flex:1; padding:10px; overflow-y:auto; height:260px; background:rgba(34,34,34,0.95);"></div>
                <div style="padding:10px; border-top:1px solid #333; background:rgba(34,34,34,0.95); display:flex;">
                    <input class="private-chat-input" type="text" placeholder="Escribe un mensaje privado..." style="flex:1; border:none; background:#333; color:#fff; border-radius:6px; padding:8px; font-size:15px;">
                    <button class="private-chat-send-btn" style="background:#FFD700; color:#222; border:none; border-radius:6px; margin-left:8px; padding:8px 14px; font-size:15px; cursor:pointer;">Enviar</button>
                </div>
            `;
            privateChatsContainer.appendChild(win);
            privateChatsContainer.style.pointerEvents = 'auto';
            privateChatWindows[alias] = win;
            // Cerrar ventana
            win.querySelector('button[title="Cerrar"]').onclick = () => closePrivateChatWindow(alias);
            // Enviar mensaje
            const input = win.querySelector('.private-chat-input');
            const sendBtn = win.querySelector('.private-chat-send-btn');
            sendBtn.onclick = () => {
                const msg = input.value.trim();
                if (msg) {
                    sendPrivateMessage(alias, msg);
                    input.value = '';
                }
            };
            input.addEventListener('keydown', e => {
                if (e.key === 'Enter') sendBtn.onclick();
            });
            // Cargar historial y escuchar nuevos mensajes
            loadPrivateChatHistory(alias, win.querySelector('.private-chat-messages'));
        }
        function closePrivateChatWindow(alias) {
            if (privateChatWindows[alias]) {
                privateChatsContainer.removeChild(privateChatWindows[alias]);
                delete privateChatWindows[alias];
            }
            if (privateChatListeners[alias]) {
                privateChatListeners[alias]();
                delete privateChatListeners[alias];
            }
            // Si no quedan ventanas, desactivar pointer-events
            if (Object.keys(privateChatWindows).length === 0) {
                privateChatsContainer.style.pointerEvents = 'none';
            }
        }
        function loadPrivateChatHistory(alias, messagesDiv) {
            // Limpiar mensajes previos
            messagesDiv.innerHTML = '';
            const chatId = getPrivateChatId(userAlias, alias);
            const privateRef = firebase.database().ref('privateMessages').child(chatId);
            // Cargar últimos 20 mensajes
            const loadedTimestamps = new Set();
            privateRef.limitToLast(20).once('value', snapshot => {
                const msgs = [];
                snapshot.forEach(child => {
                    const msg = child.val();
                    msgs.push(msg);
                    if (msg.timestamp) loadedTimestamps.add(msg.timestamp);
                });
                msgs.forEach(msg => {
                    appendPrivateMessage(messagesDiv, msg, alias);
                });
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            });
            // Escuchar nuevos mensajes (solo si no están ya en el historial)
            const listener = privateRef.limitToLast(1).on('child_added', snap => {
                const msg = snap.val();
                if (!msg.timestamp || !loadedTimestamps.has(msg.timestamp)) {
                    appendPrivateMessage(messagesDiv, msg, alias);
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                }
            });
            // Guardar función para limpiar listener
            privateChatListeners[alias] = () => privateRef.off('child_added', listener);
        }
        function appendPrivateMessage(messagesDiv, msg, otherAlias) {
            const isOwn = msg.from === userAlias;
            const div = document.createElement('div');
            div.className = isOwn ? 'chat-message own' : 'chat-message';
            div.style.margin = '6px 0';
            div.style.textAlign = isOwn ? 'right' : 'left';
            div.innerHTML = `<span style="color:${isOwn ? '#FFD700' : '#4ECDC4'}; font-weight:bold;">${isOwn ? 'Tú' : otherAlias}:</span> <span style="color:#fff;">${msg.message}</span> <span style="color:#aaa; font-size:11px; margin-left:8px;">${msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : ''}</span>`;
            messagesDiv.appendChild(div);
            // Limitar a los últimos 20 mensajes
            while (messagesDiv.children.length > 20) {
                messagesDiv.removeChild(messagesDiv.firstChild);
            }
        }
        // UI: Al hacer clic en un usuario, abrir ventana privada
        usersList.addEventListener('click', function(e) {
            const userItem = e.target.closest('.user-item');
            if (userItem && !userItem.classList.contains('own')) {
                const alias = userItem.textContent.replace(' (Tú)', '').trim();
                openPrivateChatWindow(alias);
            }
        });

        // Devuelve el color del cielo según la hora actual (día, atardecer, noche)
        function getSkyColorByHour() {
            const hour = new Date().getHours();
            if (hour >= 7 && hour < 18) {
                return 0x87CEEB; // Día: azul claro
            } else if (hour >= 18 && hour < 20) {
                return 0xFFA07A; // Atardecer: naranja/rojo suave
            } else {
                return 0x223366; // Noche: azul oscuro
            }
        }

        // --- Variables globales para el cielo de la habitación personal ---
        
    </script>
</body>
