<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paseo Virtual por Centro Comercial</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            mix-blend-mode: difference;
            z-index: 5;
        }
        #chat-toggle-btn {
            position: fixed;
            top: 16px;
            left: 16px;
            width: 36px;
            height: 36px;
            background: #222;
            color: #fff;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            font-size: 20px;
            transition: background 0.2s;
        }
        #chat-toggle-btn:hover {
            background: #444;
        }
        #chat-panel {
            position: fixed;
            top: 60px;
            left: 16px;
            width: 480px;
            max-width: 90vw;
            height: 600px;
            background: rgba(30,30,30,0.85);
            border-radius: 12px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.4);
            z-index: 1003;
            display: none;
            flex-direction: column;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        #chat-header {
            background: rgba(24,24,24,0.9);
            color: #fff;
            padding: 12px 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        #chat-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        #chat-main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        #users-sidebar {
            width: 140px;
            background: rgba(34,34,34,0.9);
            border-left: 1px solid #333;
            padding: 8px;
            overflow-y: auto;
        }
        #users-title {
            color: #aaa;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
        }
        .user-item {
            color: #fff;
            font-size: 12px;
            padding: 4px 6px;
            margin-bottom: 2px;
            border-radius: 4px;
            background: #333;
            border-left: 3px solid transparent;
        }
        #emoji-panel {
            position: absolute;
            bottom: 70px;
            left: 10px;
            right: 10px;
            background: rgba(51,51,51,0.95);
            border-radius: 8px;
            padding: 10px;
            display: none;
            flex-wrap: wrap;
            gap: 4px;
            max-height: 140px;
            overflow-y: auto;
            backdrop-filter: blur(5px);
        }
        .emoji-btn {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: background 0.2s;
        }
        .emoji-btn:hover {
            background: #555;
        }
        #emoji-toggle {
            background: none;
            border: none;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            padding: 4px;
            margin-right: 4px;
        }
        #chat-close-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
        }
        #chat-messages {
            flex: 1;
            padding: 12px;
            overflow-y: auto;
            color: #eee;
            font-size: 15px;
        }
        #chat-input-area {
            display: flex;
            border-top: 1px solid #333;
            background: rgba(34,34,34,0.9);
            padding: 10px;
        }
        #chat-input {
            flex: 1;
            border: none;
            background: #333;
            color: #fff;
            border-radius: 6px;
            padding: 8px;
            font-size: 15px;
        }
        #chat-send-btn {
            background: #4B0000;
            color: #fff;
            border: none;
            border-radius: 6px;
            margin-left: 8px;
            padding: 8px 14px;
            font-size: 15px;
            cursor: pointer;
            transition: background 0.2s;
        }
        #chat-send-btn:hover {
            background: #800000;
        }
        #alias-prompt {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1002;
        }
        #alias-prompt input {
            padding: 10px;
            font-size: 16px;
            border-radius: 6px;
            border: none;
            margin-bottom: 12px;
        }
        #alias-prompt button {
            padding: 8px 18px;
            font-size: 15px;
            border-radius: 6px;
            border: none;
            background: #4B0000;
            color: #fff;
            cursor: pointer;
        }
        #change-alias-btn {
            position: fixed;
            top: 16px;
            left: 60px;
            width: 36px;
            height: 36px;
            background: #333;
            color: #fff;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            font-size: 16px;
            transition: background 0.2s;
        }
        #change-alias-btn:hover {
            background: #555;
        }
        
        /* Estilos para el panel de personalizaci√≥n simple */
        #simple-panel.customization-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 1100px;
            max-width: 99vw;
            height: 700px;
            background: linear-gradient(135deg, rgba(20,20,20,0.98), rgba(30,30,30,0.98));
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            z-index: 21000; /* Siempre por encima del overlay */
            display: none;
            flex-direction: column;
            overflow: hidden;
            backdrop-filter: blur(20px);
            border: 2px solid #4B0000;
            pointer-events: auto;
        }
        
        #simple-panel .panel-header {
            background: linear-gradient(135deg, #4B0000, #800000);
            color: #fff;
            padding: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 2px solid #FFD700;
        }
        
        #simple-panel .panel-header > div {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        #simple-panel .panel-header > div span:first-child {
            font-size: 28px;
        }
        
        #simple-panel .panel-header > div span:last-child {
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        #simple-panel .panel-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            color: #eee;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            min-height: 0;
            min-width: 0;
        }
        
        #simple-panel .options-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        #simple-panel .preview-column {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        #simple-panel .option-section {
            padding: 8px;
            background: linear-gradient(135deg, rgba(40,40,40,0.8), rgba(50,50,50,0.8));
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            margin-bottom: 4px;
        }
        
        #simple-panel .section-title {
            margin: 0 0 8px 0;
            color: #FFD700;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        #simple-panel .section-title span:first-child {
            font-size: 16px;
        }
        
        #simple-panel .color-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
        }
        
        #simple-panel .preview-section {
            padding: 10px;
            background: linear-gradient(135deg, rgba(40,40,40,0.8), rgba(50,50,50,0.8));
            border-radius: 6px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            text-align: center;
        }
        
        #simple-panel .avatar-preview {
            width: 150px;
            height: 200px;
            margin: 0 auto;
            position: relative;
            background: linear-gradient(135deg, rgba(20,20,20,0.5), rgba(30,30,30,0.5));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #333;
        }
        
        #simple-panel .panel-footer {
            padding: 8px 10px;
            background: linear-gradient(135deg, rgba(34,34,34,0.95), rgba(44,44,44,0.95));
            border-top: 1px solid #333;
            display: flex;
            gap: 6px;
            justify-content: flex-end;
        }
        
        /* Estilos adicionales para elementos espec√≠ficos */
        #simple-panel .close-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            padding: 6px;
            border-radius: 6px;
            transition: all 0.3s;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #simple-panel .section-icon {
            font-size: 16px;
        }

        #simple-panel #simple-alias-input {
            width: 100%;
            padding: 12px;
            font-size: 14px;
            border-radius: 6px;
            border: 2px solid #333;
            background: rgba(20,20,20,0.8);
            color: #fff;
            box-sizing: border-box;
            transition: all 0.3s;
            outline: none;
        }

        #simple-panel #simple-alias-input:focus {
            border-color: #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        #customization-actions {
            padding: 16px 20px;
            background: rgba(34,34,34,0.9);
            border-top: 1px solid #333;
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            width: 100%;
            min-height: 60px;
            box-sizing: border-box;
        }
        
        .customization-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        #save-customization-btn {
            background: linear-gradient(135deg, #4B0000, #800000);
            color: #fff;
        }
        
        #save-customization-btn:hover {
            background: linear-gradient(135deg, #800000, #B22222);
            transform: translateY(-1px);
        }
        
        #reset-customization-btn {
            background: #333;
            color: #ccc;
        }
        
        #reset-customization-btn:hover {
            background: #555;
            color: #fff;
        }
        
        /* Estilos para los botones de color */
        .color-option {
            width: 30px;
            height: 30px;
            border: 2px solid #333;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--color, #333);
        }
        .color-option[data-color] {
            border: 2px solid #333;
        }
        .color-option:hover {
            border-color: #FFD700;
        }
        
        /* Animaciones para el panel */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        #simple-panel {
            animation: slideIn 0.3s ease-out;
        }
        
        /* Estilos para el input de alias */
        #simple-alias-input:focus {
            border-color: #FFD700 !important;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3) !important;
        }
        
        /* Estilos para los botones del footer */
        #simple-panel button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4) !important;
        }
        
        #simple-panel button:active {
            transform: translateY(0);
        }
        .chat-message {
            padding: 6px 10px;
            border-radius: 8px;
            margin-bottom: 4px;
            background: rgba(40,40,40,0.7);
            display: inline-block;
            max-width: 90%;
            word-break: break-word;
        }
        .chat-message.own {
            background: linear-gradient(90deg, #FFD70033, #FFD70011);
        }
        /* Overlay para bloquear clics al fondo cuando el panel de personalizaci√≥n est√° abierto */
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.5);
            z-index: 20000; /* Debe estar debajo del panel de personalizaci√≥n */
            pointer-events: none; /* Solo se activa cuando el panel est√° abierto */
            display: none; /* Solo se muestra cuando el panel est√° abierto */
        }

    </style>
</head>
<body>
    <div id="ui-overlay"></div>
    <div id="crosshair"></div>
    <button id="chat-toggle-btn" title="Abrir chat">üí¨</button>
    <button id="change-alias-btn" title="Personalizar avatar">üë§</button>
        <!-- Panel de personalizaci√≥n completamente redise√±ado -->
    <div id="simple-panel" class="customization-panel">
        <!-- Header elegante -->
        <div class="panel-header">
            <div>
                <span>üë§</span>
                <span>Personalizar Avatar</span>
            </div>
            <button onclick="closeSimplePanel()" class="close-btn">‚úñ</button>
        </div>
        
        <!-- Contenido principal -->
        <div class="panel-content">
            <!-- Columna izquierda - Opciones -->
            <div class="options-column">
                <!-- Secci√≥n de Alias -->
                <div class="option-section">
                    <h3 class="section-title">
                        <span class="section-icon">üìù</span>
                        Nombre del Avatar
                    </h3>
                    <input type="text" id="simple-alias-input" placeholder="Escribe tu nombre..." maxlength="20">
                </div>
                
                <!-- Secci√≥n de Colores de Camisa -->
                <div class="option-section">
                    <h3 class="section-title">
                        <span class="section-icon">üëï</span>
                        Color de Camisa
                    </h3>
                    <div id="shirt-colors" class="color-grid">
                        <!-- Los colores se agregar√°n din√°micamente -->
                    </div>
                </div>
                
                <!-- Secci√≥n de Colores de Pantal√≥n -->
                <div class="option-section">
                    <h3 class="section-title">
                        <span style="font-size: 20px;">üëñ</span>
                        Color de Pantal√≥n
                    </h3>
                    <div id="pants-colors" class="color-grid">
                        <!-- Los colores se agregar√°n din√°micamente -->
                    </div>
                </div>
                
                <!-- Secci√≥n de Colores de Zapatos -->
                <div class="option-section">
                    <h3 class="section-title">
                        <span style="font-size: 20px;">üëû</span>
                        Color de Zapatos
                    </h3>
                    <div id="shoes-colors" class="color-grid">
                        <!-- Los colores se agregar√°n din√°micamente -->
                    </div>
                </div>
            </div>
            
            <!-- Columna derecha - Vista previa -->
            <div class="preview-column">
                <!-- Vista previa del avatar -->
                <div class="preview-section">
                    <h3 style="margin: 0 0 20px 0; color: #FFD700; font-size: 18px; text-transform: uppercase; letter-spacing: 1px; display: flex; align-items: center; justify-content: center; gap: 10px;">
                        <span style="font-size: 20px;">üë§</span>
                        Vista Previa
                    </h3>
                    <div id="avatar-preview" class="avatar-preview">
                        <div style="color: #ccc; font-size: 14px;">Avatar en tiempo real</div>
                    </div>
                </div>
                <!-- Eliminada la tarjeta de 'Nombre Actual' y alias -->
            </div>
        </div>
        
        <!-- Footer con botones -->
        <div class="panel-footer">
            <button onclick="resetSimpleCustomization()" style="padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; background: linear-gradient(135deg, #555, #777); color: #fff; transition: all 0.3s; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">üîÑ Restablecer</button>
            <button onclick="saveSimpleCustomization()" style="padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; background: linear-gradient(135deg, #4B0000, #800000); color: #fff; transition: all 0.3s; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">üíæ Guardar</button>
        </div>
    </div>
    <div id="chat-panel">
        <div id="chat-header">
            Chat
            <button id="chat-close-btn" title="Cerrar">‚úñ</button>
        </div>
        <div id="chat-content">
            <div id="chat-main">
                <div id="chat-messages"></div>
                <div id="chat-input-area">
                    <button id="emoji-toggle" title="Emojis">üòä</button>
                    <input id="chat-input" type="text" placeholder="Escribe un mensaje..." autocomplete="off" />
                    <button id="chat-send-btn">Enviar</button>
                </div>
                <div id="emoji-panel"></div>
            </div>
            <div id="users-sidebar">
                <div id="users-title">Usuarios</div>
                <div id="users-list"></div>
            </div>
        </div>
    </div>
    
    <!-- Panel de personalizaci√≥n de avatar -->
    <!-- Eliminado: <div id="customization-panel">...</div> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="/firebase-config.js"></script>
    <script>
        // URLs de las tiendas proporcionadas por el usuario (duplicadas para llenar todos los pisos)
        const originalStoreLinks = [
            "https://www.ipweb.pro/en/?Davincho88", "https://ipgold.biz/?r=meramente42@gmail.com", "https://surfe.be/ext/2837287",
            "https://sproutgigs.com/?a=0675642e", "https://r.adbtc.top/2847448", "https://www.coinpayu.com/?r=everest101",
            "https://surfio.site/i/794", "https://serfclick.net/i/277142", "https://faucetcrypto.com/r/1373767",
            "https://earnbitmoon.club/?ref=1075373", "https://viefaucet.com?r=6383ddeaec6d7776fc69e555", "https://simplebits.io/ref/OLkiv6stfLj_",
            "https://tap-coin.de/refer/user/4365", "https://btcadspace.com/ref/p4ch3c0", "https://trustdice.win/faucet/?ref=u_mapachox101",
            "http://cointiply.com/r/4yDJAp", "https://autofaucet.dutchycorp.space/?r=sakreto", "https://freebitco.in/?r=49843181",
            "https://faucetpay.io/?r=2136351", "https://r.honeygain.me/MERAM588A9", "https://pawns.app/?r=585883",
            "https://teaserfast.ru/u/mapachox", "https://addon.money/p/343495", "https://everve.net/ref/961754/",
            "https://swashapp.io/download?referral_code=3opl7k4ztf53", "https://addslice.com/?crew=JHVJ6", "https://earnapp.com/i/4zbftm2",
            "https://node.optimai.network/register?ref=F471454F", "https://dashboard.teneo.pro/auth/signup?referralCode=ERPr2", "https://app.nodepay.ai/register?ref=kOYHwfDuFNSSZg2",
            "https://www.jumptask.io/r/budapygirazu", "https://payeer.com/?partner=23994523", "https://rollercoin.com/?r=m9dnpgsp",
            "https://bux.money/u/239006", "https://www.swagbucks.com/p/register?rb=119244201&rp=1", "https://app.getgrass.io/register?referralCode=SwWRadefuICY8DI",
            "https://freecash.com/r/116249823271721789104", "https://r.honeygain.me/AIRRIFADB7", "https://www.binance.com/referral/earn-together/refertoearn2000usdc/claim?hl=en&ref=GRO_14352_ZBFKF",
            "https://www.paidwork.com/?r=meramente42", "https://www.bybit.com/invite?ref=VWN6NL", "https://app-earnings-link.com/givvyMusic/hoty216dfkvisgv",
            "https://swcapp.com/i/davehz", "https://app-earnings-link.com/givvyStream/a6dd8fsmn6t6qhfjjw5", "https://app-earnings-link.com/givvyScratchCardNew/euz9t4x3bmk6"
        ];

        // Mapeo de dominios a nombres de archivo de logos
        const domainToLogoMap = {
            'ipweb': 'ipweb-logo.png',
            'ipgold': 'ipgold-logo.png',
            'surfe': 'surfe-logo.png',
            'sproutgigs': 'sproutgigs-logo.png',
            'adbtc': 'adbtc-logo.png',
            'coinpayu': 'coinpayu-logo.png',
            'surfio': 'surfio-logo.png',
            'serfclick': 'serfclick-logo.png',
            'faucetcrypto': 'faucetcrypto-logo.png',
            'earnbitmoon': 'earnbitmoon-logo.png',
            'viefaucet': 'viefaucet-logo.png',
            'simplebits': 'simplebits-logo.png',
            'tap-coin': 'tapcoin-logo.png',
            'btcadspace': 'btcadspace-logo.png',
            'trustdice': 'trustdice-logo.png',
            'cointiply': 'cointiply-logo.png',
            'autofaucet': 'autofaucet-logo.png',
            'freebitco': 'freebitcoin-logo.png',
            'faucetpay': 'faucetpay-logo.png',
            'honeygain': 'honeygain-logo.png',
            'pawns': 'pawns-logo.png',
            'teaserfast': 'teaserfast-logo.png',
            'addon': 'addonmoney-logo.png',
            'everve': 'everve-logo.png',
            'swashapp': 'swash-logo.png',
            'addslice': 'addslice-logo.png',
            'earnapp': 'earnapp-logo.png',
            'optimai': 'optimai-logo.png',
            'teneo': 'teneo-logo.png',
            'nodepay': 'nodepay-logo.png',
            'jumptask': 'jumptask-logo.png',
            'payeer': 'payeer-logo.png',
            'rollercoin': 'rollercoin-logo.png',
            'bux': 'buxmoney-logo.png',
            'swagbucks': 'swagbucks-logo.png',
            'grass': 'grass-logo.png',
            'getgrass': 'grass-logo.png', // Agregar alias para app.getgrass.io
            'freecash': 'freecash-logo.png',
            'binance': 'binance-logo.png',
            'paidwork': 'paidwork-logo.png',
            'bybit': 'bybit-logo.png',
            'givvyMusic': 'givvymusic-logo.png',
            'givvyStream': 'givvystream-logo.png',
            'givvyScratchCardNew': 'givvystream-logo.png', // Usar givvystream como fallback
            'swcapp': 'swcapp-logo.png',
            'app-earnings-link': 'givvystream-logo.png' // Agregar alias para app-earnings-link.com
        };

        // Duplicar los enlaces 5 veces para asegurar que hay suficientes para todos los pisos
        const storeLinks = [];
        for (let i = 0; i < 5; i++) {
            storeLinks.push(...originalStoreLinks);
        }

        // --- Constantes y Configuraci√≥n Global ---
        const HALL_SIZE = 90; // Aumentado 1.5 veces (60 * 1.5 = 90)
        const HALL_HEIGHT = 4;
        const MOVE_SPEED = 0.8;
        const ROTATE_SPEED = 0.1;
        const CAMERA_HEIGHT = 1.6;
        const MAX_FLOOR = 1; // Cambiado de 4 a 1 (solo 2 pisos: planta baja + 1 piso superior)
        const MIN_FLOOR = 0;

        // --- Variables de la Escena ---
        let scene, camera, renderer;
        const clickableObjects = [];
        const collisionObjects = [];
        const keys = { W: false, S: false, A: false, D: false, ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        
        // --- Variables para Avatares de Usuarios ---
        const userAvatars = new Map(); // Mapa de alias -> avatar
        const avatarColors = [
            0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFFEAA7,
            0xDDA0DD, 0x98D8C8, 0xF7DC6F, 0xBB8FCE, 0x85C1E9,
            0xF8C471, 0x82E0AA, 0xF1948A, 0x85C1E9, 0xD7BDE2,
            0xF9E79F, 0xABEBC6, 0xFAD7A0, 0xAED6F1, 0xF5B7B1
        ];

        // --- Variables de personalizaci√≥n de avatar ---
        const customizationColors = [
            // Colores vibrantes para camisas
            0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFFEAA7, 0xDDA0DD,
            0x98D8C8, 0xF7DC6F, 0xBB8FCE, 0x85C1E9, 0xF8C471, 0x82E0AA,
            0xF1948A, 0xD7BDE2, 0xF9E79F, 0xABEBC6, 0xFAD7A0, 0xAED6F1,
            // Colores m√°s oscuros para pantalones
            0x2C3E50, 0x34495E, 0x8B4513, 0x654321, 0x2F4F4F, 0x696969,
            0x556B2F, 0x8B0000, 0x4B0082, 0x191970, 0x006400, 0x8B4513,
            0x654321, 0x2F4F4F, 0x696969, 0x556B2F, 0x8B0000, 0x4B0082,
            // Colores para zapatos
            0x8B4513, 0x654321, 0x000000, 0x2F4F4F, 0x696969, 0x8B0000,
            0x4B0082, 0x191970, 0x006400, 0x8B4513, 0x654321, 0x2F4F4F,
            0x696969, 0x556B2F, 0x8B0000, 0x4B0082, 0x191970, 0x006400
        ];
        

        
        let customizationPanelOpen = false;

        // --- Variables de Interacci√≥n y Movimiento ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let targetPosition;
        let targetRotationY;
        let currentFloor = 0;
        let keyA = false;
        let keyD = false;
        let keyW = false;
        let keyS = false;
        let shopNumberCounter = 1; // Contador global para numerar las tiendas

        // Funci√≥n para obtener el siguiente n√∫mero de tienda solo cuando se crea una
        const getNextShopNumber = () => {
            return shopNumberCounter++;
        };

        // --- Variables de rendimiento ---
        let lastTime = 0;
        let frameCount = 0;
        let fps = 60;
        const targetFPS = 60;
        const frameInterval = 1000 / targetFPS;
        let lastSkyUpdate = 0; // Para actualizar el cielo cada minuto

        // --- Cache de materiales para reutilizaci√≥n ---
        const materialCache = new Map();
        const textureCache = new Map();

        function getCachedMaterial(color, roughness = 0.8, metalness = 0.2) {
            const key = `${color}-${roughness}-${metalness}`;
            if (!materialCache.has(key)) {
                materialCache.set(key, new THREE.MeshStandardMaterial({ 
                    color, 
                    roughness, 
                    metalness 
                }));
            }
            return materialCache.get(key);
        }

        function getCachedTexture(text, colorIdx, width, height) {
            const key = `${text}-${colorIdx}-${width}-${height}`;
            if (!textureCache.has(key)) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const canvasW = Math.min(512, width * 64); // Reducir tama√±o del canvas
                const canvasH = Math.min(512, height * 64);
                canvas.width = canvasW;
                canvas.height = canvasH;
                
                context.fillStyle = `hsl(${colorIdx * 47 % 360}, 60%, 50%)`;
                context.fillRect(0, 0, canvasW, canvasH);
                
                context.font = `bold ${canvasH * 0.3}px Arial`;
                context.fillStyle = 'white';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text.charAt(0).toUpperCase() + text.slice(1), canvasW / 2, canvasH / 2);

                const texture = new THREE.CanvasTexture(canvas);
                textureCache.set(key, texture);
            }
            return textureCache.get(key);
        }

        // --- Funci√≥n para obtener el color del cielo seg√∫n la hora ---
        function getSkyColor() {
            const now = new Date();
            const hour = now.getHours();
            
            // Transiciones suaves entre colores seg√∫n la hora
            if (hour >= 6 && hour < 12) {
                // Ma√±ana: azul claro
                return new THREE.Color(0x87CEEB); // Sky blue
            } else if (hour >= 12 && hour < 18) {
                // Tarde: azul m√°s intenso
                return new THREE.Color(0x4682B4); // Steel blue
            } else if (hour >= 18 && hour < 20) {
                // Atardecer: naranja/rosa
                return new THREE.Color(0xFF7F50); // Coral
            } else if (hour >= 20 && hour < 22) {
                // Anochecer: azul oscuro
                return new THREE.Color(0x191970); // Midnight blue
            } else {
                // Noche: negro
                return new THREE.Color(0x000000); // Black
            }
        }

        function init() {
            // --- Configuraci√≥n de la Escena, C√°mara y Renderer ---
            setupScene();
            setupLighting();
            createMall();

            // --- Event Listeners ---
            setupEventListeners();
            
            // --- Configurar botones de UI ---
            setupUIButtons();

            // --- Iniciar Animaci√≥n ---
            animate();
        }

        function setupScene() {
            scene = new THREE.Scene();
            scene.background = getSkyColor(); // Color din√°mico del cielo
            scene.fog = new THREE.Fog(0x1a1a1a, 15, 105); // Ajustado para el nuevo tama√±o

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(25, CAMERA_HEIGHT, 25); // Posici√≥n m√°s cerca del centro
            camera.lookAt(HALL_SIZE / 2, CAMERA_HEIGHT, HALL_SIZE / 2);

            targetPosition = camera.position.clone();
            targetRotationY = camera.rotation.y;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limitar pixel ratio
            renderer.shadowMap.enabled = false;
            document.body.appendChild(renderer.domElement);
        }

        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(30, 45, 15);
            directionalLight.castShadow = false;
            scene.add(directionalLight);
        }

        function createMall() {
            // --- Materiales ---
            const floorMaterial = getCachedMaterial(0x444444, 0.8, 0.2);
            const wallMaterial = getCachedMaterial(0x6B8E23, 0.9); // Verde oliva
            const separatorMaterial = getCachedMaterial(0xFFFFFF, 0.9); // Blanco para muros separadores

            // --- Creaci√≥n del Centro Comercial ---
            let linkIndex = 0;
            
            // Planta baja con tiendas
            linkIndex = createFloorLevel(0, floorMaterial, wallMaterial, separatorMaterial, linkIndex);
            
            // Solo un piso superior con tiendas y pasillos (piso 1)
            const floorY = 1 * (HALL_HEIGHT + 1);
            linkIndex = createUpperFloorLevel(floorY, floorMaterial, wallMaterial, separatorMaterial, linkIndex);

            // --- Estructura Central completa ---
            const centralStructureY = 0;
            const cubeSize = 6;
            createCentralCubeScreens(HALL_SIZE / 2, centralStructureY, HALL_SIZE / 2, cubeSize, storeLinks.slice(0, 4), 0, 2500);
            createCentralCubeScreens(HALL_SIZE / 2, centralStructureY + cubeSize * 0.8, HALL_SIZE / 2, cubeSize, storeLinks.slice(4, 8), 100, 2000);
            createCentralCubeScreens(HALL_SIZE / 2, centralStructureY + cubeSize * 1.6, HALL_SIZE / 2, cubeSize, storeLinks.slice(8, 12), 200, 1800);
            const clockCubeY = centralStructureY + cubeSize * 2.4;
            createDigitalClockCube(HALL_SIZE / 2, clockCubeY, HALL_SIZE / 2, cubeSize);

            // C√∫pula
            const pyramidHeight = cubeSize * 1.5;
            const pyramidGeometry = new THREE.ConeGeometry(cubeSize / Math.SQRT2 * 1.2, pyramidHeight, 4);
            const pyramidMaterial = getCachedMaterial(0xA0522D, 0.8, 0.1); // Sienna
            const pyramid = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
            pyramid.position.set(HALL_SIZE / 2, clockCubeY + cubeSize * 0.8 + pyramidHeight / 2, HALL_SIZE / 2);
            pyramid.rotation.y = Math.PI / 4;
            scene.add(pyramid);

            // Crear √°rea de descanso completa (restaurar 8 mesas)
            const gardenRadius = 8;
            const tableCount = 8;
            
            for (let i = 0; i < tableCount; i++) {
                const angle = (i / tableCount) * Math.PI * 2;
                const radius = gardenRadius + Math.random() * 2 - 1;
                
                // Crear mesa
                const tableTopGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.1, 8);
                const tableTopMaterial = getCachedMaterial(new THREE.Color().setHSL(0.1, 0.3, 0.7));
                const tableTop = new THREE.Mesh(tableTopGeometry, tableTopMaterial);
                
                // Patas de la mesa
                const tableLegGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.7, 6);
                const tableLegMaterial = getCachedMaterial(new THREE.Color().setHSL(0.05, 0.2, 0.5));
                
                // Posicionar mesa
                const tableX = HALL_SIZE / 2 + Math.cos(angle) * radius;
                const tableZ = HALL_SIZE / 2 + Math.sin(angle) * radius;
                
                tableTop.position.set(tableX, 0.85, tableZ);
                scene.add(tableTop);
                
                // Agregar 4 patas a la mesa
                for (let j = 0; j < 4; j++) {
                    const legAngle = (j / 4) * Math.PI * 2;
                    const legRadius = 0.6;
                    const leg = new THREE.Mesh(tableLegGeometry, tableLegMaterial);
                    leg.position.set(
                        tableX + Math.cos(legAngle) * legRadius,
                        0.35,
                        tableZ + Math.sin(legAngle) * legRadius
                    );
                    scene.add(leg);
                }
                
                // Crear parasol sobre la mesa
                const parasolPoleGeometry = new THREE.CylinderGeometry(0.03, 0.03, 2.5, 6);
                const parasolPoleMaterial = getCachedMaterial(new THREE.Color().setHSL(0.05, 0.2, 0.5));
                const parasolPole = new THREE.Mesh(parasolPoleGeometry, parasolPoleMaterial);
                parasolPole.position.set(tableX, 2.1, tableZ);
                // parasolPole.receiveShadow = true;
                scene.add(parasolPole);
                
                // Tela del parasol
                const parasolGeometry = new THREE.ConeGeometry(1.2, 0.3, 8);
                const parasolMaterial = getCachedMaterial(0x000080); // Azul oscuro
                const parasol = new THREE.Mesh(parasolGeometry, parasolMaterial);
                parasol.position.set(tableX, 3.25, tableZ);
                parasol.rotation.x = 0; // Quitar la rotaci√≥n para que apunte hacia arriba (invertido)
                // parasol.castShadow = false; // Desactivar sombras para mejor rendimiento
                // parasol.receiveShadow = true;
                scene.add(parasol);
                
                // Crear sillas completas (restaurar 4 sillas por mesa)
                const chairCount = 4; // Restaurar 4 sillas
                for (let k = 0; k < chairCount; k++) {
                    // Posicionar sillas en los 4 puntos cardinales alrededor de la mesa
                    const chairAngle = (k / chairCount) * Math.PI * 2; // 0¬∞, 90¬∞, 180¬∞, 270¬∞
                    const chairRadius = 1.8; // Distancia fija desde la mesa
                    
                    // Asiento de la silla
                    const seatGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.4);
                    const seatMaterial = getCachedMaterial(new THREE.Color().setHSL(0.08, 0.4, 0.6));
                    const seat = new THREE.Mesh(seatGeometry, seatMaterial);
                    
                    const chairX = tableX + Math.cos(chairAngle) * chairRadius;
                    const chairZ = tableZ + Math.sin(chairAngle) * chairRadius;
                    
                    seat.position.set(chairX, 0.45, chairZ);
                    // seat.castShadow = false; // Desactivar sombras para mejor rendimiento
                    // seat.receiveShadow = true;
                    scene.add(seat);
                    
                    // Patas de la silla
                    for (let l = 0; l < 4; l++) {
                        const chairLeg = new THREE.Mesh(chairLegGeometry, chairLegMaterial);
                        
                        const legOffsetX = (l % 2 === 0 ? -1 : 1) * 0.15;
                        const legOffsetZ = (l < 2 ? -1 : 1) * 0.15;
                        
                        chairLeg.position.set(chairX + legOffsetX, 0.225, chairZ + legOffsetZ);
                        // chairLeg.castShadow = false; // Desactivar sombras para mejor rendimiento
                        // chairLeg.receiveShadow = true;
                        scene.add(chairLeg);
                    }
                }
            }
        }

        // Funci√≥n centralizada para crear tiendas en sentido horario
        function createClockwiseStores(yOffset, storeDepth, storeWidth, storeSpacing, initialOffset, numStoresPerSide, wallMaterial, linkIndex) {
            // Funci√≥n para verificar si una posici√≥n est√° en una esquina
            const isCornerPosition = (index, side) => {
                // Saltar solo la primera y la √∫ltima tienda de cada lado
                return index === 0 || index === numStoresPerSide - 1;
            };

            // Norte (de izquierda a derecha)
            for (let i = 0; i < numStoresPerSide; i++) {
                if (isCornerPosition(i, 'north')) continue;
                const x = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                const currentLinkIndex = linkIndex % storeLinks.length;
                createStoreWithParams(x, storeDepth / 2, 0, currentLinkIndex, wallMaterial, yOffset, getNextShopNumber());
                linkIndex++;
            }

            // Este (de arriba hacia abajo)
            for (let i = 0; i < numStoresPerSide; i++) {
                if (isCornerPosition(i, 'east')) continue;
                const z = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                const currentLinkIndex = linkIndex % storeLinks.length;
                createStoreWithParams(HALL_SIZE - storeDepth / 2, z, -Math.PI / 2, currentLinkIndex, wallMaterial, yOffset, getNextShopNumber());
                linkIndex++;
            }

            // Sur (de derecha a izquierda)
            for (let i = numStoresPerSide - 1; i >= 0; i--) {
                if (isCornerPosition(i, 'south')) continue;
                const x = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                const currentLinkIndex = linkIndex % storeLinks.length;
                createStoreWithParams(x, HALL_SIZE - storeDepth / 2, Math.PI, currentLinkIndex, wallMaterial, yOffset, getNextShopNumber());
                linkIndex++;
            }

            // Oeste (de abajo hacia arriba)
            for (let i = numStoresPerSide - 1; i >= 0; i--) {
                if (isCornerPosition(i, 'west')) continue;
                const z = initialOffset + i * (storeWidth + storeSpacing) + storeWidth / 2;
                const currentLinkIndex = linkIndex % storeLinks.length;
                createStoreWithParams(storeDepth / 2, z, Math.PI / 2, currentLinkIndex, wallMaterial, yOffset, getNextShopNumber());
                linkIndex++;
            }
        }

        // Funci√≥n centralizada para crear muros separadores
        function createSeparatorWalls(yOffset, storeDepth, storeWidth, storeSpacing, initialOffset, numStoresPerSide, separatorMaterial) {
            // Norte
            for (let i = 0; i < numStoresPerSide - 1; i++) {
                const x = initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2;
                createSeparatorWall(x, storeDepth, true, yOffset, separatorMaterial);
            }

            // Sur
            for (let i = 0; i < numStoresPerSide - 1; i++) {
                const x = initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2;
                createSeparatorWall(x, HALL_SIZE - storeDepth, true, yOffset, separatorMaterial);
            }

            // Oeste
            for (let i = 0; i < numStoresPerSide - 1; i++) {
                const z = initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2;
                createSeparatorWall(storeDepth, z, false, yOffset, separatorMaterial);
            }

            // Este
            for (let i = 0; i < numStoresPerSide - 1; i++) {
                const z = initialOffset + (i + 1) * storeWidth + i * storeSpacing + storeSpacing / 2;
                createSeparatorWall(HALL_SIZE - storeDepth, z, false, yOffset, separatorMaterial);
            }
        }

        function createFloorLevel(yOffset, floorMaterial, wallMaterial, separatorMaterial, startLinkIndex) {
            // --- Suelo con patr√≥n de tablero de ajedrez optimizado ---
            // Crear textura de tablero de ajedrez
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            const tileSize = 64; // Tama√±o de cada cuadrado en la textura
            const tilesPerTexture = 8; // 8x8 cuadrados en la textura
            
            for (let x = 0; x < tilesPerTexture; x++) {
                for (let y = 0; y < tilesPerTexture; y++) {
                    const isBlack = (x + y) % 2 === 0;
                    ctx.fillStyle = isBlack ? '#000000' : '#FFFFFF';
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(8, 8); // Repetir la textura 8x8 veces
            
            const chessboardMaterial = new THREE.MeshStandardMaterial({ 
                map: texture,
                roughness: 0.8, 
                metalness: 0.1 
            });
            
            // Calcular el tama√±o del √°rea central (sin tiendas ni corredores)
            const storeDepth = 12;
            const corridorWidth = 8;
            const sueloOffset = corridorWidth / 2;
            const areaCentralSize = HALL_SIZE - 2 * (storeDepth + sueloOffset + 4); // Agregar 4 unidades m√°s de margen
            
            // Crear suelo de ajedrez solo para el √°rea central
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(areaCentralSize, areaCentralSize), chessboardMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(HALL_SIZE / 2, yOffset, HALL_SIZE / 2);
            floor.receiveShadow = true;
            scene.add(floor);
            collisionObjects.push(new THREE.Box3().setFromObject(floor));

            // --- Tiendas ---
            const storeSpacing = 1.5; // Espaciado ajustado para un balance entre densidad y espacio
            const numStoresPerSide = Math.floor(HALL_SIZE / (storeWidth + storeSpacing));
            const totalStoresWidth = numStoresPerSide * storeWidth + (numStoresPerSide - 1) * storeSpacing;
            const initialOffset = (HALL_SIZE - totalStoresWidth) / 2;
            let linkIndex = startLinkIndex;

            // Crear tiendas en sentido horario usando la funci√≥n centralizada
            createClockwiseStores(yOffset, storeDepth, storeWidth, storeSpacing, initialOffset, numStoresPerSide, wallMaterial, linkIndex);

            // Crear muros separadores usando la funci√≥n centralizada
            createSeparatorWalls(yOffset, storeDepth, storeWidth, storeSpacing, initialOffset, numStoresPerSide, separatorMaterial);

            // --- Crear pasillos en la planta baja ---
            // Usar las variables ya declaradas arriba
            const sueloLong = HALL_SIZE - 2 * (storeDepth + sueloOffset);
            const norteZ = storeDepth + sueloOffset;
            const surZ = HALL_SIZE - storeDepth - sueloOffset;
            const oesteX = storeDepth + sueloOffset;
            const esteX = HALL_SIZE - storeDepth - sueloOffset;
            
            // Material para el suelo del pasillo de la planta baja (rojo oscuro como el segundo piso)
            const pasilloMaterialPlantaBaja = new THREE.MeshStandardMaterial({ 
                color: 0x4B0000, // Color rojo oscuro igual al del segundo piso
                roughness: 0.8
            });
            
            // Funci√≥n para crear suelo de pasillo de la planta baja
            const createPasilloSueloPlantaBaja = (geometry, position) => {
                const suelo = new THREE.Mesh(geometry, pasilloMaterialPlantaBaja);
                suelo.position.copy(position);
                suelo.receiveShadow = true;
                return suelo;
            };
            
            // Norte - pasillo rojo oscuro
            const nortePasillo = createPasilloSueloPlantaBaja(
                new THREE.BoxGeometry(sueloLong, 0.2, corridorWidth),
                new THREE.Vector3(HALL_SIZE / 2, yOffset - 0.1, norteZ)
            );
            scene.add(nortePasillo);
            collisionObjects.push(new THREE.Box3().setFromObject(nortePasillo));
            
            // Sur - pasillo rojo oscuro
            const surPasillo = createPasilloSueloPlantaBaja(
                new THREE.BoxGeometry(sueloLong, 0.2, corridorWidth),
                new THREE.Vector3(HALL_SIZE / 2, yOffset - 0.1, surZ)
            );
            scene.add(surPasillo);
            collisionObjects.push(new THREE.Box3().setFromObject(surPasillo));
            
            // Oeste - pasillo rojo oscuro
            const oestePasillo = createPasilloSueloPlantaBaja(
                new THREE.BoxGeometry(corridorWidth, 0.2, sueloLong),
                new THREE.Vector3(oesteX, yOffset - 0.1, HALL_SIZE / 2)
            );
            scene.add(oestePasillo);
            collisionObjects.push(new THREE.Box3().setFromObject(oestePasillo));
            
            // Este - pasillo rojo oscuro
            const estePasillo = createPasilloSueloPlantaBaja(
                new THREE.BoxGeometry(corridorWidth, 0.2, sueloLong),
                new THREE.Vector3(esteX, yOffset - 0.1, HALL_SIZE / 2)
            );
            scene.add(estePasillo);
            collisionObjects.push(new THREE.Box3().setFromObject(estePasillo));
            
            // Esquinas - pasillo rojo oscuro
            const createCornerPlantaBaja = (posX, posZ) => {
                const corner = createPasilloSueloPlantaBaja(
                    new THREE.BoxGeometry(corridorWidth, 0.2, corridorWidth),
                    new THREE.Vector3(posX, yOffset - 0.1, posZ)
                );
                scene.add(corner);
                collisionObjects.push(new THREE.Box3().setFromObject(corner));
            };
            createCornerPlantaBaja(oesteX, norteZ); // NO
            createCornerPlantaBaja(esteX, norteZ); // NE
            createCornerPlantaBaja(oesteX, surZ); // SO
            createCornerPlantaBaja(esteX, surZ); // SE

            return linkIndex;
        }

        function createUpperFloorLevel(yOffset, floorMaterial, wallMaterial, separatorMaterial, startLinkIndex) {
            const storeDepth = 12;
            const storeWidth = 8;
            const storeSpacing = 1.5;
            const corridorWidth = 8; // Aumentado para eliminar huecos en el piso
            const numStoresPerSide = Math.floor(HALL_SIZE / (storeWidth + storeSpacing));
            const totalStoresWidth = numStoresPerSide * storeWidth + (numStoresPerSide - 1) * storeSpacing;
            const initialOffset = (HALL_SIZE - totalStoresWidth) / 2;
            let linkIndex = startLinkIndex;

            // Funci√≥n para verificar si una posici√≥n est√° en una esquina
            const isCornerPosition = (index, side) => {
                // Saltar solo la primera y la √∫ltima tienda de cada lado
                return index === 0 || index === numStoresPerSide - 1;
            };

            // --- Crear pasillos con suelo ---
            // Crear materiales para cada cara
            const pasilloMaterialVinotinto = new THREE.MeshStandardMaterial({ 
                color: 0x4B0000, // Color vinotinto m√°s oscuro
                roughness: 0.8
            });
            
            const pasilloMaterialBlanco = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF, // Color blanco
                roughness: 0.8
            });
            
            // Material original para el techo del pasillo
            const techoMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF, // Color blanco
                roughness: 0.8 
            });
            
            // El suelo empieza justo al frente de las tiendas para eliminar huecos
            const sueloOffset = corridorWidth / 2; // mitad del ancho del corredor para que empiece al frente de las tiendas
            const sueloLong = HALL_SIZE - 2 * (storeDepth + sueloOffset);
            const norteZ = storeDepth + sueloOffset;
            const surZ = HALL_SIZE - storeDepth - sueloOffset;
            const oesteX = storeDepth + sueloOffset;
            const esteX = HALL_SIZE - storeDepth - sueloOffset;
            
            // Funci√≥n para crear suelo de pasillo con dos colores
            const createPasilloSuelo = (geometry, position, materialVinotinto, materialBlanco) => {
                const grupo = new THREE.Group();
                
                // Cara superior (vinotinto) - ligeramente m√°s alta
                const caraSuperior = new THREE.Mesh(geometry, materialVinotinto);
                caraSuperior.position.set(0, 0.001, 0); // Ligeramente m√°s alta
                grupo.add(caraSuperior);
                
                // Cara inferior (blanca) - ligeramente m√°s baja
                const caraInferior = new THREE.Mesh(geometry, materialBlanco);
                caraInferior.position.set(0, -0.001, 0); // Ligeramente m√°s baja
                caraInferior.rotation.x = Math.PI; // Rotar 180 grados para que mire hacia abajo
                grupo.add(caraInferior);
                
                grupo.position.copy(position);
                return grupo;
            };
            
            // Norte - vinotinto arriba, blanco abajo
            const norte = createPasilloSuelo(
                new THREE.BoxGeometry(sueloLong, 0.2, corridorWidth),
                new THREE.Vector3(HALL_SIZE / 2, yOffset - 0.1, norteZ),
                pasilloMaterialVinotinto,
                pasilloMaterialBlanco
            );
            scene.add(norte);
            collisionObjects.push(new THREE.Box3().setFromObject(norte));
            
            // Sur - vinotinto arriba, blanco abajo
            const sur = createPasilloSuelo(
                new THREE.BoxGeometry(sueloLong, 0.2, corridorWidth),
                new THREE.Vector3(HALL_SIZE / 2, yOffset - 0.1, surZ),
                pasilloMaterialVinotinto,
                pasilloMaterialBlanco
            );
            scene.add(sur);
            collisionObjects.push(new THREE.Box3().setFromObject(sur));
            
            // Oeste - vinotinto arriba, blanco abajo
            const oeste = createPasilloSuelo(
                new THREE.BoxGeometry(corridorWidth, 0.2, sueloLong),
                new THREE.Vector3(oesteX, yOffset - 0.1, HALL_SIZE / 2),
                pasilloMaterialVinotinto,
                pasilloMaterialBlanco
            );
            scene.add(oeste);
            collisionObjects.push(new THREE.Box3().setFromObject(oeste));
            
            // Este - vinotinto arriba, blanco abajo
            const este = createPasilloSuelo(
                new THREE.BoxGeometry(corridorWidth, 0.2, sueloLong),
                new THREE.Vector3(esteX, yOffset - 0.1, HALL_SIZE / 2),
                pasilloMaterialVinotinto,
                pasilloMaterialBlanco
            );
            scene.add(este);
            collisionObjects.push(new THREE.Box3().setFromObject(este));
            
            // Esquinas - vinotinto arriba, blanco abajo
            const createCorner = (posX, posZ) => {
                const corner = createPasilloSuelo(
                    new THREE.BoxGeometry(corridorWidth, 0.2, corridorWidth),
                    new THREE.Vector3(posX, yOffset - 0.1, posZ),
                    pasilloMaterialVinotinto,
                    pasilloMaterialBlanco
                );
                scene.add(corner);
                collisionObjects.push(new THREE.Box3().setFromObject(corner));
            };
            createCorner(oesteX, norteZ); // NO
            createCorner(esteX, norteZ); // NE
            createCorner(oesteX, surZ); // SO
            createCorner(esteX, surZ); // SE

            // --- Crear techos de pasillos (solo para el segundo piso) ---
            const currentFloor = Math.floor(yOffset / (HALL_HEIGHT + 1));
            if (currentFloor === 1) { // Segundo piso (piso 1, ya que empezamos desde 0)
                const ceilingHeight = 0.2;
                const extendedHeight = HALL_HEIGHT + 1;
                const ceilingY = yOffset + (extendedHeight / 2 + 2.5); // Mucho m√°s alto que el techo de las tiendas
                const extendedCorridorWidth = corridorWidth + 4; // Reducir el sobresaliente del techo
                
                // Norte - techo gris original
                const techoNorte = new THREE.Mesh(new THREE.BoxGeometry(sueloLong, ceilingHeight, extendedCorridorWidth), techoMaterial);
                techoNorte.position.set(HALL_SIZE / 2, ceilingY, norteZ + 2); // Reducir sobresaliente hacia el centro
                // techoNorte.receiveShadow = true;
                // techoNorte.castShadow = true;
                scene.add(techoNorte);
                
                // Sur - techo gris original
                const techoSur = new THREE.Mesh(new THREE.BoxGeometry(sueloLong, ceilingHeight, extendedCorridorWidth), techoMaterial);
                techoSur.position.set(HALL_SIZE / 2, ceilingY, surZ - 2); // Reducir sobresaliente hacia el centro
                // techoSur.receiveShadow = true;
                // techoSur.castShadow = true;
                scene.add(techoSur);
                
                // Oeste - techo gris original
                const techoOeste = new THREE.Mesh(new THREE.BoxGeometry(extendedCorridorWidth, ceilingHeight, sueloLong), techoMaterial);
                techoOeste.position.set(oesteX + 2, ceilingY, HALL_SIZE / 2); // Reducir sobresaliente hacia el centro
                // techoOeste.receiveShadow = true;
                // techoOeste.castShadow = true;
                scene.add(techoOeste);
                
                // Este - techo gris original
                const techoEste = new THREE.Mesh(new THREE.BoxGeometry(extendedCorridorWidth, ceilingHeight, sueloLong), techoMaterial);
                techoEste.position.set(esteX - 2, ceilingY, HALL_SIZE / 2); // Reducir sobresaliente hacia el centro
                // techoEste.receiveShadow = true;
                // techoEste.castShadow = true;
                scene.add(techoEste);
                
                // Esquinas del techo - gris original
                const createCeilingCorner = (posX, posZ) => {
                    const techoCorner = new THREE.Mesh(new THREE.BoxGeometry(extendedCorridorWidth, ceilingHeight, extendedCorridorWidth), techoMaterial);
                    techoCorner.position.set(posX, ceilingY, posZ);
                    // techoCorner.receiveShadow = true;
                    // techoCorner.castShadow = true;
                    scene.add(techoCorner);
                };
                createCeilingCorner(oesteX + 2, norteZ + 2); // NO
                createCeilingCorner(esteX - 2, norteZ + 2); // NE
                createCeilingCorner(oesteX + 2, surZ - 2); // SO
                createCeilingCorner(esteX - 2, surZ - 2); // SE
            }

                    trapezoid.rotation.y = Math.PI / 4; // Rotar 45 grados
                    trapezoid.castShadow = true;
                    trapezoid.receiveShadow = true;
            // --- Crear barandas al borde exterior de los corredores ---
            const railingHeight = 0.8;
            const railMat = new THREE.MeshStandardMaterial({ color: 0x000000, metalness: 0.5, roughness: 0.5 }); // Color negro
            const cornerGap = 2; // Espacio en las esquinas para no bloquear el paso
            const barandaLong = (sueloLong + corridorWidth - cornerGap) / 2; // Longitud de cada tramo
            const railThickness = 0.3; // Grosor de las barandas para hacerlas s√≥lidas
            
            // Norte - dos tramos separados
            const railN1 = new THREE.Mesh(new THREE.BoxGeometry(barandaLong, railingHeight, railThickness), railMat);
            railN1.position.set(storeDepth + corridorWidth + barandaLong / 2, yOffset + railingHeight / 2 - 0.1, storeDepth + corridorWidth);
            scene.add(railN1);
            const railN2 = new THREE.Mesh(new THREE.BoxGeometry(barandaLong, railingHeight, railThickness), railMat);
            railN2.position.set(HALL_SIZE - storeDepth - corridorWidth - barandaLong / 2, yOffset + railingHeight / 2 - 0.1, storeDepth + corridorWidth);
            scene.add(railN2);
            
            // Sur - dos tramos separados
            const railS1 = new THREE.Mesh(new THREE.BoxGeometry(barandaLong, railingHeight, railThickness), railMat);
            railS1.position.set(storeDepth + corridorWidth + barandaLong / 2, yOffset + railingHeight / 2 - 0.1, HALL_SIZE - storeDepth - corridorWidth);
            scene.add(railS1);
            const railS2 = new THREE.Mesh(new THREE.BoxGeometry(barandaLong, railingHeight, railThickness), railMat);
            railS2.position.set(HALL_SIZE - storeDepth - corridorWidth - barandaLong / 2, yOffset + railingHeight / 2 - 0.1, HALL_SIZE - storeDepth - corridorWidth);
            scene.add(railS2);
            
            // Oeste - dos tramos separados
            const railO1 = new THREE.Mesh(new THREE.BoxGeometry(railThickness, railingHeight, barandaLong), railMat);
            railO1.position.set(storeDepth + corridorWidth, yOffset + railingHeight / 2 - 0.1, storeDepth + corridorWidth + barandaLong / 2);
            scene.add(railO1);
            const railO2 = new THREE.Mesh(new THREE.BoxGeometry(railThickness, railingHeight, barandaLong), railMat);
            railO2.position.set(storeDepth + corridorWidth, yOffset + railingHeight / 2 - 0.1, HALL_SIZE - storeDepth - corridorWidth - barandaLong / 2);
            scene.add(railO2);
            
            // Este - dos tramos separados
            const railE1 = new THREE.Mesh(new THREE.BoxGeometry(railThickness, railingHeight, barandaLong), railMat);
            railE1.position.set(HALL_SIZE - storeDepth - corridorWidth, yOffset + railingHeight / 2 - 0.1, storeDepth + corridorWidth + barandaLong / 2);
            scene.add(railE1);
            const railE2 = new THREE.Mesh(new THREE.BoxGeometry(railThickness, railingHeight, barandaLong), railMat);
            railE2.position.set(HALL_SIZE - storeDepth - corridorWidth, yOffset + railingHeight / 2 - 0.1, HALL_SIZE - storeDepth - corridorWidth - barandaLong / 2);
            scene.add(railE2);

            // --- Tiendas ---

            // Crear tiendas en sentido horario usando la funci√≥n centralizada
            createClockwiseStores(yOffset, storeDepth, storeWidth, storeSpacing, initialOffset, numStoresPerSide, wallMaterial, linkIndex, getNextShopNumber);
            
            // Crear muros separadores usando la funci√≥n centralizada
            createSeparatorWalls(yOffset, storeDepth, storeWidth, storeSpacing, initialOffset, numStoresPerSide, separatorMaterial);
            
            return linkIndex;
        }

        function createStoreWithParams(position, size, rotationY, linkIdx, depth, wallMaterial, floorY, shopNumber) {
            const storeGroup = new THREE.Group();
            storeGroup.position.copy(position);
            storeGroup.rotation.y = rotationY;
            const wallThickness = 0.2;

            // Determinar el piso actual una sola vez
            const currentFloor = Math.floor(floorY / (HALL_HEIGHT + 1));

            // --- Crear material de pared con el color de la pancarta ---
            const url = storeLinks[linkIdx];
            const domain = new URL(url).hostname.replace('www.', '').split('.')[0];
            const storeColor = new THREE.Color().setHSL((linkIdx * 47) % 360 / 360, 0.6, 0.5); // Mismo color que la pancarta
            const storeWallMaterial = new THREE.MeshStandardMaterial({ 
                color: storeColor,
                roughness: 0.9
            });

            // --- Suelo de la tienda con dos colores ---
            // Crear materiales para cada cara
            const storeFloorMaterialNegro = new THREE.MeshStandardMaterial({ 
                color: 0x000000, // Color negro
                roughness: 0.8
            });
            
            const storeFloorMaterialBlanco = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF, // Color blanco
                roughness: 0.8
            });
            
            // Funci√≥n para crear suelo de tienda con dos colores
            const createStoreFloor = (geometry, position) => {
                const grupo = new THREE.Group();
                
                // Cara superior (negra) - ligeramente m√°s alta
                const caraSuperior = new THREE.Mesh(geometry, storeFloorMaterialNegro);
                caraSuperior.position.set(0, 0.001, 0); // Ligeramente m√°s alta
                grupo.add(caraSuperior);
                
                // Cara inferior (blanca) - ligeramente m√°s baja
                const caraInferior = new THREE.Mesh(geometry, storeFloorMaterialBlanco);
                caraInferior.position.set(0, -0.001, 0); // Ligeramente m√°s baja
                caraInferior.rotation.x = Math.PI; // Rotar 180 grados para que mire hacia abajo
                grupo.add(caraInferior);
                
                grupo.position.copy(position);
                grupo.rotation.x = -Math.PI / 2;
                return grupo;
            };
            
            // Crear suelo de tienda con negro arriba y blanco abajo
            const storeFloor = createStoreFloor(new THREE.PlaneGeometry(size.x, depth), new THREE.Vector3(0, 0, 0));
            
            // Ajustar la posici√≥n del suelo seg√∫n el piso
            if (currentFloor === 1) {
                // Para el segundo piso, subir ligeramente el suelo
                const floorOffset = -0.05 - HALL_HEIGHT / 2; // Reducido de -0.1 a -0.05
                storeFloor.position.set(0, floorOffset, 0);
            } else {
                // Para la planta baja, mantener la posici√≥n original
                storeFloor.position.set(0, -size.y / 2 + 0.05, 0);
            }
            
            // storeFloor.receiveShadow = true;
            // storeFloor.castShadow = false; // Desactivar sombras para mejor rendimiento
            storeGroup.add(storeFloor);

            // --- Paredes (extendidas hasta el siguiente piso) ---
            const extendedHeight = HALL_HEIGHT + 1; // Extender hasta el siguiente piso
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(size.x, extendedHeight, wallThickness), storeWallMaterial);
            backWall.position.z = -depth / 2;
            backWall.position.y = (extendedHeight - size.y) / 2; // Centrar en la nueva altura
            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(depth, extendedHeight, wallThickness), storeWallMaterial);
            leftWall.position.set(-size.x / 2, (extendedHeight - size.y) / 2, 0);
            leftWall.rotation.y = Math.PI / 2;
            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(depth, extendedHeight, wallThickness), storeWallMaterial);
            rightWall.position.set(size.x / 2, (extendedHeight - size.y) / 2, 0);
            rightWall.rotation.y = -Math.PI / 2;
            [backWall, leftWall, rightWall].forEach(wall => {
                // wall.castShadow = false; // Desactivar sombras para mejor rendimiento
                // wall.receiveShadow = true;
                storeGroup.add(wall);
            });

            // --- Techo (para el segundo piso) ---
            if (currentFloor === 1) { // Segundo piso (piso 1, ya que empezamos desde 0)
                const ceilingMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF, // Color blanco
                    roughness: 0.8,
                    side: THREE.DoubleSide
                });
                const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(size.x, depth), ceilingMaterial);
                ceiling.rotation.x = Math.PI / 2;
                ceiling.position.set(0, extendedHeight / 2 + 0.5, 0); // Posicionar m√°s alto que las paredes extendidas
                // ceiling.receiveShadow = true;
                // ceiling.castShadow = false; // Desactivar sombras para mejor rendimiento
                storeGroup.add(ceiling);
            }
            
            // --- Cartel principal ---
            const mainSign = createImagePlane(url, domain, size.x * 0.9, size.y * 0.8, linkIdx, true);
            mainSign.position.z = -depth / 2 + wallThickness + 0.01;
            mainSign.position.y = (extendedHeight - size.y) / 2; // Ajustar posici√≥n vertical
            storeGroup.add(mainSign);

            // --- N√∫mero de tienda ---
            const shopNumberSign = createShopNumberSign(shopNumber, size.x * 0.25, size.y * 0.25);
            shopNumberSign.position.z = -depth / 2 + wallThickness + 0.02;
            shopNumberSign.position.y = (extendedHeight - size.y) / 2 + size.y * 0.4; // Posicionar m√°s abajo
            shopNumberSign.position.x = 0; // Centrar horizontalmente
            storeGroup.add(shopNumberSign);

            // --- Carteles laterales (restaurar ambos carteles) ---
            const sideSignTexts = [ `Ofertas en ${domain}`, `Vis√≠tanos ahora`, `Clic para ganar`, `Novedades aqu√≠`];
            const leftSign = createRotatingSign(url, sideSignTexts, 2.5, size.y * 0.6, linkIdx);
            leftSign.position.set(-size.x / 2 + wallThickness + 0.01, (extendedHeight - size.y) / 2, -2);
            leftSign.rotation.y = Math.PI / 2;

            const rightSign = createRotatingSign(url, sideSignTexts.slice(2).concat(sideSignTexts.slice(0,2)), 2.5, size.y * 0.6, linkIdx + 1);
            rightSign.position.set(size.x / 2 - wallThickness - 0.01, (extendedHeight - size.y) / 2, -2);
            rightSign.rotation.y = -Math.PI / 2;
            
            storeGroup.add(leftSign, rightSign);

            // --- Letreros verticales completos para los pasillos ---
            const createVerticalSign = (text, width, height, colorIdx) => {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const canvasW = 256; // Restaurar tama√±o original
                const canvasH = 512; // M√°s alto para texto vertical
                canvas.width = canvasW;
                canvas.height = canvasH;
                
                // Fondo con el mismo color que el cartel principal
                context.fillStyle = `hsl(${colorIdx * 47 % 360}, 60%, 50%)`;
                context.fillRect(0, 0, canvasW, canvasH);
                context.strokeStyle = '#FFFFFF';
                context.lineWidth = 4; // Restaurar grosor original
                context.strokeRect(2, 2, canvasW - 4, canvasH - 4);
                
                // Texto vertical en blanco
                context.fillStyle = '#FFFFFF';
                context.font = `bold ${canvasW * 0.25}px Arial`; // Restaurar tama√±o de fuente original
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                
                // Dividir el texto en caracteres y dibujarlos verticalmente de arriba hacia abajo
                const chars = text.split('');
                const charHeight = canvasH * 0.12; // M√°s espacio entre letras
                const totalHeight = chars.length * charHeight;
                const startY = canvasH / 2 - totalHeight / 2;
                const centerX = canvasW / 2;
                
                chars.forEach((char, index) => {
                    context.fillText(char, centerX, startY + index * charHeight);
                });
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshStandardMaterial({ 
                    map: texture,
                    transparent: true,
                    alphaTest: 0.1
                });
                
                const plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), material);
                return plane;
            };

            // Crear letreros verticales en los bordes de los pasillos (restaurar ambos)
            const verticalSignWidth = 0.8; // Restaurar tama√±o original
            const verticalSignHeight = extendedHeight; // Restaurar altura original
            
            // Letrero en el extremo izquierdo del muro (hacia el pasillo)
            const leftVerticalSign = createVerticalSign(domain.toUpperCase(), verticalSignWidth, verticalSignHeight, linkIdx);
            leftVerticalSign.position.set(-size.x / 2 + wallThickness + 0.02, (extendedHeight - size.y) / 2, depth / 2 - 1);
            leftVerticalSign.rotation.y = Math.PI / 2;
            storeGroup.add(leftVerticalSign);
            
            // N√∫mero de tienda en el extremo izquierdo del muro
            const leftNumberSign = createShopNumberSign(shopNumber, 0.8, 0.8);
            leftNumberSign.position.set(-size.x / 2 + wallThickness + 0.02, (extendedHeight - size.y) / 2 + 1.5, depth / 2 - 0.2);
            leftNumberSign.rotation.y = Math.PI / 2;
            storeGroup.add(leftNumberSign);
            
            // Letrero en el extremo derecho del muro (hacia el pasillo)
            const rightVerticalSign = createVerticalSign(domain.toUpperCase(), verticalSignWidth, verticalSignHeight, linkIdx);
            rightVerticalSign.position.set(size.x / 2 - wallThickness - 0.02, (extendedHeight - size.y) / 2, depth / 2 - 1);
            rightVerticalSign.rotation.y = -Math.PI / 2;
            storeGroup.add(rightVerticalSign);
            
            // N√∫mero de tienda en el extremo derecho del muro
            const rightNumberSign = createShopNumberSign(shopNumber, 0.8, 0.8);
            rightNumberSign.position.set(size.x / 2 - wallThickness - 0.02, (extendedHeight - size.y) / 2 + 1.5, depth / 2 - 0.2);
            rightNumberSign.rotation.y = -Math.PI / 2;
            storeGroup.add(rightNumberSign);

            scene.add(storeGroup);

            // --- Actualizar colisiones ---
            storeGroup.updateMatrixWorld(true);
            [backWall, leftWall, rightWall].forEach(wall => {
                collisionObjects.push(new THREE.Box3().setFromObject(wall));
            });
        }

        function createCentralCubeScreens(x, y, z, size, links, colorOffset, interval) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            const planes = [];

            const cubeGeom = new THREE.BoxGeometry(size, size * 0.6, size);
            const cubeMat = new THREE.MeshStandardMaterial({ color: 0x222, metalness: 0.3, roughness: 0.7 });
            const cube = new THREE.Mesh(cubeGeom, cubeMat);
            cube.position.y = size * 0.3;
            group.add(cube);
            
            for (let i = 0; i < 4; i++) {
                if (i >= links.length) continue;
                const angle = i * Math.PI / 2;
                const url = links[i];
                const domain = new URL(url).hostname.replace('www.', '').split('.')[0];
                const plane = createImagePlane(url, domain, size, size * 0.6, colorOffset + i, true);
                plane.position.set(Math.sin(angle) * (size / 2 + 0.01), size * 0.3, Math.cos(angle) * (size / 2 + 0.01));
                plane.rotation.y = angle;
                group.add(plane);
                planes.push(plane);
            }
            scene.add(group);
            group.updateMatrixWorld(true);
            collisionObjects.push(new THREE.Box3().setFromObject(cube));

            let offset = 0;
            setInterval(() => {
                planes.forEach((plane, i) => {
                    const linkIdx = (offset + i) % links.length;
                    const url = links[linkIdx];
                    const domain = new URL(url).hostname.replace('www.', '').split('.')[0];
                    plane.userData.URL = url;
                    updateImagePlane(plane, url, domain, colorOffset + linkIdx, true);
                });
                offset = (offset + 1) % links.length;
            }, interval);
        }

        function createImagePlane(url, text, width, height, colorIdx, solid) {
            const plane = new THREE.Mesh(
                new THREE.PlaneGeometry(width, height),
                new THREE.MeshStandardMaterial({ roughness: 0.7, metalness: 0.2, transparent: !solid })
            );
            plane.userData.URL = url;
            updateImagePlane(plane, url, text, colorIdx, solid);
            clickableObjects.push(plane);
            return plane;
        }

        // Cache para texturas de logos
        const logoTextureCache = new Map();
        
        function getLogoTexture(domain) {
            const logoFileName = domainToLogoMap[domain];
            if (!logoFileName) {
                return null;
            }
            
            // Verificar si ya est√° en cache
            if (logoTextureCache.has(domain)) {
                return logoTextureCache.get(domain);
            }
            
            try {
                const textureLoader = new THREE.TextureLoader();
                const texture = textureLoader.load(
                    `assets/images/${logoFileName}`,
                    // onLoad callback
                    function(loadedTexture) {
                        console.log(`Logo cargado exitosamente: ${logoFileName}`);
                    },
                    // onProgress callback
                    function(xhr) {
                        // Silenciar progreso para evitar spam
                    },
                    // onError callback
                    function(error) {
                        console.error(`Error cargando logo ${logoFileName}:`, error);
                        // Remover del cache si falla
                        logoTextureCache.delete(domain);
                    }
                );
                
                // Guardar en cache
                logoTextureCache.set(domain, texture);
                return texture;
            } catch (error) {
                console.error(`Error creando textura para ${domain}:`, error);
                return null;
            }
        }

        function createShopNumberSign(number, width, height) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const canvasW = 256;
            const canvasH = 256;
            canvas.width = canvasW;
            canvas.height = canvasH;
            
            // Fondo circular negro
            context.fillStyle = '#000000';
            context.beginPath();
            context.arc(canvasW / 2, canvasH / 2, canvasW / 2 - 10, 0, 2 * Math.PI);
            context.fill();
            
            // Borde blanco
            context.strokeStyle = '#FFFFFF';
            context.lineWidth = 8;
            context.stroke();
            
            // N√∫mero en blanco
            context.fillStyle = '#FFFFFF';
            context.font = `bold ${canvasH * 0.6}px Arial`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(number.toString(), canvasW / 2, canvasH / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshStandardMaterial({ 
                map: texture,
                transparent: true,
                alphaTest: 0.1
            });
            
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), material);
            return plane;
        }

        function updateImagePlane(plane, url, text, colorIdx) {
            try {
                let domain = new URL(url).hostname.replace('www.', '');
                // Extraer el dominio principal (sin subdominios)
                const domainParts = domain.split('.');
                if (domainParts.length > 2) {
                    domain = domainParts[1];
                } else {
                    domain = domainParts[0];
                }
                
                const logoTexture = getLogoTexture(domain);
                
                if (plane.material.map) {
                    plane.material.map.dispose();
                }
                
                if (logoTexture) {
                    plane.material.map = logoTexture;
                } else {
                    // Fallback a la textura generada si no hay logo
                    const texture = getCachedTexture(text, colorIdx, plane.geometry.parameters.width, plane.geometry.parameters.height);
            plane.material.map = texture;
                }
                
            plane.material.needsUpdate = true;
            } catch (error) {
                console.error('Error en updateImagePlane:', error);
                // Fallback seguro
                if (plane.material.map) {
                    plane.material.map.dispose();
                }
                const texture = getCachedTexture(text, colorIdx, plane.geometry.parameters.width, plane.geometry.parameters.height);
                plane.material.map = texture;
                plane.material.needsUpdate = true;
            }
        }

        function createRotatingSign(url, texts, width, height, colorIdx) {
            const plane = createImagePlane(url, texts[0], width, height, colorIdx, false);
            plane.material.transparent = true;
            let textIndex = 0;
            setInterval(() => {
                textIndex = (textIndex + 1) % texts.length;
                updateRotatingSign(plane.material, texts[textIndex]);
            }, 2500);
            return plane;
        }

        function updateRotatingSign(material, text) {
            // Create a new canvas if material.map doesn't exist or if it's not a canvas
            let canvas = material.map ? material.map.image : null;
            if (!canvas || !canvas.getContext) {
                canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 128;
            }
            
            const context = canvas.getContext('2d');
            const canvasW = canvas.width;
            const canvasH = canvas.height;
            
            context.fillStyle = '#fff';
            context.fillRect(0, 0, canvasW, canvasH);
            context.strokeStyle = '#000';
            context.lineWidth = 8;
            context.strokeRect(4, 4, canvasW-8, canvasH-8);

            let fontSize = canvasH * 0.3;
            context.font = `bold ${fontSize}px Arial`;
            context.fillStyle = '#000';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            while(context.measureText(text).width > canvasW - 20 && fontSize > 10) {
                fontSize -= 2;
                context.font = `bold ${fontSize}px Arial`;
            }
            context.fillText(text, canvasW/2, canvasH/2);
            
            // Create or update the texture
            if (!material.map) {
                material.map = new THREE.CanvasTexture(canvas);
            } else {
                material.map.needsUpdate = true;
            }
        }
        
        function createDigitalClockCube(x, y, z, size) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            const planes = [];

            const cubeGeom = new THREE.BoxGeometry(size, size * 0.6, size);
            const cubeMat = new THREE.MeshStandardMaterial({ color: 0x111, metalness: 0.3, roughness: 0.7 });
            const cube = new THREE.Mesh(cubeGeom, cubeMat);
            cube.position.y = size * 0.3;
            group.add(cube);

            for (let i = 0; i < 4; i++) {
                const angle = i * Math.PI / 2;
                const plane = createClockPlane(size, size * 0.6);
                plane.position.set(Math.sin(angle) * (size / 2 + 0.01), size * 0.3, Math.cos(angle) * (size / 2 + 0.01));
                plane.rotation.y = angle;
                group.add(plane);
                planes.push(plane);
            }
            scene.add(group);
            group.updateMatrixWorld(true);
            collisionObjects.push(new THREE.Box3().setFromObject(cube));

            setInterval(() => {
                planes.forEach(plane => updateClockPlane(plane.material));
            }, 1000);
        }

        function createClockPlane(width, height) {
            const material = new THREE.MeshStandardMaterial({ roughness: 0.7, metalness: 0.2 });
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), material);
            updateClockPlane(material);
            return plane;
        }

        function updateClockPlane(material) {
            const canvas = material.map ? material.map.image : document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 800;
            canvas.height = 400;
            
            context.fillStyle = '#111';
            context.fillRect(0, 0, 800, 400);
            
            const now = new Date();
            const timeStr = now.toLocaleTimeString('es-ES', { hour12: false });
            context.font = 'bold 160px monospace';
            context.fillStyle = '#0ff';
            context.shadowColor = '#0ff';
            context.shadowBlur = 32;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(timeStr, 400, 200);

            if (!material.map) {
                material.map = new THREE.CanvasTexture(canvas);
            } else {
                material.map.needsUpdate = true;
            }
        }

        // --- Manejadores de Eventos ---
        function setupEventListeners() {
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousedown', onMouseDown);
        }
        
        function setupUIButtons() {
            console.log('Configurando botones de UI...');
            
            // Verificar que el bot√≥n se encontr√≥ correctamente
            if (changeAliasBtn) {
                console.log('Bot√≥n de personalizaci√≥n encontrado');
                changeAliasBtn.onclick = () => {
                    console.log('Bot√≥n de personalizaci√≥n clickeado');
                    // Mostrar el panel de personalizaci√≥n completo
                    openCustomizationPanel();
                };
            } else {
                console.error('No se encontr√≥ el bot√≥n de personalizaci√≥n');
            }
            
            if (saveCustomizationBtn) {
                console.log('Bot√≥n de guardar personalizaci√≥n encontrado');
                saveCustomizationBtn.onclick = saveCustomization;
            } else {
                console.error('No se encontr√≥ el bot√≥n de guardar personalizaci√≥n');
            }
            
            if (resetCustomizationBtn) {
                console.log('Bot√≥n de resetear personalizaci√≥n encontrado');
                resetCustomizationBtn.onclick = resetCustomization;
            } else {
                console.error('No se encontr√≥ el bot√≥n de resetear personalizaci√≥n');
            }
        }

        function onKeyDown(event) {
            // Si el chat est√° abierto, no procesar controles del juego
            if (chatOpen) {
                return;
            }
            
            const key = event.code.replace('Key', '');
            if (key in keys) keys[key] = true;
            if (event.code === 'ArrowUp') keys.W = true;
            if (event.code === 'ArrowDown') keys.S = true;
            if (event.code === 'ArrowLeft') keys.A = true;
            if (event.code === 'ArrowRight') keys.D = true;
            
            if (event.code === 'KeyW' && !keyW) { // W para subir de piso (solo una vez)
                if (currentFloor < MAX_FLOOR) currentFloor++;
                keyW = true;
            }
            if (event.code === 'KeyS' && !keyS) { // S para bajar de piso (solo una vez)
                if (currentFloor > MIN_FLOOR) currentFloor--;
                keyS = true;
            }
            if (event.code === 'KeyA') { // A para moverse hacia la izquierda
                keyA = true;
            }
            if (event.code === 'KeyD') { // D para moverse hacia la derecha
                keyD = true;
            }
        }

        function onKeyUp(event) {
            const key = event.code.replace('Key', '');
            if (key in keys) keys[key] = false;
            if (event.code === 'ArrowUp') keys.W = false;
            if (event.code === 'ArrowDown') keys.S = false;
            if (event.code === 'ArrowLeft') keys.A = false;
            if (event.code === 'ArrowRight') keys.D = false;
            if (event.code === 'KeyA') keyA = false;
            if (event.code === 'KeyD') keyD = false;
            if (event.code === 'KeyW') keyW = false;
            if (event.code === 'KeyS') keyS = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onMouseDown(event) {
            // Si el overlay est√° activo, no procesar ning√∫n clic del juego
            const overlay = document.getElementById('ui-overlay');
            if (overlay && overlay.style.display === 'block' && overlay.style.pointerEvents === 'auto') {
                return;
            }
            // Si el chat est√° abierto, no procesar controles del juego
            if (chatOpen) {
                return;
            }
            // Si el panel de personalizaci√≥n est√° abierto, no procesar clics del juego
            const simplePanel = document.getElementById('simple-panel');
            if (simplePanel && simplePanel.style.display === 'block') {
                return;
            }
            
            if (event.button !== 0) return; // Solo clic izquierdo
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(clickableObjects);
            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                
                // Verificar si es un clic en el nombre del avatar para personalizaci√≥n
                if (clickedObject.userData && clickedObject.userData.type === 'customization') {
                    openCustomizationPanel();
                    return;
                }
                
                // Verificar si es un clic en una tienda
                if (clickedObject.userData.URL) {
                    window.open(clickedObject.userData.URL, '_blank');
                }
            }
        }

        function updateMovement() {
            // Si el chat est√° abierto, no actualizar movimiento
            if (chatOpen) {
                return;
            }
            
            // --- Rotaci√≥n con flechas izquierda/derecha usando Quaternion ---
            const currentRotation = new THREE.Quaternion();
            camera.getWorldQuaternion(currentRotation);
            
            // Crear un quaternion de rotaci√≥n alrededor del eje Y
            const rotationSpeed = ROTATE_SPEED * 0.1; // Ajustar la velocidad para Quaternion
            const deltaRotation = new THREE.Quaternion();
            if (keys.ArrowLeft) {
                deltaRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), -rotationSpeed);
            } else if (keys.ArrowRight) {
                deltaRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotationSpeed);
            }
            
            // Interpolar entre la rotaci√≥n actual y la nueva
            const targetRotation = new THREE.Quaternion();
            targetRotation.copy(currentRotation);
            targetRotation.multiply(deltaRotation);
            
            // Aplicar la rotaci√≥n suavemente
            const lerpFactor = 0.1; // Factor de suavizado
            currentRotation.slerp(targetRotation, lerpFactor);
            camera.quaternion.copy(currentRotation);

            // --- Movimiento hacia adelante/atr√°s con flechas ---
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();
            
            const velocity = new THREE.Vector3();
            
            // Movimiento hacia adelante/atr√°s con flechas arriba/abajo
            if (keys.ArrowUp) velocity.add(direction);
            if (keys.ArrowDown) velocity.sub(direction);
            
            // Movimiento lateral con A y D (teclas)
            const rightDirection = new THREE.Vector3();
            rightDirection.setFromMatrixColumn(camera.matrix, 0);
            rightDirection.y = 0;
            rightDirection.normalize();
            
            if (keyA) velocity.sub(rightDirection); // Moverse hacia la izquierda
            if (keyD) velocity.add(rightDirection); // Moverse hacia la derecha
            
            if (velocity.length() > 0) {
                velocity.normalize().multiplyScalar(MOVE_SPEED);
                const newPosition = targetPosition.clone().add(velocity);
                
                // --- Colisiones optimizadas ---
                const playerBox = new THREE.Box3().setFromCenterAndSize(newPosition, new THREE.Vector3(1.0, CAMERA_HEIGHT, 1.0));
                let collision = false;
                
                // Optimizaci√≥n: solo verificar colisiones cercanas
                const nearbyCollisions = collisionObjects.filter(wallBox => {
                    const distance = wallBox.getCenter(new THREE.Vector3()).distanceTo(newPosition);
                    return distance < 20; // Solo verificar objetos dentro de 20 unidades
                });
                
                for (const wallBox of nearbyCollisions) {
                    if (playerBox.intersectsBox(wallBox)) {
                        collision = true;
                        break;
                    }
                }
                
                if (!collision) {
                    targetPosition.copy(newPosition);
                }
            }

            // --- Cambio de Piso ---
            const floorStep = HALL_HEIGHT + 1;
            const targetY = currentFloor * floorStep + CAMERA_HEIGHT;
            targetPosition.y = targetY;

            // --- Interpolaci√≥n para suavidad ---
            camera.position.lerp(targetPosition, 0.2);
        }

        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            // Control de FPS
            const deltaTime = currentTime - lastTime;
            if (deltaTime < frameInterval) {
                return;
            }
            
            lastTime = currentTime - (deltaTime % frameInterval);
            frameCount++;
            
            // Actualizar el color del cielo cada minuto (60000 ms)
            if (currentTime - lastSkyUpdate > 60000) {
                scene.background = getSkyColor();
                lastSkyUpdate = currentTime;
            }
            
            updateMovement();
            updateAvatarPositions(); // Actualizar posiciones de avatares
            
            // Enviar posici√≥n del usuario cada 100ms (10 veces por segundo)
            if (frameCount % 6 === 0) { // 60 FPS / 6 = 10 veces por segundo
                sendUserPosition();
            }
            
            renderer.render(scene, camera);
        }
        
        // Funci√≥n para limpiar recursos
        function cleanup() {
            // Limpiar cache de texturas
            logoTextureCache.forEach(texture => {
                if (texture && texture.dispose) {
                    texture.dispose();
                }
            });
            logoTextureCache.clear();
            
            // Limpiar cache de materiales
            materialCache.forEach(material => {
                if (material && material.dispose) {
                    material.dispose();
                }
            });
            materialCache.clear();
            
            // Limpiar cache de texturas generadas
            textureCache.forEach(texture => {
                if (texture && texture.dispose) {
                    texture.dispose();
                }
            });
            textureCache.clear();
        // Limpiar al cerrar la p√°gina
        window.addEventListener('beforeunload', cleanup);

        // --- Chat UI Logic ---
        const chatToggleBtn = document.getElementById('chat-toggle-btn');
        const chatPanel = document.getElementById('chat-panel');
        const chatCloseBtn = document.getElementById('chat-close-btn');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');
        const emojiToggle = document.getElementById('emoji-toggle');
        const emojiPanel = document.getElementById('emoji-panel');
        const usersList = document.getElementById('users-list');
        const changeAliasBtn = document.getElementById('change-alias-btn');
        let userAlias = localStorage.getItem('userAlias') || '';
        let chatOpen = false;
        let connectedUsers = [];
        
        chatToggleBtn.onclick = () => {
            const simplePanel = document.getElementById('simple-panel');
            if (simplePanel && simplePanel.style.display === 'block') {
                closeSimplePanel();
            }
            chatPanel.style.display = 'flex';
            chatOpen = true;
            chatInput.focus();
            // El overlay NO debe mostrarse al abrir el chat
        };
        chatCloseBtn.onclick = () => {
            chatPanel.style.display = 'none';
            chatOpen = false;
            // El overlay NO debe ocultarse al cerrar el chat
        };

        // --- Emojis ---
        const emojis = ['üòä', 'üòÇ', '‚ù§Ô∏è', 'üëç', 'üéâ', 'üî•', 'üòé', 'ü§î', 'üò¢', 'üò°', 'üëã', 'üí™', 'üéØ', '‚≠ê', 'üíØ', 'üöÄ', 'üíé', 'üéÆ', 'üçï', '‚òï', 'üåÆ', 'üç∫', 'üéµ', 'üé¨', '‚öΩ', 'üèÄ', 'üéæ', 'üèà', '‚ö°', 'üåà', 'üåô', '‚òÄÔ∏è'];
        function createEmojiPanel() {
            emojiPanel.innerHTML = '';
            emojis.forEach(emoji => {
                const btn = document.createElement('button');
                btn.className = 'emoji-btn';
                btn.textContent = emoji;
                btn.onclick = () => {
                    chatInput.value += emoji;
                    chatInput.focus();
                    emojiPanel.style.display = 'none';
                };
                emojiPanel.appendChild(btn);
            });
        }
        emojiToggle.onclick = () => {
            if (emojiPanel.style.display === 'none' || !emojiPanel.style.display) {
                emojiPanel.style.display = 'flex';
                createEmojiPanel();
            } else {
                emojiPanel.style.display = 'none';
            }
        };

        document.addEventListener('click', (e) => {
            if (!emojiPanel.contains(e.target) && !emojiToggle.contains(e.target)) {
                emojiPanel.style.display = 'none';
            }
        });

        // --- Firebase Chat Logic ---
        function handleSendMessage() {
            const message = chatInput.value.trim();
            if (message.length > 0 && userAlias) {
                if (privateRecipient) {
                    sendPrivateMessage(privateRecipient, message);
                } else {
                    sendMessage(message);
                }
                chatInput.value = '';
            }
        }
        chatSendBtn.onclick = handleSendMessage;
        chatInput.addEventListener('keydown', e => {
            if (e.key === 'Enter') {
                handleSendMessage();
            }
        });

        // Alias setup and connect to chat
        if (!userAlias) {
            userAlias = 'Usuario_' + Math.floor(Math.random() * 10000);
            localStorage.setItem('userAlias', userAlias);
        }
        if (userAlias) {
            changeAliasBtn.style.display = 'flex';
        }
        connectToChat(userAlias); // Provided by firebase-config.js

        // Estado de personalizaci√≥n
        const currentCustomization = {
            shirtColor: 0x4ECDC4,
            pantsColor: 0x2C3E50,
            shoesColor: 0x8B4513,
            alias: 'Usuario'
        };

        // Paletas de colores
        const shirtColors = [
            { color: 0x96CEB4, name: 'Verde Claro' },
            { color: 0xFFEAA7, name: 'Amarillo' },
            { color: 0xDDA0DD, name: 'Lila' },
            { color: 0xFF5733, name: 'Naranja' },
            { color: 0x8E4585, name: 'Morado' },
            { color: 0x3498DB, name: 'Azul' },
            { color: 0x2ECC71, name: 'Verde' },
            { color: 0xF1C40F, name: 'Dorado' },
            { color: 0xE74C3C, name: 'Rojo' },
            { color: 0x95A5A6, name: 'Gris' },
            { color: 0x1ABC9C, name: 'Turquesa Oscuro' },
            { color: 0x34495E, name: 'Azul Oscuro' }
        ];

        const pantsColors = [
            { color: 0x2C3E50, name: 'Azul Oscuro' },
            { color: 0x2E4053, name: 'Azul Marino' },
            { color: 0x2B2B2B, name: 'Negro' },
            { color: 0x3498DB, name: 'Azul' },
            { color: 0x1ABC9C, name: 'Verde Azulado' },
            { color: 0x95A5A6, name: 'Gris' },
            { color: 0x7F8C8D, name: 'Gris Azulado' },
            { color: 0x34495E, name: 'Azul Gris√°ceo' },
            { color: 0x273746, name: 'Azul Oscuro' },
            { color: 0x1A237E, name: 'Azul Profundo' },
            { color: 0x0D47A1, name: 'Azul Real' },
            { color: 0x01579B, name: 'Azul Marino' },
            { color: 0x004D40, name: 'Verde Marino' },
            { color: 0x006064, name: 'Azul Verde' },
            { color: 0x004D40, name: 'Verde Oscuro' }
        ];

        const shoesColors = [
            { color: 0x8B4513, name: 'Marr√≥n' },
            { color: 0x5B2C2F, name: 'Marr√≥n Oscuro' },
            { color: 0x331C14, name: 'Marr√≥n Profundo' },
            { color: 0x2C3E50, name: 'Azul Oscuro' },
            { color: 0x2B2B2B, name: 'Negro' },
            { color: 0x3498DB, name: 'Azul' },
            { color: 0x1ABC9C, name: 'Verde Azulado' },
            { color: 0x95A5A6, name: 'Gris' },
            { color: 0x7F8C8D, name: 'Gris Azulado' },
            { color: 0x34495E, name: 'Azul Gris√°ceo' },
            { color: 0x273746, name: 'Azul Oscuro' },
            { color: 0x1A237E, name: 'Azul Profundo' },
            { color: 0x0D47A1, name: 'Azul Real' },
            { color: 0x01579B, name: 'Azul Marino' },
            { color: 0x004D40, name: 'Verde Marino' },
            { color: 0x006064, name: 'Azul Verde' },
            { color: 0x004D40, name: 'Verde Oscuro' }
        ];

        // Crear botones para cada color
        function createColorButton(color, name, type) {
            const button = document.createElement('button');
            button.className = 'color-option';
            button.style.backgroundColor = '#' + color.toString(16).padStart(6, '0');
            button.style.borderColor = 'transparent';
            button.style.cursor = 'pointer';
            button.style.transition = 'all 0.2s';
            button.title = name;
            button.dataset.color = color;
            button.onclick = () => {
                // Actualizar el color correspondiente
                switch (type) {
                    case 'shirt':
                        currentCustomization.shirtColor = color;
                        break;
                    case 'pants':
                        currentCustomization.pantsColor = color;
                        break;
                    case 'shoes':
                        currentCustomization.shoesColor = color;
                        break;
                }
                updateAvatarPreview();
            };
            return button;
        }

        // Agregar botones a cada grid
        shirtColors.forEach(color => {
            const button = createColorButton(color.color, color.name, 'shirt');
            document.getElementById('shirt-colors').appendChild(button);
        });

        pantsColors.forEach(color => {
            const button = createColorButton(color.color, color.name, 'pants');
            document.getElementById('pants-colors').appendChild(button);
        });

        shoesColors.forEach(color => {
            const button = createColorButton(color.color, color.name, 'shoes');
            document.getElementById('shoes-colors').appendChild(button);
        });

        // Funciones de personalizaci√≥n
        function updateAvatarPreview() {
            const previewDiv = document.getElementById('avatar-preview');
            const aliasInput = document.getElementById('simple-alias-input');
            if (!previewDiv) return;
            
            // Actualizar el alias en la vista previa
            const currentAlias = aliasInput ? aliasInput.value.trim() : currentCustomization.alias;
            const shirtColorHex = currentCustomization.shirtColor.toString(16).padStart(6, '0');
            const pantsColorHex = currentCustomization.pantsColor.toString(16).padStart(6, '0');
            const shoesColorHex = currentCustomization.shoesColor.toString(16).padStart(6, '0');
            
            previewDiv.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; gap: 0; position: relative; width: 90px; height: 180px;">
                    <!-- Cabeza -->
                    <div style="width: 40px; height: 40px; background: #FFE4C4; border: 2px solid #333; position: relative; margin-bottom: 0;">
                        <!-- Ojos -->
                        <div style="position: absolute; top: 12px; left: 10px; width: 6px; height: 6px; background: #222; border-radius: 1px;"></div>
                        <div style="position: absolute; top: 12px; right: 10px; width: 6px; height: 6px; background: #222; border-radius: 1px;"></div>
                        <!-- Boca -->
                        <div style="position: absolute; bottom: 10px; left: 12px; width: 16px; height: 4px; background: #222; border-radius: 1px;"></div>
                    </div>
                    <!-- Torso y brazos -->
                    <div style="display: flex; flex-direction: row; align-items: flex-start; height: 50px;">
                        <div style="width: 16px; height: 50px; background: #${shirtColorHex}; border: 2px solid #333; margin-right: 0;"></div>
                        <div style="width: 28px; height: 50px; background: #${shirtColorHex}; border: 2px solid #333; margin: 0 0;"></div>
                        <div style="width: 16px; height: 50px; background: #${shirtColorHex}; border: 2px solid #333; margin-left: 0;"></div>
                    </div>
                    <!-- Piernas -->
                    <div style="display: flex; flex-direction: row; align-items: flex-start; height: 50px; margin-top: 0;">
                        <div style="width: 16px; height: 50px; background: #${pantsColorHex}; border: 2px solid #333; margin-right: 4px;"></div>
                        <div style="width: 16px; height: 50px; background: #${pantsColorHex}; border: 2px solid #333; margin-left: 4px;"></div>
                    </div>
                    <!-- Zapatos -->
                    <div style="display: flex; flex-direction: row; align-items: flex-start; height: 12px; margin-top: -2px;">
                        <div style="width: 16px; height: 12px; background: #${shoesColorHex}; border: 2px solid #333; margin-right: 4px;"></div>
                        <div style="width: 16px; height: 12px; background: #${shoesColorHex}; border: 2px solid #333; margin-left: 4px;"></div>
                    </div>
                    <!-- Nombre -->
                    <div style="color: #FFD700; font-size: 12px; font-weight: bold; text-align: center; margin-top: 8px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); width: 100%;">${currentAlias || 'Sin nombre'}</div>
                </div>
            `;
            

        }

        function saveCustomization() {
            const aliasInput = document.getElementById('simple-alias-input');
            const newAlias = aliasInput ? aliasInput.value.trim() : '';
            
            // Validar alias
            if (newAlias.length > 20) {
                alert('El nombre no puede tener m√°s de 20 caracteres');
                return;
            }
            
            // Guardar alias
            currentCustomization.alias = newAlias;
            
            // Guardar en localStorage
            const customizationData = {
                ...currentCustomization
            };
            
            localStorage.setItem('avatarCustomization', JSON.stringify(customizationData));
            
            // Limpiar selecci√≥n de botones
            document.querySelectorAll('.color-option').forEach(btn => {
                btn.style.borderColor = 'transparent';
                btn.style.transform = 'scale(1)';
                btn.style.boxShadow = 'none';
            });
            
            console.log('‚úÖ Personalizaci√≥n guardada:', customizationData);
            updateAvatarPreview();
            
            // Actualizar el avatar 3D si existe
            const myAvatar = userAvatars.get(userAlias);
            if (myAvatar) {
                if (myAvatar.bodyMaterial) {
                    myAvatar.bodyMaterial.color.setHex(currentCustomization.shirtColor);
                    myAvatar.bodyMaterial.needsUpdate = true;
                }
                if (myAvatar.pantsMaterial) {
                    myAvatar.pantsMaterial.color.setHex(currentCustomization.pantsColor);
                    myAvatar.pantsMaterial.needsUpdate = true;
                }
                if (myAvatar.shoeMaterial) {
                    myAvatar.shoeMaterial.color.setHex(currentCustomization.shoesColor);
                    myAvatar.shoeMaterial.needsUpdate = true;
                }
            }
            
            closeCustomizationPanel();
            
            // Enviar alias al servidor si est√° conectado
            if (isConnected) {
                sendAlias();
            }
        }

        function resetSimpleCustomization() {
            // Restablecer valores por defecto
            Object.assign(currentCustomization, {
                shirtColor: 0x4ECDC4,
                pantsColor: 0x2C3E50,
                shoesColor: 0x8B4513,
                alias: 'Usuario'
            });
            
            // Limpiar selecci√≥n de botones
            document.querySelectorAll('.color-option').forEach(btn => {
                btn.style.borderColor = 'transparent';
                btn.style.transform = 'scale(1)';
                btn.style.boxShadow = 'none';
            });
            
            console.log('‚úÖ Personalizaci√≥n restablecida');
            updateAvatarPreview();
        }

        function loadSimpleCustomization() {
            const savedData = localStorage.getItem('avatarCustomization');
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    Object.assign(currentCustomization, {
                        shirtColor: data.shirtColor || 0x4ECDC4,
                        pantsColor: data.pantsColor || 0x2C3E50,
                        shoesColor: data.shoesColor || 0x8B4513,
                        alias: data.alias || 'Usuario'
                    });
                    console.log('‚úÖ Personalizaci√≥n cargada:', data);
                    updateAvatarPreview();
                } catch (e) {
                    console.error('Error al cargar la personalizaci√≥n:', e);
                    resetSimpleCustomization();
                }
            } else {
                resetSimpleCustomization();
            }
        }

        // Inicializar la personalizaci√≥n al cargar la p√°gina
        document.addEventListener('DOMContentLoaded', () => {
            loadCustomization();
            
            // Event listener para el input de alias
            const aliasInput = document.getElementById('simple-alias-input');
            if (aliasInput) {
                aliasInput.addEventListener('input', updateAvatarPreview);
            }
        });



        // Funciones de panel
        function openCustomizationPanel() {
            console.log('Abriendo panel de personalizaci√≥n');
            
            // Cerrar chat si est√° abierto
            if (chatOpen) {
                chatPanel.style.display = 'none';
                chatOpen = false;
            }
            
            const panel = document.getElementById('simple-panel');
            if (panel) {
                // Actualizar el alias actual
                const currentAliasElement = document.getElementById('current-alias');
                if (currentAliasElement) {
                    currentAliasElement.textContent = currentCustomization.alias || 'Sin alias';
                }
                
                // Poblar el input con el alias actual
                const aliasInput = document.getElementById('simple-alias-input');
                if (aliasInput) {
                    aliasInput.value = currentCustomization.alias || '';
                }
                
                // Mostrar el panel
                panel.style.display = 'block';
                customizationPanelOpen = true;
                
                // Inicializar vista previa del avatar
                updateAvatarPreview();
                
                // Mostrar overlay y bloquear clics
                const overlay = document.getElementById('ui-overlay');
                if (overlay) {
                    overlay.style.display = 'block';
                    overlay.style.pointerEvents = 'auto';
                    overlay.style.zIndex = '20000';
                }
                
                // Asegurar que el panel est√© por encima
                panel.style.zIndex = '21000';
                panel.style.pointerEvents = 'auto';
                
                console.log('‚úÖ Panel mostrado');
            } else {
                console.log('‚ùå Panel no encontrado');
            }
        }

        function closeCustomizationPanel() {
            const panel = document.getElementById('simple-panel');
            if (panel) {
                panel.style.display = 'none';
                customizationPanelOpen = false;
                
                // Ocultar overlay y permitir clics
                const overlay = document.getElementById('ui-overlay');
                if (overlay) {
                    overlay.style.display = 'none';
                    overlay.style.pointerEvents = 'none';
                }
                
                console.log('Panel cerrado');
            }
        }

        if (!previewDiv) return;
        
        // Actualizar el alias en la vista previa
        const currentAlias = aliasInput ? aliasInput.value.trim() : currentCustomization.alias;
        const shirtColorHex = currentCustomization.shirtColor.toString(16).padStart(6, '0');
        const pantsColorHex = currentCustomization.pantsColor.toString(16).padStart(6, '0');
        const shoesColorHex = currentCustomization.shoesColor.toString(16).padStart(6, '0');
        
        previewDiv.innerHTML = `
            <div style="display: flex; flex-direction: column; align-items: center; gap: 0; position: relative; width: 90px; height: 180px;">
                <!-- Cabeza -->
                <div style="width: 40px; height: 40px; background: #FFE4C4; border: 2px solid #333; position: relative; margin-bottom: 0;">
                    <!-- Ojos -->
                    <div style="position: absolute; top: 12px; left: 10px; width: 6px; height: 6px; background: #222; border-radius: 1px;"></div>
                    <div style="position: absolute; top: 12px; right: 10px; width: 6px; height: 6px; background: #222; border-radius: 1px;"></div>
                    <!-- Boca -->
                    <div style="position: absolute; bottom: 10px; left: 12px; width: 16px; height: 4px; background: #222; border-radius: 1px;"></div>
                </div>
                <!-- Torso y brazos -->
                <div style="display: flex; flex-direction: row; align-items: flex-start; height: 50px;">
                    <div style="width: 16px; height: 50px; background: #${shirtColorHex}; border: 2px solid #333; margin-right: 0;"></div>
                    <div style="width: 28px; height: 50px; background: #${shirtColorHex}; border: 2px solid #333; margin: 0 0;"></div>
                    <div style="width: 16px; height: 50px; background: #${shirtColorHex}; border: 2px solid #333; margin-left: 0;"></div>
                </div>
                <!-- Piernas -->
                <div style="display: flex; flex-direction: row; align-items: flex-start; height: 50px; margin-top: 0;">
                    <div style="width: 16px; height: 50px; background: #${pantsColorHex}; border: 2px solid #333; margin-right: 4px;"></div>
                    <div style="width: 16px; height: 50px; background: #${pantsColorHex}; border: 2px solid #333; margin-left: 4px;"></div>
                </div>
                <!-- Zapatos -->
                <div style="display: flex; flex-direction: row; align-items: flex-start; height: 12px; margin-top: -2px;">
                    <div style="width: 16px; height: 12px; background: #${shoesColorHex}; border: 2px solid #333; margin-right: 4px;"></div>
                    <div style="width: 16px; height: 12px; background: #${shoesColorHex}; border: 2px solid #333; margin-left: 4px;"></div>
                </div>
                <!-- Nombre -->
                <div style="color: #FFD700; font-size: 12px; font-weight: bold; text-align: center; margin-top: 8px; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); width: 100%;">${currentAlias || 'Sin nombre'}</div>
            </div>
        `;
        
        // Actualizar avatar 3D si existe
        if (avatar) {
            if (avatar.bodyMaterial) {
                avatar.bodyMaterial.color.setHex(currentCustomization.shirtColor);
                avatar.bodyMaterial.needsUpdate = true;
            avatar.bodyMaterial.needsUpdate = true;
            // Agregar botones a cada grid
            shirtColors.forEach(color => {
                const button = createColorButton(color.color, color.name, 'shirt');
                shirtColorsGrid.appendChild(button);
            });

            pantsColors.forEach(color => {
                const button = createColorButton(color.color, color.name, 'pants');
                pantsColorsGrid.appendChild(button);
            });

            shoesColors.forEach(color => {
                const button = createColorButton(color.color, color.name, 'shoes');
                shoesColorsGrid.appendChild(button);
            });
        }

        // Inicializar el sistema de personalizaci√≥n al cargar
        document.addEventListener('DOMContentLoaded', () => {
            // Inicializar el sistema de personalizaci√≥n simple
            const aliasInput = document.getElementById('simple-alias-input');
            if (aliasInput) {
                aliasInput.addEventListener('input', function() {
                    updateAvatarPreview();
                });
            }
        });

        // Funci√≥n centralizada para manejar cambios de color
        function selectColor(color, type) {
            console.log(`Cambiando color de ${type} a:`, color);
            
            // Actualizar la variable global correspondiente
            switch(type) {
                case 'shirt':
                    shirtColor = color;
                    currentCustomization.shirtColor = color;
                    break;
                case 'pants':
                    pantsColor = color;
                    currentCustomization.pantsColor = color;
                    break;
                case 'shoes':
                    shoesColor = color;
                    currentCustomization.shoesColor = color;
                    break;
            }
            
            // Actualizar avatar
            applyCustomizationToAvatar();
            
            // Actualizar vista previa
            updateAvatarPreview();
            
            // Feedback visual en los botones
            updateColorButtonSelection(type, color);
        }

        function updateColorButtonSelection(type, selectedColor) {
            // Remover selecci√≥n anterior
            const colorOptions = document.querySelectorAll('.color-option');
            colorOptions.forEach(btn => {
                btn.style.borderColor = 'transparent';
                btn.style.transform = 'scale(1)';
                btn.style.boxShadow = 'none';
            });
            
            // Marcar el bot√≥n seleccionado
            const selectedBtn = document.querySelector(`[data-color="${selectedColor}"][data-type="${type}"]`);
            if (selectedBtn) {
                selectedBtn.style.borderColor = '#FFD700';
                selectedBtn.style.transform = 'scale(1.1)';
                selectedBtn.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.5)';
            }
        }

        function updateSelectedColors() {
            // Actualizar selecci√≥n de botones seg√∫n los colores actuales
            updateColorButtonSelection('shirt', shirtColor);
            updateColorButtonSelection('pants', pantsColor);
            updateColorButtonSelection('shoes', shoesColor);
        }

        function applyCustomizationToAvatar() {
            // Aplicar la personalizaci√≥n actual al avatar
            const avatar = userAvatars.get(userAlias);
            if (avatar) {
                if (avatar.bodyMaterial) {
                    avatar.bodyMaterial.color.setHex(shirtColor);
                    avatar.bodyMaterial.needsUpdate = true;
                }
                if (avatar.pantsMaterial) {
                    avatar.pantsMaterial.color.setHex(pantsColor);
                    avatar.pantsMaterial.needsUpdate = true;
                }
                if (avatar.shoeMaterial) {
                    avatar.shoeMaterial.color.setHex(shoesColor);
                    avatar.shoeMaterial.needsUpdate = true;
                }
            }
        }

        function saveCustomization() {
            // Guardar la personalizaci√≥n actual
            const customizationData = {
                alias: userAlias,
                shirtColor: shirtColor,
                pantsColor: pantsColor,
                shoesColor: shoesColor
            };
            
            localStorage.setItem('avatarCustomization', JSON.stringify(customizationData));
            console.log('Personalizaci√≥n guardada:', customizationData);
        }

        function resetCustomization() {
            // Restablecer a valores por defecto
            shirtColor = 0xFF6B6B;
            pantsColor = 0x2C3E50;
            shoesColor = 0x8B4513;
            
            // Actualizar avatar
            applyCustomizationToAvatar();
            
            // Actualizar vista previa
            updateAvatarPreview();
            
            // Actualizar selecci√≥n de botones
            updateSelectedColors();
        }

        function loadCustomization() {
            // Cargar personalizaci√≥n guardada
            const savedData = localStorage.getItem('avatarCustomization');
            if (savedData) {
                const data = JSON.parse(savedData);
                userAlias = data.alias;
                shirtColor = data.shirtColor;
                pantsColor = data.pantsColor;
                shoesColor = data.shoesColor;
                
                // Actualizar avatar
                applyCustomizationToAvatar();
                
                // Actualizar vista previa
                updateAvatarPreview();
                
                // Actualizar selecci√≥n de botones
                updateSelectedColors();
            }
        }



        // Cerrar panel al hacer clic fuera
        document.addEventListener('click', (e) => {
            // Cerrar chat si est√° abierto y se hace clic fuera
            if (chatOpen && !chatPanel.contains(e.target) && !chatToggleBtn.contains(e.target)) {
                chatPanel.style.display = 'none';
                chatOpen = false;
                // Ocultar overlay
                const overlay = document.getElementById('ui-overlay');
                if (overlay) {
                    overlay.style.display = 'none';
                    overlay.style.pointerEvents = 'none';
                }
            }
            
            if (customizationPanelOpen && !customizationPanel.contains(e.target)) {
                closeCustomizationPanel();
            }
            
            // Cerrar panel de trabajo al hacer clic fuera
            const workingPanel = document.getElementById('working-customization-panel');
            if (workingPanel && !workingPanel.contains(e.target)) {
                closeWorkingPanel();
            }
        });

        // Agregar event listener al overlay para bloquear clics
        const overlay = document.getElementById('ui-overlay');
        if (overlay) {
            overlay.addEventListener('click', (e) => {
                // Bloquear TODOS los clics que pasen por el overlay
                e.stopPropagation();
                e.preventDefault();
                return false;
            });
        }

        // Cargar personalizaci√≥n al iniciar
        loadCustomization();

        function sendUserPosition() {
            if (userAlias) {
                // TODO: Enviar posici√≥n a Firebase
                // firebase.database().ref('positions').child(userAlias).set({ ... })
            }
        }

        function updateAvatarPosition(alias, position, floor, rotation = 0) {
            if (!position || typeof position.x !== 'number' || typeof position.y !== 'number' || typeof position.z !== 'number') {
                console.warn('Posici√≥n inv√°lida para alias:', alias, position);
                return;
            }
            if (typeof floor !== 'number') {
                console.warn('Floor inv√°lido para alias:', alias, floor);
                return;
            }
            if (typeof rotation !== 'number') {
                console.warn('Rotaci√≥n inv√°lida para alias:', alias, rotation);
                return;
            }
            // No crear avatar para el usuario propio
            if (alias === userAlias) {
                return;
            }
            let avatar = userAvatars.get(alias);
            if (!avatar) {
                createUserAvatar(alias, position, floor);
                avatar = userAvatars.get(alias);
            }
            if (avatar) {
                const floorStep = HALL_HEIGHT + 1;
                const targetY = floor * floorStep + 0.4;
                avatar.targetPosition.set(position.x, targetY, position.z);
                avatar.currentFloor = floor;
                avatar.group.position.y = targetY;
                let normalizedRotation = rotation;
                while (normalizedRotation > Math.PI) normalizedRotation -= 2 * Math.PI;
                while (normalizedRotation < -Math.PI) normalizedRotation += 2 * Math.PI;
                avatar.targetRotation = normalizedRotation;
                const rotationDegrees = (normalizedRotation * 180 / Math.PI).toFixed(1);
                // Opcional: console.log(`Avatar ${alias} rotaci√≥n actualizada a: ${rotationDegrees}¬∞ (${normalizedRotation.toFixed(3)} rad)`);
            }
        }

        // Asegurar que el DOM est√© completamente cargado antes de inicializar
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        // Configurar overlay al cargar la p√°gina
        document.addEventListener('DOMContentLoaded', () => {
            const overlay = document.getElementById('ui-overlay');
            if (overlay) {
                overlay.style.pointerEvents = 'auto';
                overlay.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    return false;
                });
            }
        });

        
       

        // Mostrar prompt de alias si no existe
        if (!userAlias) {
            userAlias = prompt('Ingresa tu alias:');
            if (userAlias) {
                localStorage.setItem('userAlias', userAlias);
            } else {
                userAlias = 'Usuario_' + Math.floor(Math.random() * 10000);
                localStorage.setItem('userAlias', userAlias);
            }
        }

        // Funci√≥n centralizada para inicializar Firebase
        function initializeFirebase() {
            // Configurar botones de chat
            chatSendBtn.onclick = handleSendMessage;
            chatInput.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    handleSendMessage();
                }
            });

            // Configurar listeners de Firebase
            // Listener de mensajes
            messagesRef.off('child_added');
            messagesRef.on('child_added', (snapshot) => {
                const msg = snapshot.val();
                addMessageToChat(msg.alias, msg.message, msg.type, msg.timestamp);
            });

            // Listener de posiciones
            positionsRef.off('value');
            positionsRef.on('value', (snapshot) => {
                const positions = snapshot.val() || {};
                Object.keys(positions).forEach(alias => {
                    const data = positions[alias];
                    if (
                        alias !== userAlias &&
                        data &&
                        data.position && typeof data.position.x === 'number' &&
                        typeof data.position.y === 'number' &&
                        typeof data.position.z === 'number' &&
                        typeof data.floor === 'number' &&
                        typeof data.rotation === 'number'
                    ) {
                        updateAvatarPosition(alias, data.position, data.floor, data.rotation);
                    }
                });
                // Eliminar avatares de usuarios que ya no est√°n
                Object.keys(userAvatars).forEach(alias => {
                    if (!positions[alias] && alias !== userAlias) {
                        removeUserAvatar(alias);
                    }
                });
            });

 else {
            console.log('‚úÖ Firebase inicializado correctamente');
            // Inicializar Firebase cuando el usuario tenga un alias
            if (userAlias) {
                firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                console.log('‚úÖ Firebase inicializado correctamente');
            }





        function openSimplePanel() {
            const panel = document.getElementById('simple-panel');
            if (panel) {
                panel.style.display = 'block';
                customizationPanelOpen = true;
                // Inicializar vista previa del avatar
                updateAvatarPreview();
                // Inicializar los grids de colores
                createColorGrids();
                // Actualizar selecciones de colores
                updateSelectedColors();
            }
        }

        // Inicializaci√≥n robusta de colores de avatar
        if (typeof shirtColor === 'undefined' || shirtColor === null) shirtColor = 0x4ECDC4;
        if (typeof pantsColor === 'undefined' || pantsColor === null) pantsColor = 0x2C3E50;
        if (typeof shoesColor === 'undefined' || shoesColor === null) shoesColor = 0x8B4513;

        let privateRecipient = null;
        
        // UI: Al hacer clic en un usuario, activar modo privado
        usersList.addEventListener('click', function(e) {
            const userItem = e.target.closest('.user-item');
            if (userItem && !userItem.classList.contains('own')) {
                privateRecipient = userItem.textContent.replace(' (T√∫)', '').trim();
                chatInput.placeholder = `Mensaje privado a: ${privateRecipient}`;
                chatInput.focus();
                document.getElementById('private-mode-indicator')?.remove();
                const indicator = document.createElement('div');
                indicator.id = 'private-mode-indicator';
                indicator.textContent = `Modo privado con: ${privateRecipient}`;
                indicator.style = 'background:#FFD700;color:#222;padding:4px 10px;border-radius:6px;margin-bottom:4px;font-weight:bold;text-align:center;';
                chatInput.parentElement.insertBefore(indicator, chatInput);
                // Bot√≥n para salir del modo privado
                const exitBtn = document.createElement('button');
                exitBtn.textContent = 'Volver a chat p√∫blico';
                exitBtn.style = 'margin-left:10px;padding:2px 8px;border-radius:4px;border:none;background:#800000;color:#fff;cursor:pointer;font-size:12px;';
                exitBtn.onclick = function() {
                    privateRecipient = null;
                    chatInput.placeholder = 'Escribe un mensaje...';
                    indicator.remove();
                };
                indicator.appendChild(exitBtn);
            }
        });

        // Iniciar al conectar
        document.addEventListener('DOMContentLoaded', () => {
            connectToChat(userAlias);
            handleConnection();
        });
        // Limpiar al cerrar la p√°gina
        window.addEventListener('beforeunload', () => {
            positionInterval.stop();
            stopPositionUpdates();
            disconnectFromChat();
        });

        // --- Funci√≥n reutilizable para crear un avatar estilo Roblox ---
        function createRobloxAvatar(options) {
            const group = new THREE.Group();
            // Opciones y colores
            const shirtColor = options.shirtColor || 0x4ECDC4;
            const pantsColor = options.pantsColor || 0x2C3E50;
            const shoesColor = options.shoesColor || 0x8B4513;
            const skinColor = 0xFFE4C4;
            // Cabeza
            const headGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const headMaterial = new THREE.MeshStandardMaterial({ color: skinColor });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 1.7, 0);
            group.add(head);
            // Torso
            const bodyGeometry = new THREE.BoxGeometry(1, 1.2, 0.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: shirtColor });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0.9, 0);
            group.add(body);
            // Brazos
            const armGeometry = new THREE.BoxGeometry(0.35, 1, 0.35);
            const armMaterial = new THREE.MeshStandardMaterial({ color: shirtColor });
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.7, 1.1, 0);
            group.add(leftArm);
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.7, 1.1, 0);
            group.add(rightArm);
            // Piernas
            const legGeometry = new THREE.BoxGeometry(0.38, 1, 0.38);
            const legMaterial = new THREE.MeshStandardMaterial({ color: pantsColor });
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.25, 0.0, 0);
            group.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.25, 0.0, 0);
            group.add(rightLeg);
            // Zapatos
            const shoeGeometry = new THREE.BoxGeometry(0.38, 0.18, 0.38);
            const shoeMaterial = new THREE.MeshStandardMaterial({ color: shoesColor });
            const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            leftShoe.position.set(-0.25, -0.5, 0);
            group.add(leftShoe);
            const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            rightShoe.position.set(0.25, -0.5, 0);
            group.add(rightShoe);
            // Materiales para personalizaci√≥n en tiempo real
            group.bodyMaterial = bodyMaterial;
            group.pantsMaterial = legMaterial;
            group.shoeMaterial = shoeMaterial;
            return group;
        }

        // --- Funci√≥n para crear un avatar de usuario (propio o de otros) ---
        function createUserAvatar(alias, position = {x:0, y:0, z:0}, floor = 0, custom = {}) {
            if (userAvatars.has(alias)) return;
            // Obtener colores personalizados si existen
            const shirtColor = custom.shirtColor || 0x4ECDC4;
            const pantsColor = custom.pantsColor || 0x2C3E50;
            const shoesColor = custom.shoesColor || 0x8B4513;
            const avatarGroup = createRobloxAvatar({ shirtColor, pantsColor, shoesColor });
            avatarGroup.position.set(position.x, position.y, position.z);
            scene.add(avatarGroup);
            userAvatars.set(alias, {
                group: avatarGroup,
                targetPosition: new THREE.Vector3(position.x, position.y, position.z),
                targetRotation: 0,
                currentFloor: floor,
                bodyMaterial: avatarGroup.bodyMaterial,
                pantsMaterial: avatarGroup.pantsMaterial,
                shoeMaterial: avatarGroup.shoeMaterial
            });
        }

        // --- Animaci√≥n de movimiento estilo Roblox ---
        function animateRobloxAvatar(avatar, alias) {
            if (!avatar || alias === userAlias) return; // No animar el propio (lo ve en primera persona)
            // Calcular velocidad de movimiento
            const velocity = avatar.group.position.distanceTo(avatar.targetPosition);
            // Si se est√° moviendo, animar
            if (velocity > 0.01) {
                const time = performance.now() * 0.002 + avatar.group.position.x * 0.1;
                const swing = Math.sin(time * 8) * 0.4;
                // Brazos
                if (avatar.group.children[2]) avatar.group.children[2].rotation.x = swing; // leftArm
                if (avatar.group.children[3]) avatar.group.children[3].rotation.x = -swing; // rightArm
                // Piernas
                if (avatar.group.children[4]) avatar.group.children[4].rotation.x = -swing; // leftLeg
                if (avatar.group.children[5]) avatar.group.children[5].rotation.x = swing; // rightLeg
            } else {
                // Si est√° quieto, mantener la rotaci√≥n actual
                if (avatar.group.children[2]) avatar.group.children[2].rotation.x = avatar.group.children[2].rotation.x;
                if (avatar.group.children[3]) avatar.group.children[3].rotation.x = avatar.group.children[3].rotation.x;
                if (avatar.group.children[4]) avatar.group.children[4].rotation.x = avatar.group.children[4].rotation.x;
                if (avatar.group.children[5]) avatar.group.children[5].rotation.x = avatar.group.children[5].rotation.x;
            }
        }
    </script>
</body>
</html>